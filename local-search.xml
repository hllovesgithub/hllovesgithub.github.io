<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Products</title>
    <link href="/2020/05/04/2020-05-04-Products/"/>
    <url>/2020/05/04/2020-05-04-Products/</url>
    
    <content type="html"><![CDATA[<h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><ul><li><p><a href="https://apps.apple.com/th/app/shopeepay-no-1-mobile-wallet/id908669202">ShopeePay</a></p></li><li><p><a href="https://apps.apple.com/th/app/shopee-2-2-%E0%B8%84-%E0%B8%99-%E0%B8%84%E0%B8%AD%E0%B8%A2%E0%B8%99-%E0%B8%84-%E0%B8%A1/id959841453">Shopee</a></p></li><li><p><a href="https://apps.apple.com/cn/app/seatalk-cn/id1436472621?l=en">SeaTalk</a></p></li></ul><h3 id="macOS-Video"><a href="#macOS-Video" class="headerlink" title="macOS - Video"></a>macOS - Video</h3><ul><li><p><a href="https://apps.apple.com/cn/app/photo-movie-maker-your-slideshow-builder/id453163102?mt=12">Photo Movie Maker-your slideshow builder</a></p></li><li><p><a href="https://apps.apple.com/cn/app/photo-slideshow-photo-video/id1000901527?mt=12">Photo Slideshow-Photo Video</a></p></li><li><p><a href="https://apps.apple.com/cn/app/slideshow-maker-hd-photo-movie-lite/id1014830960?mt=12">Slideshow Maker HD-Photo Movie Lite</a></p></li><li><p><a href="https://apps.apple.com/cn/app/photo-slideshow-dvd-slideshow1/id1029247120?mt=12">Photo Slideshow-DVD Slideshow</a></p></li><li><p><a href="https://apps.apple.com/cn/app/photo-video-photo-slideshow/id956396273?mt=12">Photo Video-Photo Slideshow</a></p></li><li><p><a href="http://www.quicksoftwarez.com/support/finemoviecreator">Fine Movie Creator</a></p></li></ul><h3 id="macOS-Image"><a href="#macOS-Image" class="headerlink" title="macOS - Image"></a>macOS - Image</h3><ul><li><p><a href="https://apps.apple.com/cn/app/photo-edit-photo-image-cut-pro/id1469178659?mt=12">Photo Edit-Photo Image Cut Pro</a></p></li><li><p><a href="https://apps.apple.com/cn/app/photo-collage-photo-poster-hd/id1000916378?mt=12">Photo Collage-Photo Poster HD</a></p></li><li><p><a href="https://apps.apple.com/cn/app/poster-maker-pro-collage/id958459191?mt=12">Poster Maker Pro-Collage</a></p></li><li><p><a href="https://apps.apple.com/cn/app/photo-edit-pro-erase-clear-effect-rotate/id1015369518?mt=12">Photo Edit Pro-Erase Clear Effect Rotate</a></p></li><li><p><a href="https://apps.apple.com/cn/app/photo-focus-splash-color-pro/id1064031195?mt=12">Photo Focus &amp; Splash Color Pro</a></p></li><li><p><a href="https://apps.apple.com/cn/app/photo-mosaic-pro/id1024919377?mt=12">Photo Mosaic Pro</a></p></li><li><p><a href="http://www.greatdy.com/mac-os-x/picture-collage-maker-pro">Picture Collage Maker Pro</a></p></li><li><p><a href="http://www.digitalsoftteam.com/mac-os-x/image-editor-pro">Image Editor Pro</a></p></li><li><p><a href="http://www.quicksoftwarez.com/mac-os-x/fine-photo-collage-pro">Fine Photo Collage Pro</a></p></li></ul><h3 id="macOS-Audio"><a href="#macOS-Audio" class="headerlink" title="macOS - Audio"></a>macOS - Audio</h3><ul><li><p><a href="https://apps.apple.com/cn/app/audio-edit-pro-audio-editor/id984332192?mt=12">Audio Edit Pro-Audio Editor</a></p></li><li><p><a href="https://apps.apple.com/cn/app/audio-studio-redux/id1030961103?mt=12">Audio Studio Redux</a></p></li><li><p><a href="https://apps.apple.com/cn/app/audio-record-diary-recorder/id1059990365?mt=12">Audio Record Diary-Recorder</a></p></li><li><p><a href="https://apps.apple.com/cn/app/audio-course-note-recorder/id1105701078?mt=12">Audio Course Note Recorder</a></p></li><li><p><a href="https://apps.apple.com/cn/app/audio-trim-split-audio-editor1/id977490657?mt=12">Audio Trim Split-Audio Editor</a></p></li></ul><hr>]]></content>
    
    
    
    <tags>
      
      <tag>Archive</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Collections Extention</title>
    <link href="/2016/03/06/2016-02-28-Collections-Extention/"/>
    <url>/2016/03/06/2016-02-28-Collections-Extention/</url>
    
    <content type="html"><![CDATA[<h3 id="NSPointerFunctiosn"><a href="#NSPointerFunctiosn" class="headerlink" title="NSPointerFunctiosn"></a>NSPointerFunctiosn</h3><p>The functions specified by an instance of NSPointerFunctions are separated into two clusters—those that define “<strong>personality</strong>” such as “object” or “C-string”, and those that describe <strong>memory management issues</strong> such as a memory deallocation function.</p><p>NSPointerArray、NSMapTable和NSHashTable使用NSPointerFunctions对象为存储其中的对象定义了获取和保留行为。内存和个性选项分为两大组：<strong>内存选项</strong>决定了内存管理，<strong>个性选项</strong>决定了哈希和相等。</p><ul><li><p><strong>NSPointerFunctionsStrongMemory</strong>(10.5~)</p><p>  使用strong写屏障后备存储，默认的内存选项。配合对象个性选项，使用retain和release；配合非对象选项，那就和NSPointerFunctionsMallocMemory一样。</p></li><li><p><strong>NSPointerFunctionsZeroingWeakMemory</strong>(10.5~10.8)</p><p>  使用弱读写屏障，保留一个non-retained对象指针。</p></li><li><p><strong>NSPointerFunctionsOpaqueMemory</strong>(10.5~)</p><p>  指针删除时没有任何操作，通常用来保留任意指针。获取内存方法只用于copy-in，释放内存方法没有任何动作。这个选项对于对象而言不是一个好选择。</p></li><li><p><strong>NSPointerFunctionsMallocMemory</strong>(10.5~)</p><p>  用calloc()拷贝，用free()释放。</p></li><li><p><strong>NSPointerFunctionsMachVirtualMemory</strong>(10.5~)</p><p>  用Mach内存</p></li><li><p><strong>NSPointerFunctionsWeakMemory</strong>(10.8~)</p><p>  在ARC中使用weak读写屏障，释放后指针变为NULL。</p></li><li><p><strong>NSPointerFunctionsObjectPersonality</strong>(10.5~)</p><p>  用hash实现哈希，用isEqual实现相等，用description实现描述，默认的个性选项。配合强内存选项，使用retain和release。</p></li><li><p><strong>NSPointerFunctionsOpaquePersonality</strong>(10.5~)</p><p>  用移位指针实现哈希，用指针值实现相等。</p></li><li><p><strong>NSPointerFunctionsObjectPointerPersonality</strong>(10.5~)</p><p>  用移位指针实现哈希，用指针值实现相等，用description实现描述。配合强内存选项，使用retain和release。</p></li><li><p><strong>NSPointerFunctionsCStringPersonality</strong>(10.5~)</p><p>  用字符串的哈希方法实现哈希，用strcmp实现相等，用’%s’实现描述。</p></li><li><p><strong>NSPointerFunctionsStructPersonality</strong>(10.5~)</p><p>  用内存哈希方法实现哈希，用memcmp实现相等。</p></li><li><p><strong>NSPointerFunctionsIntegerPersonality</strong>(10.5~)</p><p>  用移位指针实现哈希，用指针值实现相等。</p></li><li><p><strong>NSPointerFunctionsCopyIn</strong>(10.5~)</p><p>  把实体加入到集合中时，使用获取内存方法开辟内存并拷贝实体。</p></li></ul><hr><h3 id="NSPointerArray"><a href="#NSPointerArray" class="headerlink" title="NSPointerArray"></a>NSPointerArray</h3><p>NSPointerArray is a mutable collection modeled after <strong>NSArray</strong> but it can also <strong>hold NULL</strong> values, which can be inserted or extracted (and which contribute to the object’s count). Moreover, unlike traditional arrays, you can set the count of the array directly.</p><p>方便的构造函数：</p><ul><li>strongObjectsPointerArray(强对象数组)</li><li>weakObjectsPointerArray(若对象数组)</li></ul><p>所有涉及到index的API，都需要注意其值不应该大于count，否则会有异常。allObjects方法可以将存储的所有有效对象(NULL被过滤)构建成一个NSArray，其中非对象实体会产生异常因为retain。</p><p>在性能方面，NSPointerArray真的非常非常慢，所以打算在一个很大的数据集合上使用它的时候一定要三思。</p><hr><h3 id="NSMapTable"><a href="#NSMapTable" class="headerlink" title="NSMapTable"></a>NSMapTable</h3><p>NSMapTable is a mutable collection modeled after <strong>NSDictionary</strong> but provides different options: </p><ul><li>The major option is to have keys and/or values held “<strong>weakly</strong>” in a manner that entries are removed when one of the objects is reclaimed.</li><li>Its keys or values may be <strong>copied</strong> on input or may use pointer identity for <strong>equality</strong> and <strong>hashing</strong>.</li><li>It can contain <strong>arbitrary pointers</strong> (its contents are not constrained to being objects).</li></ul><p>方便的构造函数：</p><ul><li>strongToStrongObjectsMapTable(强key强value)</li><li>weakToStrongObjectsMapTable(弱key强value)</li><li>strongToWeakObjectsMapTable(强key弱value)</li><li>weakToWeakObjectsMapTable(弱key弱value)</li></ul><p>除了NSPointerFunctionsCopyIn，默认行为都会strong-retain(或weak-assign)key而不会copy，与CFDictionary行为相同而与NSDictionary不同。当需要一个字典，它的键没实现NSCopying协议时候非常有用。</p><p>NSMapTable只比NSDictionary略微慢一点。如果需要一个不retain键的字典，放弃CFDictionary使用它吧。</p><hr><h3 id="NSHashTable"><a href="#NSHashTable" class="headerlink" title="NSHashTable"></a>NSHashTable</h3><p>NSHashTable is modeled after <strong>NSSet</strong> but provides different options, in particular to support weak relationships:</p><ul><li>It can hold <strong>weak</strong> references to its members.</li><li>Its members may be copied on input or may use pointer identity for <strong>equality</strong> and <strong>hashing</strong>.</li><li>It can contain <strong>arbitrary pointers</strong> (its members are not constrained to being objects).</li></ul><p>方便的构造函数：</p><ul><li>weakObjectsHashTable(弱对象哈希表)</li><li>hashTableWithOptions:(某类型哈希表)</li></ul><p>哈希表可以保持对对象的弱引用并在对象被销毁之后正确的将其移除 — 一些手动添加到NSSet的时候非常恶心的事情。</p><p>如果只是需要NSSet的特性，请坚持使用NSSet。NSHashTable在添加对象时花费了将近2倍的时间，但是其他方面的效率却非常相近。</p><hr><h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><p><a href="http://objcio.com/blog/2014/01/20/the-foundation-collection-classes/">基础集合类</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective Objective-C 读书笔记-下</title>
    <link href="/2016/01/24/2016-01-24-Effective-Objective-C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%8B/"/>
    <url>/2016/01/24/2016-01-24-Effective-Objective-C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="用handle块降低代码分散度"><a href="#用handle块降低代码分散度" class="headerlink" title="用handle块降低代码分散度"></a>用handle块降低代码分散度</h3><p>编写界面代码时，常会用到<strong>异步执行任务</strong>(perform task asynchronously)范式，其好处在于处理界面和用户交互的主线程不会因为要执行I/O或网络通信这类耗时任务而被阻塞。同步执行耗时任务时，用户界面变得无法响应用户输入，甚至因为长时间不响应而被系统终止执行。</p><p>异步常见的模式是实用delegate进行异步回调，这种方法确实可行，而且也没有什么错误：</p><pre><code>// DataFetcher.h@class DataFetcher;@protocol DataFetcherDelegate- (void)dataFetcher:(DataFetcher *)fetcher didGetData:(NSData *)data;@end@interface DataFetcher@property (nonatomic,readwrite,assign) id&lt;DataFetcherDelegate&gt; delegate;+ (instance)dataFetcherWithURL:(NSURL *)url;- (void)start;@end// Other.m- (void)fetcherData &#123;    DataFetcher *fetcher = [DataFetcher dataFetcherWithURL:someURL];    fetcher.delegate = self;    [fetcher start];&#125;...- (void)dataFetcher:(DataFetcher *)fetcher didGetData:(NSData *)data &#123;    _fetcherData = data;&#125;</code></pre><p>然而如果使用block，代码更清晰易懂，逻辑更紧凑简洁：</p><pre><code>// DataFetcher.htypedef void(^DataFetcherCompletion)(NSData *data);- (void)startWithCompletion:(DataFetcherCompletion)handler;// Other.m- (void)fetcherData &#123;    DataFetcher *fetcher = [DataFetcher dataFetcherWithURL:someURL];    [fetcher startWithCompletion:^(NSData *data) &#123;        _fetcherData = data;    &#125;];&#125;</code></pre><p>delegate有个缺点，多个委托对象在同一个回调中要进行区分。这不仅会让回调方法里因判断分支而变长，导致代码激增。使用block不需要：</p><pre><code>// Delegate- (void)fetcherDataA &#123;    _fetcherA = [DataFetcher dataFetcherWithURL:someURLA];    _fetcherA.delegate = self;    [_fetcherA start];&#125;- (void)fetcherDataB &#123;    _fetcherB = [DataFetcher dataFetcherWithURL:someURLB];    _fetcherB.delegate = self;    [_fetcherB start];&#125;...- (void)dataFetcher:(DataFetcher *)fetcher didGetData:(NSData *)data &#123;    if (fetcher == _fetcherA) &#123;        _fetcherDataA = data;        _fetcherA = nil;    &#125; else if (fetcher == _fetcherB) &#123;        _fetcherDataB = data;        _fetcherB = nil;    &#125;&#125;// Block- (void)fetcherDataA &#123;    DataFetcher *fetcher = [DataFetcher dataFetcherWithURL:someURL];    [fetcher startWithCompletion:^(NSData *data) &#123;        _fetcherDataA = data;    &#125;];&#125;- (void)fetcherData &#123;    DataFetcher *fetcher = [DataFetcher dataFetcherWithURL:someURL];    [fetcher startWithCompletion:^(NSData *data) &#123;        _fetcherDataB = data;    &#125;];&#125;</code></pre><p>block协会发还有其他用途，比如很多基于block的API用来处理错误：</p><pre><code>// Atypedef void(^DataFetcherCompletion)(NSData *data);typedef void(^DataFetcherError)(NSError *error);- (void)startWithCompletion:(DataFetcherCompletion)handler failure:(DataFetcherError)failure;// Btypedef void(^DataFetcherCompletion)(NSData *data, NSError *error);- (void)startWithCompletion:(DataFetcherCompletion)handler;</code></pre><p>对于方案A，成功和失败分别处理，使代码更易懂，有需要还可以省略不想处理的情况。对于方案B，全部逻辑放在一起会变得更长更复杂，但也更灵活，比如如果出现错误也可以继续使用已有的data等。Apple的API几乎都是基于方案B。基于handle设计API还有个原因，就是某些代码必须在特定线程上运行。由API的调用者根据需要设置参数，使得将指定代码块运行在指定线程中变得非常方便：</p><pre><code>- (id)addObserverForName:(NSString *)name object:(id)object queue:(NSOerationQueue *)queue usingBlock:(void(^)(NSNotification *))block;</code></pre><hr><h3 id="多用派发队列，少用同步锁"><a href="#多用派发队列，少用同步锁" class="headerlink" title="多用派发队列，少用同步锁"></a>多用派发队列，少用同步锁</h3><p>objc中的同步块@synchronized(id){}会根据给定的对象自动创建一个锁，进入括号前阻塞获取同步锁，执行完代码离开括号时释放同步锁。@synchronized的问题在于提供值，它相当于锁的ID。一般都是具有统一资源竞争相关性的代码片段对应同一个ID，如果滥用导致有大量相同ID的@synchronized存在，那么必然会降低代码效率。另一个方法是直接使用NSLock，同步执行前lock，执行完毕后unlock。</p><p>GCD能以更简单更高效的形式为代码同步加锁。比如某属性的存取方法：</p><pre><code>_syncQueue = dispatch_queue_create(&quot;SyncQueueForProperty&quot;, DISPATCH_QUEUE_SERIAL);- (NSString *)something &#123;    __block NSString *something = nil;    dispatch_sync(_syncQueue, ^() &#123;        something = _something;    &#125;);    return something;&#125;- (void)setSomething:(NSString *)something &#123;    dispatch_async(_syncQueue, ^() &#123;        _something = something;    &#125;);&#125;</code></pre><p>串行队列确保block同步执行。存方法使用异步派发可能比同步派发要慢，因为GCD异步派发需要拷贝block，但是如果block内的代码本身是比较耗时的话，同步执行会阻塞调用线程，而且同步获取是为了获取正确的值，同步设置本身也没有什么意义。多个取方法同能同时并发执行，而多个存取方法不能并发执行。所以改用并行队列会更快，同时使用GCD的<strong>栅栏</strong>(barrier)功能确保存方法单个执行：</p><pre><code>_syncQueue = dispatch_queue_create(&quot;SyncQueueForProperty&quot;, DISPATCH_QUEUE_CONCURRENT);- (NSString *)something &#123;    __block NSString *something = nil;    dispatch_sync(_syncQueue, ^() &#123;        something = _something;    &#125;);    return something;&#125;- (void)setSomething:(NSString *)something &#123;    dispatch_barrier_async(_syncQueue, ^() &#123;        _something = something;    &#125;);&#125;</code></pre><hr><h3 id="多用GCD，少用performSelector"><a href="#多用GCD，少用performSelector" class="headerlink" title="多用GCD，少用performSelector"></a>多用GCD，少用performSelector</h3><p>objc本质上是一门非常动态的语言，其定义了一些performSelector方法，令开发者可以随意调用任何方法。</p><p><strong>一般方法</strong>：</p><ul><li>(id)performSelector:(SEL)aSelector;</li><li>(id)performSelector:(SEL)aSelector withObject:(id)anObject;</li><li>(id)performSelector:(SEL)aSelector withObject:(id)anObject withObject:(id)anotherObject;</li></ul><p>这些方法看上去似乎有些多余，但是其真正的用意是运行时利用选择子进行多重动态绑定：</p><pre><code>SEL selector;if (Condition1) &#123;    selector = @selector(foo);&#125; else if (Condition2) &#123;    selector = @selector(bar);&#125; else &#123;    selector = @selector(baz);&#125;[object performSelector:selector];</code></pre><p>所以这种方式极为灵活，经常可以用来简化复杂代码。还有一种方法，先把selector保存起来等到特定事件发生后再调用。不管哪种，编译器都不知道selector是什么，必须要等到运行时才能最终确定。但是其代价是，虽然@selector可以检查方法名的合法性，但是selector终究是个NSString*类型的变量，可以被赋成任何值，所以可能因缺少编译器类型检查的帮助而引起调用不存在方法的问题。另外，编译器不知道将调用的selector是什么，所以不了解方法签名及返回值，甚至连是否有返回值都不清楚，基于方法名称来进行内存管理的ARC没法判断了。为了谨慎起见，ARC不添加释放操作，于是可能造成内存泄漏：</p><pre><code>SEL selector;if (Condition1) &#123;    selector = @selector(newObject);&#125; else if (Condition2) &#123;    selector = @selector(copy);&#125; else &#123;    selector = @selector(someProperty);&#125;id ret = [object performSelector:selector];</code></pre><p>对于返回值，如果返回的是基本类型，则还需要转换工作。因为id类型表示指向人意objc对象的指针，如果返回的是自定义类型(如struct)其大小如果超出所在架构的指针大小，则还不能正确返回。同理可知传入参数也一样，而且明显的是参数个数受限。然而，block方法签名也有明确定义，内部可以引用任何类型任何个数的参数。</p><p><strong>延迟执行方法</strong>：</p><ul><li>(void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay;</li><li>(void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray&lt;NSString *&gt; *)modes;</li></ul><p>很快会发现，这些方法都无法处理多个参数的selector。然而，dispatch_after可以实现相同的功能。</p><p><strong>线程功能方法</strong>：</p><ul><li>(void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg;</li><li>(void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;</li><li>(void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait</li></ul><p>同样，这些方法都无法处理多个参数的selector。</p><hr><h3 id="选择GCD还是NSOperationQueue"><a href="#选择GCD还是NSOperationQueue" class="headerlink" title="选择GCD还是NSOperationQueue"></a>选择GCD还是NSOperationQueue</h3><p>使用NSOperation的好处：</p><p><strong>取消某个Operation</strong>：使用NSOperationQueue，想要取消Operation是很容易的。在运行Operation之前，可以调用cancel方法将Operation内部设置标志位，用于表明此Operation不需要执行。不过已经执行的Operation无法取消。GCD就不能做到这一点。虽然说可以自己实现，但是需要编写很多代码，而这些代码都是NSOperationQueue已经实现好了的。</p><p><strong>指定Operation之间的依赖关系</strong>：一个Operation可以依赖其它多个Operation，建立依赖体系，值特定Operation在另一个Operation完成后才能执行。</p><p><strong>支持KVO观测</strong>：Operation有许多属性适合KVO观测，比如通过isCancelled来判断是否已取消，比如通过isFinished来判断是否已完成。能在某个Operation变更状态时得到通知，控制比GCD更精细。</p><p><strong>指定Operation的优先级</strong>：Operation的优先级统一队列中各个Operation之间的优先关系。优先级高的先执行，优先级低的后执行。GCD只是队列有优先级，但是同一queue中的各个block之间没有优先级。</p><p><strong>重用Operation对象</strong>：Apple已经实现了一下NSOperation子类比如NSBlockOperation。可以根据需要自己创建特制的Operation，能够存放任何信息，Operation执行时可以充分利用这些信息，还可以随意调用定义的方法，这就比GCD那些简单的block要强大得多。</p><hr><h3 id="不要使用dispatch-get-current-queue"><a href="#不要使用dispatch-get-current-queue" class="headerlink" title="不要使用dispatch_get_current_queue"></a>不要使用dispatch_get_current_queue</h3><p>dispatch_get_current_queue有种典型的错误用法(antipattern)，就是用它来检测当前队列是不是某个特定队列，试图以此来避免执行同步派发时可能不要的死锁问题。考虑下面的代码：</p><pre><code>- (NSString *)someString &#123;    __block NSString *someString = nil;    dispatch_sync(_syncQueue, ^() &#123;        someString = _someString;    &#125;);    return someString;&#125;- (void)setSomestring &#123;    dispatch_async(_syncQueue, ^() &#123;        _someString = someString;    &#125;);&#125;</code></pre><p>这种写法的问题在于，如果调用getter的线程就是同一个_syncQueue，那么可能会产生死锁。得知dispatch_get_current_queue后，也许觉得可以用它改写使得getter方法变得<strong>可重入</strong>，只需要检测当前队列是否为同步操作所针对的队列，如果是，就不派发直接执行：</p><pre><code>- (NSString *)someString &#123;    __block NSString *someString = nil;    dispatch_block_t task = ^() &#123;        someString = _someString;    &#125;;    if (dispatch_get_current_queue() == _syncQueue) &#123;        task();    &#125; else &#123;        dispatch_sync(_syncQueue, task);    &#125;    return someString;&#125;</code></pre><p>这种做法可以处理一些简单的情况。不过仍然有死锁的可能：</p><pre><code>dispatch_queueu_t queueA = dispatch_queue_create(&quot;QueueA&quot;, DISPATCH_QUEUE_SERIAL);dispatch_queueu_t queueB = dispatch_queue_create(&quot;QueueB&quot;, DISPATCH_QUEUE_SERIAL);dispatch_sync(queueA, ^() &#123;    dispatch_sync(queueB, ^() &#123;        dispatch_sync(queueA, ^() &#123;            // Deadlock        &#125;);    &#125;);&#125;);</code></pre><p>这段代码执行到最内层时总会死锁。按照之前认为的办法使用dispatch_get_current_queue进行检测：</p><pre><code>dispatch_sync(queueA, ^() &#123;    dispatch_sync(queueB, ^() &#123;        dispatch_block_t task = ^() &#123;...&#125;;        if (dispatch_get_current_queue() == queueA) &#123;            task();        &#125; else &#123;            dispatch_sync(queueA, task);        &#125;    &#125;);&#125;);</code></pre><p>然而这样也不行，因为dispatch_get_current_queue返回的<strong>仅仅是当前执行block的队列</strong>，也就是queueB。这样queueA的同步派发依然会执行，和之前一样还是死锁。正确的做法是：确保存取方法<strong>不可重入</strong>，同步队列绝不访问同步队列。由于派发队列是一种极为轻量的机制，为了每项属性都有专用的同步队列，不妨创建多个队列。</p><p>队列之间会形成一套层级体系，这意味着排在某队列中的block，会在其<strong>上级队列</strong>(parent queue)里执行。层级地位最高的队列总是<strong>全局并发队列</strong>。</p><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1f059mnna4rj20ou0g6q4b.jpg"></p><p>由于队列间有层级关系，所以dispatch_get_current_queue就起不到作用。比如QueueC中的block为以为当前是queueC，那么queueA上执行就没问题，实际上这依然会死锁。解决这个问题的办法是，通过GCD提供的功能来设定<strong>队列特定数据</strong>(queue-specific data)，它可以将任意数据以<strong>健值对</strong>的形式<strong>关联</strong>到队列中。最重要的是，如果当前队列没有找到给定健对应的值，那么GCD会<strong>沿着层级系统向上查找直到找到或者到达根队列</strong>：</p><pre><code>dispatch_queue_t queueA = dispatch_queue_create(&quot;queueA&quot;, DISPATCH_QUEUE_SERIAL);dispatch_queue_t queueB = dispatch_queue_create(&quot;queueB&quot;, DISPATCH_QUEUE_SERIAL);dispatch_set_target_queue(queueB, queueA);static int kSpecific;CFStringRef value = CFSTR(&quot;queueA&quot;);dispatch_queue_set_specific(queueA, &amp;kSpecific, (void *)value, (dispatch_function_t)CFRelease);dispatch_sync(queueB, ^&#123;    dispatch_block_t block = ^(void) &#123;        NSLog(@&quot;No deadlock&quot;);    &#125;;        CFStringRef value = dispatch_get_specific(&amp;kSpecific);    if (value) &#123;        block();    &#125; else &#123;        dispatch_sync(queueA, block);    &#125;&#125;);</code></pre><p>使用队列特定数据提供的这套简单易用的机制，就能避免使用dispatch_get_current_queue时经常遭遇的陷进。</p><hr><h3 id="对自定义内存语义的collection使用无缝桥接-toll-free-bridging"><a href="#对自定义内存语义的collection使用无缝桥接-toll-free-bridging" class="headerlink" title="对自定义内存语义的collection使用无缝桥接(toll-free bridging)"></a>对自定义内存语义的collection使用无缝桥接(toll-free bridging)</h3><p>在使用Foundation的NSDictionary时会遇到一个大问题，那就是key的内存管理是copy，value的内存管理是retian。除非使用强大的无缝桥接技术，否则无法改变其语义。CoreFoudation的字典类型叫做CFDictionary，可变版本为CFMutableDictionary。创建CFMutableDictionary是可以通过下列方法来指定key和value的内存语义：</p><pre><code>CFMutableDictionaryRef CFDictionaryCreateMutable(    CFAllocatorRef allocator,    CFIndex capacity,    const CFDictionaryKeyCallBacks *keyCallBacks,    const CFDictionaryValueCallBacks *valueCallBacks)</code></pre><p><strong>allocator</strong>表示将要使用的内存分配器。CoreFoundation的数据结构需要占用内存，而分配器负责分配及回收这些内存。通常传入NULL，表示使用默认的分配器。<strong>capacity</strong>表示字典初始化大小。<strong>keyCallBacks</strong>和<strong>valueCallBacks</strong>定了许多回调函数，用于指示key和value在遇到各种事件时应该执行何种操作：</p><pre><code>struct CFDictionaryKeyCallBacks &#123;    CFIndex version;    CFDictionaryRetainCallBack retain;    CFDictionaryReleaseCallBack release;    CFDictionaryCopyDescriptionCallBack copyDescription;    CFDictionaryEqualCallBack equal;    CFDictionaryHashCallBack hash;&#125;;struct CFDictionaryValueCallBacks &#123;    CFIndex version;    CFDictionaryRetainCallBack retain;    CFDictionaryReleaseCallBack release;    CFDictionaryCopyDescriptionCallBack copyDescription;    CFDictionaryEqualCallBack equal;&#125;;</code></pre><p>version表示数据结构的版本号，目前为0。结构体中其余都是函数指针，定义了各种事件发生时采用哪个函数来执行相关任务。例如retain函数的原型：</p><pre><code>typedef const void* (*CFDictionaryRetainCallBack) (CFAllocatorRef allocator, const void *value);</code></pre><p>其中value表示即将加入字典的key或value，void*表示最终加入字典的值。</p><pre><code>const void* CustomCallback(CFAllocatorRef allocator, const void *value) &#123;    return value;&#125;</code></pre><p>CustomCallback则表示将值照原样返回，如果用它来充当retian的回调函数，那么字典就不会保留key或value了。和无缝桥接搭配起来，就能创造出特殊的NSDictionary对象：</p><pre><code>const void* EOCRetainCallback(CFAllocatorRef allocator, const void *value) &#123;    return CFRetain(value);&#125;const EOCReleaseCallback(CFAllocatorRef allocator, const void *value) &#123;    CFRelease(value);&#125;CFDictionaryKeyCallBacks keyCallbacks = &#123;    0,    EOCRetainCallback,    EOCReleaseCallback,    NULL,    CFEqual,    CFHash&#125;;CFDictionaryValueCallBacks valueCallbacks = &#123;    0,    EOCRetainCallback,    EOCReleaseCallback,    NULL,    CFEqual&#125;;CFMutableDictionaryRef aCFDictionary = CFDictionaryCreateMutable(NULL,0,&amp;keyCallbacks,&amp;valueCallbacks);NSMutableDictionary *anNSDictionary = (__bridge_transfer NSMutableDictionary *)aCFDictionary;</code></pre><p>因为NSMutableDictionary默认会copy传入的key，如果key不遵循NSCopying协议，那么会有unrecognized selector运行期错误。但是这个NSDictionary就能对key进行retain而非copy。这对于要求key必须实现NSCopying协议要更实用的多。</p><hr><h3 id="构建缓存时选择NSCache而非NSDictionary"><a href="#构建缓存时选择NSCache而非NSDictionary" class="headerlink" title="构建缓存时选择NSCache而非NSDictionary"></a>构建缓存时选择NSCache而非NSDictionary</h3><p>对于那些重新计算起来很费事儿的对象，比如通过网络或者磁盘获取的对象可以缓存在内存中，来提高程序响应速度。Foundation专门为缓存需求而创建了一个类NSCache，其胜过NSDictionary在于，当系统资源将要耗尽时可以自动根据规则，先行删减最久未使用的缓存。同时NSCache对key不要求copy而是retain，对于不支持NSCopying的对象来说更方便。最重要的是，NSCache是<strong>线程安全</strong>的，多线程可以同时访问NSCache。我们可以调整NSCache行为，一个是<strong>缓存对象总数</strong>，一个是<strong>缓存总开销</strong>。当NSCache总数或者总开销超过上限时，就可能会删减其中的对象。将对象加入NSCache时会要求指定其<strong>开销</strong>，因为使用NSCache的目的就是为了提高程序响应用户操作的速度，所以计算该开销值时不应该很耗时很复杂，比如必须访问磁盘或者数据库才能决定具体数值。</p><p>还有个类叫<strong>NSPurgeablData</strong>，它是NSMutableData的子类实现了NSDiscardableContent协议，在系统资源紧张时可以根据需要随时被丢弃。如果需要访问某个NSPurgeablData，先调用<strong>beginContentAccess</strong>，确保访问期间的有效性，在使用完后调用<strong>endContentAccess</strong>，告诉系统你想丢就丢。这些方法可以嵌套，就像引用计数那样，只有平衡到0时才可以真正能被丢掉。NSCache中的NSPurgeablData对象被系统丢弃时也自动从NSCache中移除，通过<strong>evictsObjectsWithDiscardedContent</strong>来开启或关闭此功能。</p><pre><code>typedef void(^EOCNetworkFetcherCompletionHandler)(NSData *data);@interface EOCNetworkFetcher : NSObject- (id)initWithURL:(NSURL *)url;- (void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)handler;@end@interface EOCCustomer: NSObject@end@implementation EOCCustomer &#123;    NSCache *_cache;&#125;- (id)init &#123;    if (self = [super init]) &#123;        _cache = [NSCache new];        _cache.countLlimit = 100;        _cache.totalCostLimit = 5 * 1024 * 1024;    &#125;    return self;&#125;- (void)downloadDataForURL:(NSURL *)url &#123;    NSPurgeablData *cachedData = [_cache objectForKey:url];    if (cachedData) &#123;        [cachedData beginContentAccess];        [self useData:cachedData];        [cachedData endContentAccess];    &#125; else &#123;        EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url];        [fetcher startWithCompletionHandler:^(NSData *data) &#123;            NSPurgeablData *purgeablData = [NSPurgeablData dataWithData:data];            [_cache setObject:purgeablData forKey:url cost:purgeablData.length];            [self useData:data];            [purgeablData endContentAccess];        &#125;];    &#125;&#125;@end</code></pre><hr><h3 id="别忘记NSTimer会保留其target"><a href="#别忘记NSTimer会保留其target" class="headerlink" title="别忘记NSTimer会保留其target"></a>别忘记NSTimer会保留其target</h3><p>创建NSTimer的API都有一个target的参数，NSTimer会保留target直到自己<strong>失效</strong>：对任何timer调用invalidate都会失效，一次性timer完成任务后悔自动失效，重复性timer必须手动调用invalidate才会失效。由于timer会保留target，所以很容易引入循环引用的问题：</p><pre><code>@interface EOCDemo : NSObject- (void)startPolling;- (void)stopPolling;@end@implementation EOCDemo &#123;    NSTimer *_timer;&#125;- (void)dealloc &#123;    [_timer invalidate];&#125;- (void)startPolling &#123;    _timer = [NSTimer scheduledTimerWithTimeInterval:5.0 target:self selector:@selector(p_doPoll) userInfo:nil repeats:YES];&#125;- (void)stopPolling &#123;    [_timer invalidate];     _timer = nil;&#125;- (void)p_doPoll &#123;    ...&#125;</code></pre><p>self保留timer，timer保留self。只有调用stopPolling才能打破循环引用。但是，我们无法保证该类的使用者一定会记得调用stopPolling，万一忘记调用，内部timer是始终保留self的。外界对self的引用释放后，再也没有可以找到self的方法，那么self就成了永远无法寻找的<strong>内存泄漏</strong>。如果p_doPoll方法里还有其它消耗资源的操作，那么就会引出更多的问题。</p><pre><code>@interface NSTimer (EOCBlocksSupport)+ (NSTimer *)eoc_scheduledTimerWithTimeInterval:(NSTimerIntervavl)interval block:(void(^)())block repeats:(BOOL)repeats;@end@implementation NSTimer (EOCBlocksSupport)+ (NSTimer *)eoc_scheduledTimerWithTimeInterval:(NSTimerIntervavl)interval block:(void(^)())block repeats:(BOOL)repeats &#123;    return [self scheduledTimerWithInterval:interval target:self selector:@selector(eoc_blockInvoke:) userInfo:[block copy] repeats:repeats];&#125;+ (void)eoc_blockInvoke:(NSTimer *)timer &#123;     void (^block)() = timer.userInfo;     !block ?: block();&#125;</code></pre><p>外部对象保留timer，timer保留NSTimer类对象。解除原来的循环引用，不过需要注意，timer保留了userInfo，如果block里面直接或间接引用了外部对象的话，还是存在循环引用的问题。不过，这已经是block循环引用的问题了，很好办：</p><pre><code>- (void)startPolling &#123;    __weak EOCDemo *weakSelf = self;    _timer = [NSTimer eoc_scheduledTimerWithTimeInterval:5.0 block:^&#123;        __strong EOCDemo* strongSelf = self;        [strongSelf p_doPoll];    &#125; repeats:YES];&#125;</code></pre><p>这样，即使是重复模式，外界释放了对象后，只要block执行完一次，__strong离开作用域也会释放对象，从而实现了内存平衡。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective Objective-C 读书笔记-中</title>
    <link href="/2016/01/17/2016-01-17-Effective-Objective-C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%AD/"/>
    <url>/2016/01/17/2016-01-17-Effective-Objective-C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<h3 id="通过协议进行对象间通信"><a href="#通过协议进行对象间通信" class="headerlink" title="通过协议进行对象间通信"></a>通过协议进行对象间通信</h3><p>在委托方实现协议时，如果协议中某方法时可选的(optional)，那么就会写出一大批下面这样的模版代码：</p><pre><code> if ([_delegate respondsToSelector:@selector(someClassDidSomething)]) &#123;     [_delegate someClassDidSomething]; &#125; </code></pre><p>很容易用代码查处delegate是否能响应对应的选择子(selector)，可是如果频繁执行此操作，除了第一次检测的结果有用之外，后面的可能都是多余的。因为如果delegate本身没变的话，那么它原来响应的某个选择子突然不能响应了是不太可能的。鉴于此，通常把delegate能否响应某个协议方法这一信息缓存起来，以优化程序效率。最佳的实现途径是使用<strong>位段</strong>(bitfield)数据类型。这是一项乏人问津的C语言特性，此处却正合适。将结构体某个字段所占用的二进制位个数设为特定的值，比如这样：</p><pre><code>struct data &#123;    unsigned int fieldA : 8;    unsigned int fieldA : 4;    unsigned int fieldA : 2;    unsigned int fieldA : 1;&#125;</code></pre><p>结构体中，fieldA位段将占用8个二进制位，fieldB将占用4个，fieldC将占用2个，fieldD将占用1个。于是，filedA可以表示0到255之间的值，fieldD则可以表示0或1。可以像filedD这样，把delegate是否实现了协议中相关方法这一信息缓存起来。如果创建的结构体中只有大小为1的位段，那么就能把许多Boolean值塞入一小块数据里：</p><pre><code>@interface EOCNetworkFetcher () &#123;    struct &#123;        unsigned int didReceiveData         : 1;        unsigned int didFailWithError         : 1;        unsigned int didUpdateProgressTo     : 1;    &#125; _delegateFlags;&#125;@end// Set flag_delegateFlags.didReceiveData = 1;// Get flagif (didReceiveData.didReceiveData) &#123;    ...&#125;</code></pre><p>将这个结构体涌来缓存delegate是否能响应特定的选择子。实现缓存功能所用的代码可以写在delegate的设置方法里：</p><pre><code>- (void)setDelegate:(id&lt;EOCNetworkFetcherDelegate&gt;)delegate &#123;    _delegate = delegate;    _delegateFlags.didReceiveData = [delegate respondsToSelector:@selector(networkFetcher:didReceiveData:)];    _delegateFlags.didFailWithError = [delegate respondsToSelector:@selector(networkFetcher:didFailWithError:)];    _delegateFlags.didUpdateProgressTo = [delegate respondsToSelector:@selector(networkFetcher:didUpdateProgressTo:)];&#125;</code></pre><p>这样，每次调用delegate相关方法前，就不用再监测delegate是否能响应给定的选择子了，而是直接查询结构体的标志：</p><pre><code>if (_delegateFlags.didReceiveData) &#123;    [_delegate networkFetcher:self didUpdateProgressTo:currentProgress];&#125;</code></pre><p>对于那些频繁通过协议交换信息的情况，折线优化技术极有可能会提高程序效率。</p><hr><h3 id="将类的实现代码分散到便于管理的多个分类中"><a href="#将类的实现代码分散到便于管理的多个分类中" class="headerlink" title="将类的实现代码分散到便于管理的多个分类中"></a>将类的实现代码分散到便于管理的多个分类中</h3><p>在实现类的时候，往往是所有方法的代码全部堆在一个巨大的实现文件里。如果还向类中继续添加方法的话，实现文件就会越来越大，变得难于管理。</p><pre><code>// EOCPerson.h@interface EOCPerson : NSObject- (instance)initWithFirstName:(NSSting *)firstName lastName:(NSString *)lastName;- (void)addFriend:(EOCPerson *)person;- (void)removeFriend:(EOCPerson *)person;- (BOOL)isFriend:(EOCPerson *)person;- (void)performDayWork;- (void)takeVacationFromWork;- (void)goToTheCinema;- (void)goToSportsGame;@end// EOCPerson.m...</code></pre><p>这种情况下，可以通过Objc的<strong>分类</strong>(category)机制，把类代码按逻辑划入多个的易于管理的小部分。如果依然把整个类的定义都放在一个头文件中，实现都放在一个源文件中，随着功能的添加依然会膨胀得无法管理。其实可以把分类的声明和实现都单独分离出去：</p><pre><code>// EOCPerson.h@interface EOCPerson : NSObject- (instance)initWithFirstName:(NSSting *)firstName lastName:(NSString *)lastName;@end// EOCPerson.m...// EOCPerson+Friendship.h@interface EOCPerson (Friendship)- (void)addFriend:(EOCPerson *)person;- (void)removeFriend:(EOCPerson *)person;- (BOOL)isFriend:(EOCPerson *)person;@end// EOCPerson+Friendship.m...// EOCPerson+Wrok.h@interface EOCPerson (Wrok)- (void)performDayWork;- (void)takeVacationFromWork;@end// EOCPerson+Wrok.m...// EOCPerson+Play.h@interface EOCPerson (Play)- (void)goToTheCinema;- (void)goToSportsGame;@end// EOCPerson+Play.m...</code></pre><p>将代码打散到分类还有个好处，就是便于调试：对于某个分类的所有方法来说，分类名称都会出现在其符号中：</p><pre><code>-[EOCPerson(Friendship) addFriend:]</code></pre><p>在调试器的回溯信息中，会看到下面这样的内容：</p><pre><code>frame #2: 0x00001c50 Test &#39;-[EOCPerson(Friendship) addFriend:]&#39;+ 32 at main.m:46</code></pre><p>根据回溯信息中的分类名称，很容易就能精确定位到方法所属的功能分类，这对于某些应该视为私有的方法来说是极为有用的。通过创建Private的分类并放入所有私有方法，这样只要使用者有时在回溯信息中发现private一词就知道不应该直接调用此方法。</p><hr><h3 id="勿在分类中声明属性"><a href="#勿在分类中声明属性" class="headerlink" title="勿在分类中声明属性"></a>勿在分类中声明属性</h3><p>属性时封装数据的方式，尽管技术上分类也可以声明属性，但是还是要尽量避免。因为只有<strong>扩展分类</strong>(class-continuation)能够增加实例变量以外，其他的分类无法合成属性对应的实例变量。</p><pre><code>@interface EOCPerson (Friendship)@property (nonatomic,readwrite,assign) NSUInteger count;@end</code></pre><p>正确的做法是把所有的公开属性都定义在主接口里，所有的私有属性都定义在扩展分类里，这是唯一能够定义实例变量的地方。而属性只是定义实例变量和相关存取方法所用的<strong>语法糖</strong>，所以也应当遵循和定义实例变量一样的规则。分类应该理解为类扩展功能而非数据的一种方法。虽然只读方法可以不依赖实例变量，不需要自动合成实例变量，但是最好还是直接声明一个方法代替。</p><pre><code>// Wrong@interface EOCPerson (Friendship)@property (nonatomic,readonly,strong) NSArray *friends;@end// Right@interface EOCPerson (Friendship)- (NSArray *)friends;@end</code></pre><hr><h3 id="使用class-continuation隐藏实现细节"><a href="#使用class-continuation隐藏实现细节" class="headerlink" title="使用class-continuation隐藏实现细节"></a>使用class-continuation隐藏实现细节</h3><p>类中经常会包含一些无须对外公开的方法和实例变量，虽然也可以对外公布并注明@private，但是无论最少知识原则还是机密类型信息，都应该把不需要公开的隐藏在实现文件中。<strong>扩展分类</strong>(class-continuation)和普通分类不同，它必须定义在类的实现文件里，因为这是<strong>唯一能定义实例变量的分类</strong>。由于有稳固的ABI这一机制，使得无须知道对象的内存布局、内存大小就能使用它：</p><pre><code>// EOCPerson.h@interface EOCPerson : NSObject &#123;    NSString *_publicStr;&#125;@end// EOCPerson.m@interface EOCPerson () &#123;    NSString *_privateStr1;&#125;@end@implementation EOCPerson &#123;    NSString *_privateStr2;&#125;@end</code></pre><p>虽然机密类型可以放在公开类定义中并注明private，但是外界就知道了内部有一个机密的类型。如果使用id隐藏其类型信息，那么在内部实现中使用此实例时，没有类型信息就<strong>得不到编译器的帮助</strong>。没有必要为了隐藏某个内容而放弃编译器的类型检查功能。同理，对于没必要公开在外面造成类型污染的都应该如此考虑，比如编写Objc++代码时尤其有用。如果C++信息暴露在头文件，那么对应的实现文件的后缀名就要改成**.mm**。所有引用到此类的其它文件都会涉及到C++影响从而都需要将后缀改成.mm，这明显是我们不希望看到的。将对应的C++类型放到实现文件中的就可以很好的解决这个问题。同理，对于没有暴露在外部的本类遵循协议类型，因为编译器必须知道协议的具体内容，所以需要包含定义协议的头文件。如果放倒实现文件中，也可以避免所有包含了本类的文件都知道协议类型。</p><p>扩展分类还有一种用法，可以将public接口中声明为readonly的属性在扩展分类变为readwrite，以便在内部设置其值。通常不直接设置实例变量，而是通过属性设置。这样能触发外界的<strong>健值观测</strong>(Key-Value Observing)通知：</p><pre><code>// EOCPerson.h@interface EOCPerson : NSObject@property (nonatomic,readonly,copy) NSString *firstName;@property (nonatomic,readonly,copy) NSString *lastName;@end// EOCPerson.m@interface EOCPerson ()@property (nonatomic,readwrite,copy) NSString *firstName;@property (nonatomic,readwrite,copy) NSString *firstName;@end</code></pre><hr><h3 id="通过协议提供匿名对象"><a href="#通过协议提供匿名对象" class="headerlink" title="通过协议提供匿名对象"></a>通过协议提供匿名对象</h3><p>协议定义了一些方法，遵循协议的对象应该实现它们。有时候，我们需要的仅仅是能够响应协议方法的对象就行了，至于它具体是什么类型可以不用关心。这样id范型，就将实际类型隐藏起来，避免了不必要的类型暴露和污染。这个概念称为<strong>匿名对象</strong>(anonymous object)，比如：</p><pre><code>@property (nonatomic,readwrite,assign) id&lt;EOCDelegaet&gt; delegate;</code></pre><p>任何对象都可以当delegate，只要它遵循了<EOCDelegaet>协议就行。NSDictionary也说明了这一概念。在字典中，Key的标准内存管理语义是<strong>设置时拷贝</strong>，而Value的标准内存管理语义是<strong>设置时保留</strong>。因此在可变字典中，设置健值对的方法签名是：</p><pre><code>- (void)setObject:(id)object forKey:(id&lt;NSCopying&gt;)key;</code></pre><p>有时候对象的类型并不重要，重要的是对象有没有实现某些方法，在此情况下，可以将协议也看作是一个<strong>匿名类型</strong>，它就代表了一些特定的类型。从而在类的设计中类型解耦。</p><hr><h3 id="在dealloc中只释放引用并解除监听"><a href="#在dealloc中只释放引用并解除监听" class="headerlink" title="在dealloc中只释放引用并解除监听"></a>在dealloc中只释放引用并解除监听</h3><p>对象在经历其生命期后，最终回被系统回收，这时就要执行且只执行一次dealloc方法。一旦调用过dealoc之后，对象就不再有效。在dealloc中，通常就是释放对象所拥有的其它引用，ARC会通过自动生成的**.cxx_destruct**方法在dealloc中添加释放引用代码。除此之外，通常还需要将原来配置过的观测行为(observation behavior)都清理掉，例如NSNotificationCenter。</p><p>对于开销较大或系统内稀缺的资源，比如文件描述符(file descriptor)、套接字(socket)、大块内存等等，不应该指望等到执行dealloc时才释放，因为有一些无法预料的情况致使本对象比想象中释放得要晚很多。如果非要等到系统调用dealloc时才释放，那么保留这些稀缺资源的时间就会过长，这样并不合适。通常需要另一个方法，在对象使用完资源后就调用它立即释放，比如：</p><pre><code>- (void)open:(NSString *)address;- (void)close;</code></pre><p>为了防止忘记清理必要的资源，可以在dealloc进行最后检查：</p><pre><code>- (void)close &#123;    // clean up resources    _closed = YES;&#125;- (void)dealloc &#123;    if (!_closed) &#123;        NSLog(@&quot;Error: close was not called before dealloc&quot;);        [self close];    &#125;&#125;</code></pre><p>需要资源时调用open，使用完毕后调用close。系统并不保证每个创建出来的对象都会执行dealloc。极个别情况下，当程序终止时，仍有对象处于存活状态。在OS X和iOS对应的程序代理方法中，都有一个会在程序终止时调用的方法。如果一定需要清理的对象，可以在这里进行清理：</p><pre><code>- (void)applicationWillTerminate:(NSNotification *)notification;- (void)applicationWillTerminate:(UIApplication *)application;</code></pre><p>编写dealloc时还需要注意，不要再里面随便调用其他方法，因为对象此时<strong>已近尾声</strong>(in a winding-down state)。如果调用的方法里又调用了异步任务，那么等到那些任务执行完毕时，对象可能已经彻底销毁了。万一callback则会访问野指针，导致很多问题。另一个需要注意的问题是，调用dealloc可以在任何线程，只要那个线程令对象的计数器为0。如果dealloc中调用了某些必须在特定线程(比如主线程)中才能正确执行的方法，由于无法保证线程的正确从而也会导致很多问题。设置属性也不应该调用，因为可能设置方法里可能有一些无法在回收阶段安全执行的操作，另外也可能引起外界KVO执行。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective Objective-C 读书笔记-上</title>
    <link href="/2016/01/10/2016-01-10-Effective-Objective-C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%8A/"/>
    <url>/2016/01/10/2016-01-10-Effective-Objective-C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h3 id="了解Objc语言的起源"><a href="#了解Objc语言的起源" class="headerlink" title="了解Objc语言的起源"></a>了解Objc语言的起源</h3><p>Objc使用<strong>消息结构</strong>(messaging structure)而非<strong>函数调用</strong>(fucntion calling)，由Smalltalk(消息型语言的鼻祖)演化而来。消息和函数调用之间的区别看上去像这样：</p><pre><code>// Messaging (Objc)Object *obj = [Object new];[obj performWith:para1 and:para2];// Fucntion calling(C++)Object *obj = new Object;obj-&gt;perform(para1, para2);</code></pre><p>程序运行时执行的代码，函数调用型语言是由<strong>编译时编译器</strong>决定，消息结构型语言是由<strong>运行时运行环境</strong>决定。如果上述函数是多态，函数调用型语言要按照<strong>虚方法表</strong>(virtual table)查找最终具体执行的函数，消息结构型语言无论是否多态都会在运行时进行查找。实际上，消息结构型语言的编译器甚至不关心接受消息的对象是什么类型。</p><hr><h3 id="在类的头文件中尽量少引入其他头文件"><a href="#在类的头文件中尽量少引入其他头文件" class="headerlink" title="在类的头文件中尽量少引入其他头文件"></a>在类的头文件中尽量少引入其他头文件</h3><p><strong>@class</strong>向前声明(forward declaring)能告诉编译器有什么类型存在，而不告诉其类型的细节。当没有必要把依赖的类型细节暴露出来的时候，在头文件使用@class在实现文件使用#import，能延后引入文件的时机，减少类的<strong>使用者</strong>需要引入的头文件总数，减少编译时间。</p><p>同时，向前声明还解决了多个类型互相引用引起的<strong>循环引用</strong>(chicken-and-egg situation)问题：当解析头文件A是，编译器发现它引入了头文件B，而头文件B又回过头来引入了头文件A。使用#import而非#include虽然不会导致死循环，但无法正确编译。</p><p>有些时候头文件必需知道依赖的类型的细节，比如父类类型和协议类型。对于自定义协议类型，最好单独写在一个头文件中，防止引入不必要的额外类型。对于系统协议类型，可以在实现文件里引入并声明。</p><p>每次引入头文件时，先问问自己这样做是否有必要。处理得当的话，不仅可以缩减编译时间，还能降低依赖程度。</p><hr><h3 id="多用字面量语法"><a href="#多用字面量语法" class="headerlink" title="多用字面量语法"></a>多用字面量语法</h3><p>对于NSString,NSNumber,NSArray,NSDictionary这些类型，常见的alloc及init方法来分配并初始化对象又冗长又麻烦。而使用<strong>字面量语法</strong>(literal syntax)可以缩减代码长度，使其更为易读。</p><pre><code>// NSStringNSString *someString = @&quot;Effective Objective-C 2.0&quot;;// NSNumberNSNumber *initNumber = @1;NSNumber *floatNumber = @2.5f;NSNumber *doubleNumber = @3.1415926;NSNumber *boolNumber = @YES;NSNumber *charNumber = @&#39;a&#39;;int x = 5;float y = 6.32f;NSNumber *expressionNumber = @(x * y);// NSArrayNSArray *animals = @[@&quot;cat&quot;, @&quot;dog&quot;, @&quot;mouse&quot;, @&quot;badger&quot;];NSString *dog = animals[1];这也叫**取下标操作**(subcripting)，更为简洁更为易懂。// NSDictionaryNSDictionary *personData = @&#123;    @&quot;firstName&quot;:@&quot;Matt&quot;,    @&quot;lastName&quot;:@&quot;Galloway&quot;,    @&quot;age&quot;:@28&#125;;NSString *lastName = personData[@&quot;lastName&quot;];// NSMutableArray &amp;&amp; NSMutableDictionaryNSMutableArray *mutableArray = [@[@&quot;cat&quot;, @&quot;dog&quot;, @&quot;mouse&quot;, @&quot;badger&quot;] mutableCopy];mutableArray[1] = @&quot;dog&quot;;NSMutableDictionary *mutableDictionary = [@&#123;    @&quot;firstName&quot;:@&quot;Matt&quot;,    @&quot;lastName&quot;:@&quot;Galloway&quot;,    @&quot;age&quot;:@28&#125; mutableCopy];mutableDictionary[@&quot;lastName&quot;] = @&quot;Hello&quot;;</code></pre><p>注意，用字面量语法创建数组和字典时，如果出现nil会抛出异常。数组取下标操作时，如果越界也会抛出异常。</p><hr><h3 id="多用类型常量，少用-define预处理命令"><a href="#多用类型常量，少用-define预处理命令" class="headerlink" title="多用类型常量，少用#define预处理命令"></a>多用类型常量，少用#define预处理命令</h3><p>使用类型常量代替以前使用的#define宏，因为它有类型信息。宏在替换时由于没有类型信息，有很多潜在的意想不到的错误发生。</p><pre><code>#define ANIMATION_DURATION 0.3// EOCAnimatedView.hextern NSString *const EOCStringConstant;// EOCAnimatedView.mNSString *const EOCStringConstant = @&quot;VALUE&quot;;static const NSTimeInterval kAnimationDuration = 0.3;</code></pre><p>const修饰的变量表示该变量在程序运行期间是可读不可写的，如果代码中试图修改const修饰符声明的变量就会编译出错，因为我们不希望有人更改它的值。</p><p>static修饰的变量表示该变量尽在被定义的编译单元(即实现文件)内可见。编译器将每个编译单元编译成一个<strong>目标文件</strong>(object file)，然后连接器链接各个目标文件依赖的符号。没有static的话，编译器会为它创建一个<strong>外部符号</strong>(external symbol)，产生隐藏的符号冲突：</p><pre><code>duplicate symbol _kAnimationDuration in:    EOCAnimatedView.o    EOCOtherView.o</code></pre><p>所以同时使用static与const来声明，能实现我们的目标。实际上，对于此类情况，编译器根本不会为它创建符号，而是会像#define一样替换所有的变量。</p><p>extern修饰的变量表示该变量需放在<strong>全局符号表</strong>(global symbol table)中，以便在定义该变量的编译单元之外使用。也就是说编译器无需查看其定义，就允许代码使用它，因为编译器知道链接成二进制文件后肯定能找到这个变量。此类常量必需定义且只能定义一次，通常在相关的实现文件里。因为在全局符号表里，所以命名时需要谨慎。由于Objc没有<strong>名称空间</strong>(namesapce)，需要考虑添加<strong>前缀</strong>使其唯一。</p><hr><h3 id="用枚举表示状态、选项和状态码"><a href="#用枚举表示状态、选项和状态码" class="headerlink" title="用枚举表示状态、选项和状态码"></a>用枚举表示状态、选项和状态码</h3><p>应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，并起个易懂的名字。</p><p>Foudation中定义了一些辅助宏，用这些宏来定义枚举类型时，可以指定用于保存枚举值的<strong>底层数据类型</strong>确保实现。这些宏能够<strong>向后兼容</strong>(backward compatibility)，如果目标平台编译器支持新标准，就使用新式语法，否则使用旧式语法：</p><pre><code>typedef NS_ENUM(NSUInteger, EOCConnectionState) &#123;    EOCConnectionStateDisconnected,    EOCConnectionStateConnecting,    EOCConnectionStateConnected        &#125;;typedef NS_OPTIONS(NSUInteger, EOCPermittedDirection) &#123;    EOCPermittedDirectionUp     = 1 &lt;&lt; 0,    EOCPermittedDirectionDown     = 1 &lt;&lt; 1,    EOCPermittedDirectionLeft     = 1 &lt;&lt; 2,    EOCPermittedDirectionRight = 1 &lt;&lt; 3,&#125;;</code></pre><p>NS_OPTIONS语法和NS_ENUM完全相同，但这个宏提示编译器值是如何通过位掩码|组合在一起的。</p><hr><h3 id="理解属性这一概念"><a href="#理解属性这一概念" class="headerlink" title="理解属性这一概念"></a>理解属性这一概念</h3><pre><code>@interface EOCPerson : NSObject &#123;@public    NSString *_firstName;    NSString *_lastName;@private    NSString *_someData;&#125;</code></pre><p>对象布局在编译器(compile time)就已经固定了。比如所有用到_firstName变量的代码，编译器就把它替换成<strong>硬编码的偏移量</strong>(hardcode offset),表示该变量距离对象内存区域起始位置有多远。但是如果类的设计在未来有变化的话：</p><pre><code>@interface EOCPerson : NSObject &#123;@public    NSDate *_birthday;    NSString *_firstName;    NSString *_lastName;@private    NSString *_someData;&#125;</code></pre><p>原来只想_firstName的偏移量现在都错误地指向了_birthday。所以，如果使用编译器计算的偏移量，那么在修改类定义后必需重新编译。Objc的做法是，把变量当作一种存储偏移量所用的<strong>特殊变量</strong>(special variable)，交给<strong>类对象</strong>(class object)统一管理。偏移量在运行期动态查找，如果类的定义变了，那么存储的偏移量也就变了，甚至在运行期间也可以向类中添加变量，无论何时访问变量都是正确的偏移量。这就是稳固的<strong>应用程序二进制接口</strong>(Application Binary Interface,ABI)<br>。ABI定义了很多内容，其中一项就是<strong>生成代码时所应遵循的规范</strong>。有了它，我们就可以在类的<strong>分类</strong>中定义额外的变量了，不用将所有的变量公开声明在外部类定义中，以便保护私有信息。</p><p>尽量<strong>不直接访问</strong>实例变量，使用存取方法来间接访问实例变量，这不仅为数据提供了简洁的封装，而且有利于控制实力变量的影响范围。</p><hr><h3 id="在对象内部如何访问变量"><a href="#在对象内部如何访问变量" class="headerlink" title="在对象内部如何访问变量"></a>在对象内部如何访问变量</h3><p>在对象外部访问变量时，总应该通过属性完成，但是在对象内部呢？这是个一直激烈争论的问题。<strong>该书作者</strong>的建议是，内部读取时采用直接访问，内部设置时采用属性访问。</p><ul><li>由于不经过Objc的方法派发，直接访问变量的速度要比读取方法快</li><li>通过属性设置变量会线程安全(atomic)，会管理内存(retain和copy)</li><li>通过属性设置变量会保证外部KVO正常响应(是否这么做取决于具体目的)</li><li>通过属性设置变量会统一观察变量变化路径(setter中添加断点)</li></ul><p>值得注意的是，在init中应该尽量直接访问实例变量。因为初始化时，对象的内存数据还没有完全确定，而如果通过属性访问调用设置方法(子类可能也override了设置方法)，会有潜在影响对象数据的可能性。在dealloc中也尽量如此，因为如果这时还通过属性访问调用设置方法，有些依赖另外一些已经释放了变量的具体实现会有潜在出错的可能性，另外KVO也可能潜在引出别的问题。总而言之，init时对象尚未完整确定，dealloc对象理应无效，这两个状态都不应该有别的行为。</p><p>但是在某些情况下又必需通过属性访问，比如想要初始化的实例变量声明在父类中不能在子类中直接访问。另外，<strong>惰性初始化</strong>(lazy initialization)必须通过属性访问，否则其影响的实例变量永远不会初始化。</p><hr><h3 id="理解“对象等同性”"><a href="#理解“对象等同性”" class="headerlink" title="理解“对象等同性”"></a>理解“对象等同性”</h3><p>如果想监测对象的等同性，需要实现isEqual:和hash这两个方法。equal的对象必须有相同的hash，但是有相同hash的对象不一定equal。不过在实现hash时，需要注意运行速度和hash碰撞(collision)率。例如，使用hash实现索引的collection，可能会根据hash把对象分装到不同的数组。当向collection添加新对象时，会根据对象hash找到相关的数组，再依次检查每个元素是否与新对象相等，最后决定是否添加到collection中。</p><p>如果hash碰撞率过高，那么看起来就是，collection内部分组集中且每个分组元素很多，每次扫描需要判定的数目很多：</p><pre><code>- (NSUInteger)hash &#123;    return 2016;&#125;</code></pre><p>如果hash碰撞率不高，那么看起来就是，collection内部分组分散切每个分组元素很少，每次扫描需要判定的数目很少：</p><pre><code>- (NSUInteger)hash &#123;    NSString *strToHash = [NSString stringWithFormat:@&quot;%@:%@:%i&quot;, _firstName, _lastName_, _age];    return [strToHash hash];&#125;</code></pre><p>这是上面的实现速度不够快，可能产生性能问题，可以这样：</p><pre><code>- (NSUInteger)hash &#123;    NSUInteger firstNameHash = [_firstName hash];    NSUInteger lastNameHash = [_lastName_ hash];    NSUInteger ageHash = _age;    return firstNameHash^lastNameHash^ageHash;&#125;</code></pre><p>这样技能保持较高效率，又能使生成的hash在一定范围内，不会过于频繁地重复。创建等同性判断时，是将判断整个对象还是对象的一部分可以根据需要来决定。比如NSArray先检查个数是否相同，再检查每个对应位置的对象是否相等，如果都相等则这两个数组就相等，这叫做<strong>深度等同性判断</strong>(deep equality)。又比如根据数据库里的数据创建的对象，可以只根据对象的数据库ID进行等同性判断。</p><p>添加可变对象到collection时需要注意，collection根据其hash放置，如果期间可变对象的hash变化了，那么collection可能就会错误地判定等同性。所以，应该确保可变对象hash的不变性，要么根据可变对象的不变部分计算hash，要么保证加入collecton后不再改变，这从另一个方面解释了将对象设计成不变的优点之一。</p><hr><h3 id="理解objc-msgSend的的作用"><a href="#理解objc-msgSend的的作用" class="headerlink" title="理解objc_msgSend的的作用"></a>理解objc_msgSend的的作用</h3><p>在objc中给对象发送消息：</p><pre><code>id returnValue = [someObject mseeageName:parameter];</code></pre><p>someObject叫做<strong>接收者</strong>(receiver)，messageName叫做<strong>选择子</strong>(selector)，选择子和所有参数组合起来称为<strong>消息</strong>(message)。编译器将其转换成一条标准的C函数调用，消息传递机制中的核心函数，叫做objc_msgSend：</p><pre><code>id objc_msgSend(id self, SEL_ cmd, ...)id returnValue = objc_msgSend(semeObject, @selector(messageName:), parameter);</code></pre><p>objc_msgSend等函数一旦找到应该调用的方法实现之后，就会“跳转过去”。因为objc对象的每个方法都可以视为简单的C函数：</p><pre><code> &lt;return_type&gt; Class_selector(id self, SEL _cmd, ...) </code></pre><p>其原型和objc_msgSend函数很像，这不是巧合，而是利用了<strong>尾调用优化</strong>(tail call optimization)。</p><p>如果某函数的最后一项操作仅仅是调用另一个函数，且不会将其返回值另作他用时，就可以运用尾调用优化技术。编译器会生成调转至另一函数所需的指令，而不会向调用栈中推入新的<strong>栈帧</strong>(frame stack)。这项优化对objc_msgSend非常关键，如果不这么做的话，那么每次调用objc的方法之前，都需要为objc_msgSend准备栈帧，<strong>栈踪迹</strong>(stack trace)中就会有很多没有必要的objc_msgSend栈帧出现。此外，还可以大量减少调用栈的内存消耗，尽量避免<strong>栈溢出</strong>(stack overflow)的问题发生。</p><hr><h3 id="尽量使用不可变对象"><a href="#尽量使用不可变对象" class="headerlink" title="尽量使用不可变对象"></a>尽量使用不可变对象</h3><p>设计类是，应尽量把对外公布出来的属性设为<strong>只读</strong>(readonly)，而且只有在确有必要的时候才讲属性对外公布。对于向修改又不像为外人所改动的内部数据，可以将对应的属性在实现文件里重新声明为<strong>可写</strong>(readwrite)。</p><pre><code>// EOCExample.h@interface EOCExample : NSObject@property (nonatomic,readonly,copy) NSString *title;@end// EOCExample.m@interface EOCExample ()@property (nonatomic,readwrite,copy) NSString *title;@end@implementation EOCExample@end</code></pre><p>当然，如果该属性是nonatomic则可能产生<strong>竞态条件</strong>(race condition)。在对象内部写入是，在对象外部也许正在读取，那么就需要一些方法<strong>同步</strong>属性的读取操作。</p><p>设计类时还需要注意，如果对象内部有可变collection，不应该将其直接暴露在外面，而是将其封装在类的内部。这样所有的操作在内部可控，也可以保证线程安全。如果外部需要collection的信息和操作，则可以公开返回其不变版本，将各种操作用API封装暴露出去。</p><pre><code>// EOCPerson.h@interface EOCPerson : NSObject@property (nonatomic,readonly,copy) NSString *firstName;@property (nonatomic,readonly,copy) NSString *lastName;@property (nonatomic,readonly,retain) NSArray *friends;- (void)addFriend:(EOCPerson *)person;- (void)removeFriend:(EOCPerson *)person;@end// EOCPerson.m@interface EOCPerson ()@property (nonatomic,readwrite,copy) NSString *firstName;@property (nonatomic,readwrite,copy) NSString *lastName;@property (nonatomic,readwrite,retain) NSMutableArray *mtFriends;@end@implementation EOCPerson- (NSArray *)friends &#123;    return [NSArray arrayWithArray:self.mtFriends];&#125;- (void)addFriend:(EOCPerson *)person &#123;    [self.mtFriends addObject:person];&#125;- (void)removeFriend:(EOCPerson *)person &#123;    [self.mtFriends removeObject:person];&#125;@end</code></pre><hr><h3 id="为私有方法添加前缀"><a href="#为私有方法添加前缀" class="headerlink" title="为私有方法添加前缀"></a>为私有方法添加前缀</h3><p>一个类所做的事通常都要比外面看起来的更多。实现类时，经常要写一些内部使用的私有方法。Objc和C++、Java不一样，其方法没有真正意义上的私有方法，每个方法都可以在运行时查询并运行，所以将私有方法隐藏在实现文件里是良好的习惯。为他们添加前缀，因为很容易把公开方法和私有方法区别开来有助于调试。同时，因为类的公开API已经暴露出去供外界使用，所以不能随意改动方法名，否则所有使用了API的代码都要变动。私有方法有了前缀，就很容易看出哪些方法可以随意修改，哪些不应该轻易修改。本书作者推荐**p_**：</p><pre><code>#import&lt;Foundation/Foundation.h&gt;@interface EOCExample : NSObject- (void)publicMethod;@end@implementation EOCExample- (void)publicMethod &#123;    ...&#125;- (void)p_privateMethod &#123;    ...&#125;</code></pre><p>Apple喜欢用**_**作为私有方法的前缀。不应该照着Apple的方法实现自己的私有方法的前缀，因为极有可能覆写(override)了Apple的私有实现从而引起莫名其妙的问题。</p><h3 id="理解Objc的错误模型"><a href="#理解Objc的错误模型" class="headerlink" title="理解Objc的错误模型"></a>理解Objc的错误模型</h3><p>默认情况下，<strong>ARC不是异常安全的</strong>(exception safe)。这意味着，如果抛出异常，那么本应该在作用域末尾释放的的对象将不能释放了。如果想生成异常安全的代码，通过设置编译器标示来**-fobjc-arc-exception**实现。</p><p>Objc的理解是，只有在极其罕见和严重的情况下抛出异常，异常抛出之后无须考虑恢复，而且程序此时也应该退出。对于<strong>非致命错误</strong>(nonfatal error)，建议方法返回nil/0，或者使用NSError已表明其中有错误发生了。NSError的用法更加灵活，因为痛过它我们可以把出错原因回报给调用着：</p><ul><li><strong>错误范围</strong>(Error domain)描述产生错误的根源</li><li><strong>错误码</strong>(Error code)指明具体发生了何种错误</li><li><strong>用户信息</strong>(User info)有关此错误的额外信息</li></ul><p>设计API时可以已委托协议或者输出参数的形式来传递错误信息：</p><pre><code>- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error;- (BOOL)doSomething:(NSError *)error;</code></pre><hr><h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><p><a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html">尾调用优化</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chisel</title>
    <link href="/2016/01/03/2016-01-03-Chisel/"/>
    <url>/2016/01/03/2016-01-03-Chisel/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/gkassabli/chisel">chisel</a>是facebook开发的用于提高LLDB使用效率的工具。这篇文章对chisel的命令写得很详细，我不再做重复的工作，转发作为参考手册在使用时方便阅读。</p><hr><h2 id="Autolayout"><a href="#Autolayout" class="headerlink" title="Autolayout"></a>Autolayout</h2><p>autolayout中有一种bug叫<a href="https://developer.apple.com/library/tvos/documentation/UserExperience/Conceptual/AutolayoutPG/AmbiguousLayouts.html#//apple_ref/doc/uid/TP40010853-CH18-SW1">Ambiguous Layouts</a>，意思是你设置的约束不足以确定view的位置或大小。比如你只设置了X轴的位置，没有设置Y轴的位置。</p><blockquote><p><strong>hasAmbiguousLayout</strong> - Available for both iOS and OS X. Call this method on a misplaced view. It returns YES if the view’s frame is ambiguous. Otherwise, it returns NO. <strong>_autolayoutTrace</strong> - Available as a private method in iOS. Call this method on a view. It returns a string with diagnostic information about the entire view hierarchy containing that view. Ambiguous views are labeled, and so are views that have translatesAutoresizingMaskIntoConstraints set to YES.</p></blockquote><p>由此可知，hasAmbiguousLayout用于判断是否存在Ambiguous Layouts，_autolayoutTrace用于查找存在的Ambiguous Layouts。但是即使有查找的方法，真正去做这个事儿也比较费时费力的，这时候chisel给我们提供了更为方便的命令。</p><h4 id="alamborder"><a href="#alamborder" class="headerlink" title="alamborder"></a>alamborder</h4><p>给存在Ambiguous Layouts的view加上border，方便查找哪些View存在问题。</p><pre><code>语法:Syntax: alamborder [--color=color] [--width=width]说明:--color/-c: border的颜色，参数为string类型，比如&#39;red&#39;，&#39;green&#39;，&#39;magenta&#39;等，不设置默认为红色--width/-w: border的宽度，参数为CGFloat类型，不设置默认宽度为2</code></pre><p>假设我们写了这么一段代码，可以明显看出，我们没有设置X轴的位置</p><pre><code>UIView *subview = [UIView new];[self.view addSubview:subview];[subview mas_makeConstraints:^(MASConstraintMaker *make) &#123;    make.top.offset(100);    make.size.equalTo(@100);&#125;];</code></pre><p>运行代码之后，在LLDB控制台输入alamborder</p><pre><code>(lldb) alamborder</code></pre><p>所有带有Ambiguous Layouts的view立即会被渲染上红色border</p><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ezmcz1p8eaj206y0dk0sm.jpg"></p><p>可以看到，subview的边框已经变为红色，另外只要有一个View存在Ambiguous Layouts，UIWindow的边框也会变为红色，这就有效的避免了宽度或者高度为0的Ambiguous Layouts不宜察觉的缺陷。</p><h4 id="alamunborder"><a href="#alamunborder" class="headerlink" title="alamunborder"></a>alamunborder</h4><p>将alamborder设置的border去掉。</p><pre><code>语法:Syntax: alamunborder    </code></pre><p>刚刚设置的border，在lldb控制台输入alamunborder即可去掉边框</p><pre><code>(lldb) alamborder</code></pre><h4 id="paltrace"><a href="#paltrace" class="headerlink" title="paltrace"></a>paltrace</h4><p>打印某个View的autolayout详细信息，相当于调用_autolayoutTrace。</p><pre><code>语法:Syntax: paltrace &lt;view&gt;说明:view: 需要打印详细信息的view，不传参数默认为keyWindow</code></pre><p>查看一下keyWindow上有哪个view存在Ambiguous Layouts</p><pre><code>(lldb) paltrace •UIWindow:0x7ff450d2fb50 - AMBIGUOUS LAYOUT|   •UIView:0x7ff450e14430|   |   *_UILayoutGuide:0x7ff450d30e90|   |   *_UILayoutGuide:0x7ff450d31230|   |   *UIView:0x7ff450d32870- AMBIGUOUS LAYOUT for UIView:0x7ff450d32870.minX&#123;id: 46&#125;Legend:    * - is laid out with auto layout    + - is laid out manually, but is represented in the layout engine because translatesAutoresizingMaskIntoConstraints = YES    • - layout engine host</code></pre><p>我们可以看到，UIView:0x7ff450d32870存在Ambiguous Layouts，原因是缺少minX。也就是没有设置X轴的位置</p><hr><h2 id="Print"><a href="#Print" class="headerlink" title="Print"></a>Print</h2><p>在LLDB中，我们执行的最多的可能就是打印操作了，chisel专门为这类操作封装了一些打印命令</p><h4 id="pviews"><a href="#pviews" class="headerlink" title="pviews"></a>pviews</h4><p>循环打印view层级，正常情况下等效于调用recursiveDescription命令，即 po [self.view recursiveDescription] 和 pviews self.view 是一样的。</p><pre><code>语法:pviews [--up] [--depth=depth] &lt;aView&gt;说明:--up/-u: 以view为起始位置，向上打印，直到打印到window层--depth/-d: 传入int类型，表示打印的层数，0表示没有限制</code></pre><p>打印一下self.view层级</p><pre><code>(lldb) pviews self.view&lt;UIView: 0x7fee7ae1fa60; frame = (0 0; 375 667); autoresize = W+H; layer = &lt;CALayer: 0x7fee7ae1d3c0&gt;&gt;   | &lt;UIButton: 0x7fee7ae1dd90; frame = (54 244; 46 30); opaque = NO; autoresize = RM+BM; layer = &lt;CALayer: 0x7fee7ae1e300&gt;&gt;   | &lt;UIView: 0x7fee7ae1f2e0; frame = (35 312; 240 128); autoresize = RM+BM; layer = &lt;CALayer: 0x7fee7ae1f660&gt;&gt;   | &lt;_UILayoutGuide: 0x7fee7ae1fc20; frame = (0 0; 0 0); hidden = YES; layer = &lt;CALayer: 0x7fee7ae20030&gt;&gt;   | &lt;_UILayoutGuide: 0x7fee7ae20b30; frame = (0 0; 0 0); hidden = YES; layer = &lt;CALayer: 0x7fee7ae1d100&gt;&gt;   | &lt;UILabel: 0x7fee7ae1d3f0; frame = (0.4 150; 58.25 20.5); text = &#39;aaa&#39;; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x7fee7ae1bb30&gt;&gt;      </code></pre><h4 id="pvc"><a href="#pvc" class="headerlink" title="pvc"></a>pvc</h4><p>循环打印viewController的层级。</p><pre><code>语法:Syntax: pvc &lt;aViewController&gt;说明:aViewController: 表示要打印的viewController，不传参数默认viewController为当前的VC。</code></pre><p>打印一下当前VC</p><pre><code>(lldb) pvc&lt;UINavigationController 0x7fce1a03d800&gt;, state: appeared, view: &lt;UILayoutContainerView 0x7fce19500c00&gt;   | &lt;ViewController 0x7fce1c03a1d0&gt;, state: disappeared, view: &lt;UIView 0x7fce19517b40&gt; not in the window   | &lt;TableViewController 0x7fce1951f7b0&gt;, state: appeared, view: &lt;UIView 0x7fce1c053e60&gt;   </code></pre><h4 id="pclass"><a href="#pclass" class="headerlink" title="pclass"></a>pclass</h4><p>循环打印class的继承关系。</p><pre><code>语法:Syntax: pclass &lt;object&gt;说明:object: 要打印继承关系的对象</code></pre><p>打印一个View对象的继承关系</p><pre><code>(lldb) pclass [UIView new]UIView   | UIResponder   |    | NSObject   </code></pre><h4 id="presponder"><a href="#presponder" class="headerlink" title="presponder"></a>presponder</h4><p>打印响应链。</p><pre><code>语法:Syntax: presponder &lt;startResponder&gt;说明:startResponder: UIResponder对象，响应链开始位置</code></pre><p>打印一个tableView的响应链</p><pre><code>(lldb) presponder tableView&lt;UITableView: 0x7fde54810e00; frame = (0 0; 0 0); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x7fde52519ac0&gt;; layer = &lt;CALayer: 0x7fde5253b4c0&gt;; contentOffset: &#123;0, 0&#125;; contentSize: &#123;0, 220&#125;&gt;   | &lt;UIView: 0x7fde5255c710; frame = (0 0; 600 600); autoresize = W+H; layer = &lt;CALayer: 0x7fde5253b300&gt;&gt;   |    | &lt;TableViewController: 0x7fde52491310&gt;   </code></pre><h4 id="ptv"><a href="#ptv" class="headerlink" title="ptv"></a>ptv</h4><p>打印屏幕中显示的tableView，主要是与pcells联合使用。如果有多个tableView，打印View层级中最上面的一个。</p><pre><code>语法:Syntax: ptv    </code></pre><p>看看当前最上面是哪个tableView</p><pre><code>(lldb) ptv&lt;UITableView: 0x7fde52811800; frame = (0 0; 414 736); clipsToBounds = YES; autoresize = RM+BM; gestureRecognizers = &lt;NSArray: 0x7fde526418d0&gt;; layer = &lt;CALayer: 0x7fde5260adc0&gt;; contentOffset: &#123;0, -64&#125;; contentSize: &#123;414, 176&#125;&gt;</code></pre><h4 id="pcells"><a href="#pcells" class="headerlink" title="pcells"></a>pcells</h4><p>打印tableView中当前可见的cell，如果有多个tableView，打印View层级中最上面的tableView的可见cell。</p><pre><code>语法:Syntax: pcells</code></pre><p>看看当前可见的cell有哪些</p><pre><code>(lldb) pcells&lt;__NSArrayI 0x7fde52565a00&gt;(&lt;UITableViewCell: 0x7fde52551180; frame = (0 0; 414 44); text = &#39;BasicViewController&#39;; autoresize = W; layer = &lt;CALayer: 0x7fde52537140&gt;&gt;,&lt;UITableViewCell: 0x7fde5255bea0; frame = (0 44; 414 44); text = &#39;DateViewController&#39;; autoresize = W; layer = &lt;CALayer: 0x7fde5255b1a0&gt;&gt;,&lt;UITableViewCell: 0x7fde5255e2d0; frame = (0 88; 414 44); text = &#39;PPTViewController&#39;; autoresize = W; layer = &lt;CALayer: 0x7fde5255e270&gt;&gt;,&lt;UITableViewCell: 0x7fde5255fce0; frame = (0 132; 414 44); text = &#39;TableViewController&#39;; autoresize = W; layer = &lt;CALayer: 0x7fde5255fa90&gt;&gt;)</code></pre><h4 id="pinternals"><a href="#pinternals" class="headerlink" title="pinternals"></a>pinternals</h4><p>打印一个对象内部的成员变量，这个方法我一般用来看model属性。</p><pre><code>语法:Syntax: pinternals &lt;object&gt;说明:object: 需要打印内部成员变量的对象</code></pre><p>我们来看看一个model内部属性的值</p><pre><code>(lldb) pinternals model(Model) $5 = &#123;  _name = 0x000000010dd1c0a0 @&quot;老鼠爱大米&quot;  _URL = nil  _array = nil  _dictionary = nil  _string = nil  _model = nil&#125;</code></pre><h4 id="pdata"><a href="#pdata" class="headerlink" title="pdata"></a>pdata</h4><p>对编码过的NSData进行解码打印，等效于调用-[NSString initWithData:encoding:]。</p><pre><code>语法:Syntax: pdata [--encoding=encoding] &lt;data&gt;说明:--encoding/-e: 编码类型(ascii utf8 utf16 utf16l utf16b utf32 utf32l utf32b latin1 latin2 cp1251 cp1252 cp1253 cp1254 cp1250)，缺省默认为utf8data: 需要打印的data，NSData类型</code></pre><p>将一个utf8的NSData打印</p><pre><code>(lldb) pdata -e=utf8 data老鼠爱大米</code></pre><h4 id="pkp"><a href="#pkp" class="headerlink" title="pkp"></a>pkp</h4><p>通过-valueForKeyPath:打印key path对应的值。</p><pre><code>语法:Syntax: pkp &lt;keypath&gt;说明:keypath: 需要打印的路径，如self.view</code></pre><p>以前打印属性一般都用po obj.xxx，现在我想用pkp obj.xxx是一个更好的选择了，因为po obj.xxx是调用getter方法，如果没有getter方法就无法打印了。pkp obj.xxx不仅会调用getter方法，没有getter方法还会去查找成员变量。</p><p>打印一下self.view</p><pre><code>(lldb) pkp self.view&lt;UIView: 0x7fd1da52d5d0; frame = (0 0; 375 667); autoresize = W+H; layer = &lt;CALayer: 0x7fd1da52d740&gt;&gt;</code></pre><h4 id="pivar"><a href="#pivar" class="headerlink" title="pivar"></a>pivar</h4><p>打印对象成员变量。</p><pre><code>语法:Syntax: pivar &lt;object&gt; &lt;ivarName&gt;说明:object: id类型，要打印成员变量的对象ivarName: 成员变量的名称，注意:如果是属性，对应成员变量的名字默认有_前缀</code></pre><p>继续打印self.view</p><pre><code>(lldb) pivar self _view&lt;UIView: 0x7fd1da52d5d0; frame = (0 0; 375 667); autoresize = W+H; layer = &lt;CALayer: 0x7fd1da52d740&gt;&gt;</code></pre><h4 id="pca"><a href="#pca" class="headerlink" title="pca"></a>pca</h4><p>从渲染服务器的角度来打印layer tree，命令的完整名字是PrintCoreAnimationTree，相当于调用po [NSString stringWithCString:(char *)CARenderServerGetInfo(0, 2, 0)]。</p><pre><code>语法:Syntax: pca</code></pre><h4 id="panim"><a href="#panim" class="headerlink" title="panim"></a>panim</h4><p>显示是否正在执行动画，相当于调用p (BOOL)[UIView _isInAnimationBlock]。</p><pre><code>语法:Syntax: panim</code></pre><p>在动画中，我们打印一下:</p><pre><code>(lldb) panim(BOOL) $0 = YES</code></pre><hr><h2 id="Find"><a href="#Find" class="headerlink" title="Find"></a>Find</h2><p>debug的时候，我们经常需要查找一些东西，比如View，viewController等。</p><h4 id="fvc"><a href="#fvc" class="headerlink" title="fvc"></a>fvc</h4><p>根据viewController的Class名字查找VC。</p><pre><code>语法:Syntax: fvc [--name=classNameRegex] [--view=view]说明:--name/-n: string类型参数，根据viewController的Class名字查找viewController--view/-v: UIView类型参数，根据viewController拥有的view查找viewController</code></pre><p>注意，上面2个option不能同时使用，只能使用某一个。</p><p>我们先根据名字查找一下VC</p><pre><code>(lldb) fvc --name=viewcontroller0x7fd01a90f310 ViewController</code></pre><p>如果我们知道VC的view地址，也可以根据view来查找VC</p><pre><code>(lldb) fvc --view=0x7fd0194194d0Found the owning view controller.&lt;ViewController: 0x7fd01a90f310&gt;</code></pre><h4 id="fv"><a href="#fv" class="headerlink" title="fv"></a>fv</h4><p>根据view的class名字查找view。</p><pre><code>语法:Syntax: fv &lt;classNameRegex&gt;说明:classNameRegex: view的class名称</code></pre><p>查找一下屏幕上的UILabel</p><pre><code>(lldb) fv uilabel0x7fd01a91dc10 UILabel</code></pre><h4 id="taplog"><a href="#taplog" class="headerlink" title="taplog"></a>taplog</h4><p>将点击的view打印出来，这个命令对于查找哪个view非常有帮助。</p><pre><code>语法:Syntax: taplog</code></pre><p>要查看的view必须能接收点击事件，也就是他的userInteractionEnabled必须为YES才能被找到，UILabel和UIImageView默认userInteractionEnabled为NO。</p><p>我们需要先将程序暂停，输入taplog，程序会自己运行，这时候点击你需要查看的view，控制台上就会显示出你刚刚点击的view相关信息。</p><p>我们先将程序暂停，输入taplog</p><pre><code>(lldb) taplogProcess 28421 resuming</code></pre><p>程序会自己运行，我们再点击一个UIButton:</p><pre><code>&lt;UIButton: 0x7fe6785284e0; frame = (54 244; 46 30); opaque = NO; autoresize = RM+BM; layer = &lt;CALayer: 0x7fe678528a50&gt;&gt;</code></pre><h4 id="flicker"><a href="#flicker" class="headerlink" title="flicker"></a>flicker</h4><p>将view闪烁一下，以便于查找view的位置。</p><pre><code>语法:Syntax: flicker &lt;viewOrLayer&gt;说明:viewOrLayer: 需要闪烁的view或者layer</code></pre><p>我们来看看self.subView的位置</p><pre><code>(lldb) flicker self.subView</code></pre><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1ezmcz9efa1g209q0330r9.gif"></p><h4 id="vs"><a href="#vs" class="headerlink" title="vs"></a>vs</h4><p>在view层级中搜索view，并显示出来。</p><pre><code>语法:Syntax: vs &lt;view&gt;说明:view: 要查找的view</code></pre><p>相比fv，vs主要用于显示view在屏幕上的位置，2个命令可以配合使用。</p><p>假设我们要找屏幕上的一个view</p><p>首先用fv查找UIView类型的view</p><pre><code>(lldb) fv uiview0x7fbcf37228d0 UIView0x7fbcf3725e90 UIView</code></pre><p>然后看看这2个view到底哪个是我们想要找的view</p><pre><code>(lldb) vs 0x7fbcf3725e90Use the following and (q) to quit.(w) move to superview(s) move to first subview(a) move to previous sibling(d) move to next sibling(p) print the hierarchy&lt;UIView: 0x7fbcf3725e90; frame = (0 100; 100 100); layer = &lt;CALayer: 0x7fbcf3712a40&gt;&gt;</code></pre><p>输入命令后他会帮我们在屏幕上用粉红色标志出来vs的view</p><p><img src="http://ww1.sinaimg.cn/mw690/9460be12gw1ezmcziflf5j20kq07ujr6.jpg"></p><p>控制台中vs的view也有相应log。并且还提示有6种子命令:</p><ul><li>w: 移动到superview</li><li>s: 移动到第一个subview</li><li>a: 移动到前面的同级view</li><li>d: 移动到后面的同级view</li><li>p: 打印出层级</li><li>q: 退出</li></ul><p>如果这个不是我们要找的view，可以使用w,s,a,d,p命令继续查找。</p><hr><h2 id="Display"><a href="#Display" class="headerlink" title="Display"></a>Display</h2><p>debug的时候，可能有一小半的工作是跟UI打交道，关于UI显示上的东西，也有几个命令。</p><h4 id="caflush"><a href="#caflush" class="headerlink" title="caflush"></a>caflush</h4><p>刷新UI界面。一般我们用LLDB命令改变UI，UI并不会立即更新，我们需要使用caflush刷新界面。</p><pre><code>语法:Syntax: caflush</code></pre><p>我们用命令将label的背景色改为红色</p><pre><code>(lldb) fv uilabel0x7fb3919189d0 UILabel(lldb) e [((UILabel*)0x7fb3919189d0) setBackgroundColor:[UIColor redColor]](lldb) caflush</code></pre><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ezmczorxsgj20ko02ka9v.jpg"></p><h4 id="border"><a href="#border" class="headerlink" title="border"></a>border</h4><p>给View或者layer加上border。</p><pre><code>语法:Syntax: border [--color=color] [--width=width] &lt;viewOrLayer&gt;说明:--color/-c: 边框颜色，string类型，比如:&#39;red&#39;，&#39;green&#39;，&#39;magenta&#39;等，不设置默认为红色--width/-w: 边框宽度，不设置默认为2viewOrLayer: 需要设置边框的view或者layer</code></pre><p>给刚刚的label加上边框</p><pre><code>(lldb) fv uilabel0x7fe713901f10 UILabel(lldb) border 0x7fe713901f10</code></pre><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ezmczvy6ufj20kk02qmx0.jpg"></p><h4 id="unborder"><a href="#unborder" class="headerlink" title="unborder"></a>unborder</h4><p>去掉view或者layer的border。</p><pre><code>语法:Syntax: unborder &lt;viewOrLayer&gt;</code></pre><p>将刚刚加上的border去掉</p><pre><code>(lldb) unborder 0x7fe713901f10</code></pre><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1ezmd034xwxj20ko02mt8i.jpg"></p><h4 id="mask"><a href="#mask" class="headerlink" title="mask"></a>mask</h4><p>给view添加一个半透明的矩形mask，用来查看view的位置。</p><pre><code>语法:Syntax: mask [--color=color] [--alpha=alpha] &lt;viewOrLayer&gt;说明:--color/-c: mask的颜色，string类型，比如:&#39;red&#39;, &#39;green&#39;,&#39;magenta&#39;等，不设置默认为红色--alpha/-a: mask的透明度，不设置默认为0.5viewOrLayer: 需要添加mask的view或者layer</code></pre><p>假如label是隐藏的，我们给他添加一个mask，看看他的位置在哪儿</p><pre><code>(lldb) fv uilabel0x7fe713901f10 UILabel(lldb) mask 0x7fe713901f10</code></pre><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ezmd0aq6t3j20kq02sdfl.jpg"></p><h4 id="unmask"><a href="#unmask" class="headerlink" title="unmask"></a>unmask</h4><p>将添加的mask去掉。</p><pre><code>语法:Syntax: unmask &lt;viewOrLayer&gt;说明:viewOrLayer: 需要去掉mask的view或者layer</code></pre><p>我们将刚刚添加的mask去掉</p><pre><code>(lldb) unmask 0x7fe713901f10</code></pre><p>使用命令之后，我们可以看到什么都没有了，因为label是hidden的。</p><h4 id="show"><a href="#show" class="headerlink" title="show"></a>show</h4><p>显示一个view或者layer，相当于执行view.hidden = NO。</p><pre><code>语法:Syntax: show &lt;viewOrLayer&gt;说明:viewOrLayer: 需要显示的view或者layer</code></pre><p>将刚刚的label显示出来</p><pre><code>(lldb) show 0x7fe713901f10</code></pre><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1ezmd0ghv9lj20kk02e3yb.jpg"></p><h4 id="hide"><a href="#hide" class="headerlink" title="hide"></a>hide</h4><p>隐藏一个view或者layer，相当于执行view.hidden = YES。</p><pre><code>语法:Syntax: hide &lt;viewOrLayer&gt;说明:viewOrLayer: 需要隐藏的view或者layer</code></pre><p>把label隐藏</p><pre><code>(lldb) hide 0x7fe713901f10</code></pre><p>可以看到label位置什么都没有了。</p><h4 id="slowanim"><a href="#slowanim" class="headerlink" title="slowanim"></a>slowanim</h4><p>减慢动画的速度。</p><pre><code>语法:Syntax: slowanim &lt;speed&gt;说明:speed: 动画的速度，速度越大，动画越快。1表示原始速度。不传参数默认为0.1</code></pre><p>原始动画我们设置为1s</p><pre><code>[UIView animateWithDuration:1 animations:^&#123;    self.subView.frame = frame;&#125;];</code></pre><p>暂停程序，将动画放慢5倍</p><pre><code>(lldb) slowanim 0.2</code></pre><p>我们可以看到动画变慢了:</p><p><img src="http://ww1.sinaimg.cn/mw690/9460be12gw1ezmd0nval3g20ad032glo.gif"></p><h4 id="unslowanim"><a href="#unslowanim" class="headerlink" title="unslowanim"></a>unslowanim</h4><p>取消slowanim效果，将动画速度变为正常。</p><pre><code>语法:Syntax: unslowanim</code></pre><p>我们将刚刚的slowanim效果取消</p><pre><code>(lldb) unslowanim</code></pre><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ezmd0upccmg20ad032745.gif"></p><hr><h2 id="Preview"><a href="#Preview" class="headerlink" title="Preview"></a>Preview</h2><p>预览功能，帮助我们用命令查看一个view或者图片的真正样子。</p><h4 id="visualize"><a href="#visualize" class="headerlink" title="visualize"></a>visualize</h4><p>用预览App打开UIImage, CGImageRef, UIView, CALayer等对象。</p><pre><code>语法:Syntax: visualize &lt;target&gt;说明:target: 需要预览的对象，id类型</code></pre><p>我们来看看某个image的样子</p><pre><code>(lldb) visualize image</code></pre><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ezmd10m7ppj20h00h00v0.jpg"></p><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>LLDB主要用于Debug，chisel怎么可能缺少debug相关命令呢？</p><h4 id="wivar"><a href="#wivar" class="headerlink" title="wivar"></a>wivar</h4><p>为对象的成员变量设置<a href="http://www.jianshu.com/p/e89af3e9a8d7">watchpoint</a>。</p><pre><code>语法:Syntax: wivar &lt;object&gt; &lt;ivarName&gt;说明:object: 需要为成员变量设置watchpoint的对象。id类型ivarName: 成员变量的名字，注意一般属性对应的成员变量带有_前缀</code></pre><p>为self.subView设置watchpoint</p><pre><code>(lldb) wivar self _subViewRemember to delete the watchpoint using: watchpoint delete 1</code></pre><p>这时候，_subView值改变就会中断程序</p><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ezmd17evopj20xa052dg5.jpg"></p><h4 id="bmessage"><a href="#bmessage" class="headerlink" title="bmessage"></a>bmessage</h4><p>根据方法名设置断点。</p><pre><code>语法:Syntax: bmessage &lt;expression&gt;说明:expression: 方法名，如-[MyView setFrame:], +[MyView awesomeClassMethod], -[0xabcd1234 setFrame:]等</code></pre><p>一般设置断点，如果这个方法本类没有实现，是父类实现的，断点是无效的。bmessage有效避免了这种缺陷，即使本类没有实现，也能设置上断点。</p><p>给self中的btnAction:方法设置一个断点</p><pre><code>(lldb) bmessage -[self btnAction:]Setting a breakpoint at -[ViewController btnAction:] with condition (void*)(id)$rdi == 0x00007ff2485311e0Breakpoint 4: where = TLLDB`-[ViewController btnAction:] at ViewController.m:42, address = 0x000000010c4bb620</code></pre><h4 id="binside"><a href="#binside" class="headerlink" title="binside"></a>binside</h4><p>通过一个相对地址，给framework(library)设置断点。</p><pre><code>语法:Syntax: binside &lt;address&gt;说明:address: framework的相对地址</code></pre><h4 id="pinvocation"><a href="#pinvocation" class="headerlink" title="pinvocation"></a>pinvocation</h4><p>打印方法调用堆栈，仅支持x86。</p><pre><code>语法:Syntax: pinvocation [--all]说明:--all/-a: 表示打印所有堆栈，不设置默认只打印当前堆栈</code></pre><p>与bt命令类似，不过信息比bt打印得更详细，遗憾的是只能支持x86。</p><p>打印一下当前堆栈</p><pre><code>(lldb) pinvocationframe #0: 0x000962aa TMasonry`-[ViewController viewDidLoad](self=0x7bf2d9c0, _cmd=&quot;viewDidLoad&quot;) + 234 at ViewController.m:28NSInvocation: 0x7bf433e0self: 0x7bf2d9c0</code></pre><p>打印所有堆栈:</p><pre><code>(lldb) pinvocation -aframe #0: 0x000962aa TMasonry`-[ViewController viewDidLoad](self=0x7bf2d9c0, _cmd=&quot;viewDidLoad&quot;) + 234 at ViewController.m:28NSInvocation: 0x7d2bb050self: 0x7bf2d9c0---------------------------------frame #1: 0x008062ae UIKit`-[UIViewController _sendViewDidLoadWithAppearanceProxyObjectTaggingEnabled] + 44NSInvocation: 0x7be18a50self: 0x7bf2d9c0---------------------------------frame #2: 0x0080adce UIKit`-[UIViewController loadViewIfRequired] + 1384NSInvocation: 0x7bf0cc40self: 0x7bf2d9c0---------------------------------frame #3: 0x008569f9 UIKit`-[UINavigationController _layoutViewController:] + 52NSInvocation: 0x7d340c90self: 0x7c89ee00Argument:0xbff69108, address of @&#125; 0x7bf2d9c0---------------------------------frame #4: 0x008572b1 UIKit`-[UINavigationController _updateScrollViewFromViewController:toViewController:] + 421NSInvocation: 0x7d340cc0self: 0x7c89ee002 Arguments:0xbff69158, address of @&#125; 0x00xbff6915c, address of @&#125; 0x7bf2d9c0---------------------------------frame #5: 0x00857458 UIKit`-[UINavigationController _startTransition:fromViewController:toViewController:] + 145NSInvocation: 0x7bf24870self: 0x7c89ee003 Arguments:0xbff69298, address of i&#125; 00xbff6929c, address of @&#125; 0x00xbff692a0, address of @&#125; 0x7bf2d9c0---------------------------------**</code></pre><hr><h2 id="Accessibility"><a href="#Accessibility" class="headerlink" title="Accessibility"></a>Accessibility</h2><p>这个模块的命令主要利用了<a href="http://nshipster.cn/uiaccessibility/">UIAccessibility</a>相关特性，需要开启才能使用。</p><h4 id="fa11y"><a href="#fa11y" class="headerlink" title="fa11y"></a>fa11y</h4><p>根据view的<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIAccessibility_Protocol/#//apple_ref/occ/instp/NSObject/accessibilityLabel">accessibilityLabel</a>查找view。</p><pre><code>语法:Syntax: fa11y &lt;labelRegex&gt;说明:labelRegex: 需要匹配的text</code></pre><p>注意，UILabel，UIButton的accessibilityLabel等于title。</p><p>我们根据显示的文案，查找相应的控件</p><pre><code>(lldb) fa11y 妈妈(UILabel 0x176b5bd0) 妈妈叫你回家吃饭了</code></pre><h4 id="pa11y"><a href="#pa11y" class="headerlink" title="pa11y"></a>pa11y</h4><p>打印view层级中所有的accessibilityLabel。</p><pre><code>语法:Syntax: pa11y &lt;aView&gt;说明:aView: 需要打印层级的View，UIView类型</code></pre><p>我们打印一下self.view层级中所有的accessibilityLabel</p><pre><code>(lldb) pa11y self.viewUIView self.view   | (UIButton 0x176b4600) Button   | (UILabel 0x176b5bd0) 妈妈叫你回家吃饭了   </code></pre><hr><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul><li><a href="https://github.com/gkassabli/chisel">chisel</a></li><li><a href="http://www.jianshu.com/p/e89af3e9a8d7">小笨狼与LLDB的故事</a></li><li><a href="https://developer.apple.com/library/tvos/documentation/UserExperience/Conceptual/AutolayoutPG/AmbiguousLayouts.html#//apple_ref/doc/uid/TP40010853-CH18-SW1">Ambiguous Layouts</a></li><li><a href="http://nshipster.cn/uiaccessibility/">UIAccessibility</a></li><li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIAccessibility_Protocol/#//apple_ref/occ/instp/NSObject/accessibilityLabel">accessibilityLabel</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Xcode Debug</title>
    <link href="/2015/12/25/2015-12-25-Xcode-Debug/"/>
    <url>/2015/12/25/2015-12-25-Xcode-Debug/</url>
    
    <content type="html"><![CDATA[<p>基于LLDB我们可以在运行期间对App进行Debug，除此之外Xcode也提供了一些设置，使得App在编译期间和运行期间独立LLDB之外方便发现问题。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>一个常见的错误就是，对一个指向已经释放过的对象的指针－即指向无效内存的野指针－进行操作。语义上讲，一个指针在其指向的对象无效时就应该标记为无效，比如指向nil，就算程序中不再使用该指针虽然不会出错，但还是存在着未来变化的风险。指向同一个对象地址的指针可以有很多个，怎么才能确保所有这些指针的安全呢？ARC的weak指针能够解决这一问题。同时，strong指针在试用期间就能确保指向的对象至少存在，所以也不会出错。而等效于MRC时代指针的unsafe_unretained指针就非常容易出错，因为它即不涉及内存管理，也不被安全置nil。那么，autoreleasing指针呢？</p><pre><code>&#123;    __autoreleasing NSArray *test = nil;    @autoreleasepool &#123;        test = @[@&quot;A&quot;, @&quot;B&quot;, @&quot;C&quot;];    &#125;    [test count];&#125;</code></pre><p>会发生EXC_BAD_ACCESS错误。test在离开{}后其注册在AutoreleasePool的对象被释放，但是test还是指向原地址没有被安全处理。所以，unsafe_unretained和autoreleasing指针都不是安全的。</p><p>为什么有时候已经释放过的对象，使用指向它的指针不会粗错呢？这是因为，Apple对回收对象内存这个行为不一定按照字面理解那样。最简单的就是更改heap的统计信息，而没有将内存全部置为0。如果在使用野指针时，其指向的内存还跟对象释放前一样的内容，那么这个时候是可以看起来正常运行的。</p><pre><code>&#123;    NSView *view = [[NSView alloc] init];    [view release];    [[[NSWindow alloc] init] autorelease];    [view description];&#125;</code></pre><p>这是个不易发现但又确实存在的问题。</p><h3 id="Static-Analyze"><a href="#Static-Analyze" class="headerlink" title="Static Analyze"></a>Static Analyze</h3><p>静态分析指的是一种在不执行程序的情况下对程序代码进行分析的行为，对应着Scheme的Analyze(快捷键Shift+Command+B)。静态分析主要通过分析语法来发现这几种问题：</p><ul><li>逻辑错误：访问未初始化的变量等。</li><li>声明错误：从未使用过的变量等。</li><li>内存错误：内存泄漏或错误释放等。</li></ul><p>声称变量并初始化是一个良好又安全的习惯，访问为初始化的变量将会带来出乎意料的行为。</p><p><img src="http://ww1.sinaimg.cn/mw690/9460be12gw1ezcyp1e26aj20qq06q75m.jpg"></p><p>对于没有使用的变量，虽然不会引起程序出错，编译优化时也可能直接省略掉，但是这些信息是可以在源代码中去掉的，这可以提高代码简洁度。</p><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1ezcyotzzpsj20qq02y74k.jpg"></p><p>ARC不代表所有内存操作都没有问题，对于使用了不属于ARC管理范围的内存操作就可能出现问题。</p><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1ezcyomwsfxj21gg05yq5f.jpg"></p><p>MRC相比于ARC出错的可能性要多得多，所以MRC时使用Analyze比ARC时更有必要。像之前内存回收的问题，在Analyze的帮助下可以在运行之前就能发现。</p><p><img src="http://ww3.sinaimg.cn/mw690/9460be12gw1ezcyogrphgj20qo04i759.jpg"></p><p>这些问题在编译期间很难被发现，但是通过Analyze就变得容易。总的来说，虽然Analyze不能发现并解决所有的问题，但是从预防角度来讲，Analyze是成本最低的改成代码错误的方法。阶段性地在Run前Analyze一下是个好习惯。可以在Build Settings里也可以通过设置，让Xcode在Build时也执行Analyze及执行程度。</p><p><img src="http://ww3.sinaimg.cn/mw690/9460be12gw1ezb4f6xt0qj20qw06yaaz.jpg"></p><h3 id="NSZombieEnabled"><a href="#NSZombieEnabled" class="headerlink" title="NSZombieEnabled"></a>NSZombieEnabled</h3><p>我在<a href="http://hllovesgithub.github.io/2015/11/07/2015-11-07[Runtime%E5%BA%94%E7%94%A8]/">Runtime应用</a>里介绍过NSZombieEnabled，这能够让对象伪释放，动态修改对象的类型信息，利用转发消息机制将发送给伪释放对象的消息传递到特定类型，打印出来以供追踪。Xcode的Scheme里面，可以在Argument的Environment Variable里设置：</p><p><img src="http://ww3.sinaimg.cn/mw690/9460be12gw1ezb386rnpoj20gs05emxf.jpg"></p><p>也可以在Diagnostics里设置：</p><p><img src="http://ww1.sinaimg.cn/mw690/9460be12gw1ezb38e6yr4j20gy04wjrw.jpg"></p><p>不过需要注意的是，因为Zombie对象并没有真正地释放内存，所以适合在发现问题后设置并重跑直面问题，否则长时间运行会产生大量不必要也消不掉的内存。</p><h3 id="Memory-Management－Malloc"><a href="#Memory-Management－Malloc" class="headerlink" title="Memory Management－Malloc"></a>Memory Management－Malloc</h3><p>对于语义上已经释放了、但是内存内容没有改变，且有时Zombie不适合的问题，可以在对象内存释放时在对应内存中写入无意义数据，如0×55(销毁时)，0xAA(生成时)；对于定位大内存越界访问的问题，可以在大内存分配之前和之后添加边界保护页；对于向内存缓冲区溢出和缓冲区释放后再用这样的常见内存问题，可以使用libgmalloc来追踪。Xcode都已经有了这些功能，分别是<strong>Malloc Scribble</strong>和<strong>Malloc Guard Edges</strong>和<strong>Guard Malloc</strong>，其实这些功能都是对malloc库(libsystem_malloc.dylib)自身调试库的调用。这些都能让相应的潜在的内存错误更容易显示地准确地暴露出来。</p><p><img src="http://ww1.sinaimg.cn/mw690/9460be12gw1ezb45ooq9lj20gw04u0ta.jpg"></p><h3 id="Logging－Malloc"><a href="#Logging－Malloc" class="headerlink" title="Logging－Malloc"></a>Logging－Malloc</h3><p>有时候发现了野指针，通过Scribble确定了是意外释放，但是找不到释放的地方时，就可以使用Logging来追踪。Xcode提供了Malloc Stack功能来记录内存分配和释放的日志。在终端中使用<strong>malloc_history</strong>，App的PID、crash的地址，这里记录着该地址对应的所有分配释放日志。最终可以找到是谁对它意外释放了的。</p><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ezb45vxld3j20dy04ut94.jpg"></p><h3 id="Address-Sanitization"><a href="#Address-Sanitization" class="headerlink" title="Address Sanitization"></a>Address Sanitization</h3><p><strong>EXC_BAD_ACCESS</strong>一直是很多开发者的噩梦，因为这个错误出现后难以实现跟踪。Apple在Xcode7中带来了提升，这样的错误会有更详细的信息，甚至会有内存使用情况的展示。启用该功能会在App下一次运行时重新编译，插入调试信息。</p><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1ezb466y091j20fu02iaa9.jpg"></p><h3 id="Environment-Variable"><a href="#Environment-Variable" class="headerlink" title="Environment Variable"></a>Environment Variable</h3><p>通过添加能起到调试作用的环境变量能：</p><ul><li>NSZombieEnabled</li><li>MallocLogFile</li><li>MallocGuardEdges</li><li>MallocDoNotProtectPrelude</li><li>MallocDoNotProtectPostlude</li><li>StackLogging</li><li>StackLoggingNoCompact</li><li>MallocCorruptionAbort</li><li>MallocNanoZone</li><li>MallocCheckHeap</li><li>CA_DEBUG_TRANSACTIONS</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说，ARC要比MRC安全的多，在CoreFoundation的也支持ARC后更是如此，但是使用ARC也不是完全没事绝对安全的，比如block的循环引用。非Objc对象造成的内存错误可以有malloc相关的技术发现。这些工具都是帮助定位错误的地方，最根本的还是开发者自身编码习惯的培养和内存原则的执行。</p><hr><h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><ul><li><a href="http://www.cocoachina.com/ios/20140526/8555.html">5个Xcode开发调试技巧</a></li><li><a href="https://developer.apple.com/library/watchos/recipes/xcode_help-scheme_editor/Articles/SchemeDiagnostics.html#//apple_ref/doc/uid/TP40010402-CH9-SW1">Running Your Application with Diagnostics</a></li><li><a href="http://www.cocoachina.com/ios/20150922/13383.html">说说iOS与内存管理（中）</a></li><li><a href="http://www.cocoachina.com/ios/20151020/13794.html">Xcode7中你一定要知道的炸裂调试神技</a></li><li><a href="http://jimkubicek.com/blog/2013/04/23/debugging-memory-smashers/">Debugging Smashed Memory in Obj-C</a></li><li><a href="http://bugly.qq.com/blog/?p=200">先提高野指针Crash率</a></li><li><a href="http://bugly.qq.com/blog/?p=308">让非必现Crash变成必现</a></li><li><a href="http://bugly.qq.com/blog/?p=335">加点黑科技让Crash自报家门</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LLDB基本使用</title>
    <link href="/2015/12/19/2015-12-19-LLDB%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2015/12/19/2015-12-19-LLDB%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>LLDB是一个有着REPL(Read-Eval-Print-Loop)的特性和C++、Python插件的开源调试器。LLDB内置于Xcode，存在于主窗口底部的控制台中。调试器允许你在程序运行的特定时暂停它，你可以查看变量的值，执行自定的指令，并且按照你所认为合适的步骤来操作程序的进展。</p><h3 id="LLDB命令结构"><a href="#LLDB命令结构" class="headerlink" title="LLDB命令结构"></a>LLDB命令结构</h3><pre><code>&lt;command&gt; [&lt;subcommand&gt; [&lt;subcommand&gt;...]] &lt;action&gt; [-options [option-value]] [argument [argument...]]</code></pre><ul><li>command和subcommand：LLDB调试命令的名称。命令和子命令按层级结构来排列，一个命令为其子命令创建上下文，子命令又为其子命令创建上下文，依此类推。</li><li>action：在前面的命令序列上下文中执行的一些操作。</li><li>options：行为修改器(action modifiers)。</li><li>argument：不同命令上下文表示不同意义的参数。</li></ul><p>LLBD命令解析后再执行。上面这些元素之间通过空格分割，如果某一元素自身含有空格，则可以使用双引用；而如果元素中又包含双引号，则可以使用反斜杠；或者元素使用单引号。</p><pre><code>(lldb) command [subcommand] -option &quot;some \&quot;quoted\&quot; string&quot;(lldb) command [subcommand] -option &#39;some &quot;quoted&quot; string&#39;</code></pre><h3 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h3><p>LLDB中的命令选项有<strong>规范</strong>形式和<strong>缩写</strong>形式两种格式。以设置断点的命令breakpoint set为例，括号中的是规范形式：</p><pre><code>breakpoint set   -M &lt;method&gt; (--method &lt;method&gt;)   -S &lt;selector&gt; (--selector &lt;selector&gt;)   -b &lt;function-name&gt; (--basename &lt;function-name&gt;)   -f &lt;filename&gt; (--file &lt;filename&gt;)   -l &lt;linenum&gt; (--line &lt;linenum&gt;)   -n &lt;function-name&gt; (--name &lt;function-name&gt;)</code></pre><p>各选项的顺序是任意的。如果后面的参数是以”-“开头的，则在选项后面添加”–”作为选项的终止信号。</p><pre><code>(lldb) process launch --stop-at-entry -- -program_arg_1 value -program_arg_2 value</code></pre><p>–stop-at-entry是命令选项，-program_arg_1和-program_arg_2是参数，中间使用”–”区分。</p><h3 id="唯一匹配原则"><a href="#唯一匹配原则" class="headerlink" title="唯一匹配原则"></a>唯一匹配原则</h3><p>LLDB的命令遵循唯一匹配原则：假如根据前n个字母已经能唯一匹配到某个命令，则只写前n个字母等效于写下完整的命令，比如：</p><pre><code>breakpoint set -n main等价于br s -n main</code></pre><h3 id="lldbinit"><a href="#lldbinit" class="headerlink" title="~/.lldbinit"></a>~/.lldbinit</h3><p>LLDB有了一个启动时加载的文件~/.lldbinit，每次启动都会加载。所以初始化的事儿，比如命令别名，都可以写入其中，但由于这事lldb还没有开始调试，所以有些操作无法进行，比如设置断点。</p><hr><h3 id="在命令行中调试"><a href="#在命令行中调试" class="headerlink" title="在命令行中调试"></a>在命令行中调试</h3><h5 id="程序："><a href="#程序：" class="headerlink" title="程序："></a>程序：</h5><pre><code>$ lldb /Projects/Sketch/build/Debug/Sketch.app或者$ lldb(lldb) file /Projects/Sketch/build/Debug/Sketch.app一旦指定了调试哪个程序，并为其设置了一些断点后，就可以开始运行程序了(lldb) process launch(lldb) run同样可以使用进程ID或进程名来连接一个已经运行的程序(lldb) process attach --pid 123(lldb) process attach --name Sketch</code></pre><h5 id="断点："><a href="#断点：" class="headerlink" title="断点："></a>断点：</h5><pre><code>如果想在某个文件中的某行设置一个断点(lldb) breakpoint set --file foo.c --line 12如果想给某个C函数设置断点(lldb) breakpoint set --name foo如果想给C++中所有命名为foo的方法设置断点(lldb) breakpoint set --method foo如果想给Objec中所有命名为alignLeftEdges:的选择器设置断点(lldb) breakpoint set --selector alignLeftEdges:如果想在一个特定的可执行库中某个C函数设置断点(lldb) breakpoint set --shlib foo.dylib --name foo如果想查看所有断点(lldb) breakpoint listCurrent breakpoints:1: file = , line = , locations = , resolved = , hit count =   1.1: where = , address = , resolved, hit count = </code></pre><p>每个断点都有一个整数标识，如上所示的1。每个断点有至少一个断点位置，每个位置也会有一个标识，如上所示的1.1。<strong>resolved</strong>标识表示当与之相关的文件地址被加载到程序进行调试时，其位置是已解析的。例如，如果在共享库中设置的断点之后被卸载了，则断点的位置还会保留，但其不能再被解析。</p><h5 id="观察点："><a href="#观察点：" class="headerlink" title="观察点："></a>观察点：</h5><p>Watchpoint是一个用来监听变量的值的变化或者内存地址的变化的工具，发生变化时会在debugger中触发一个暂停。对于那些不知道如何准确跟踪的状态问题，可以利用这个工具来解决。值得注意的是，硬件资源对观察点有数目限制，一般为4个。对那些设置失败的观察点需要禁用或者删除来释放资源。</p><pre><code>添加变量观察点(lldb)watchpoint set variable添加地址观察点(lldb)watchpoint set expression查看所有观察点(lldb)watchpoint list</code></pre><h5 id="控制："><a href="#控制：" class="headerlink" title="控制："></a>控制：</h5><pre><code>启动程序后，LLDB允许程序在到达断点前继续运行。LLDB中流程控制的命令都在thread命令层级中(lldb)thread continue (=c)(lldb)thread step-in (=s)(lldb)thread step-over (=n)(lldb)thread step-out (=finish)(lldb)thread step-inst (=si =stepi)(lldb)thread step-over-inst (=ni =nexti)使得当前函数立即以某值返回(可能会使内存出错)(lldb)thread return LLDB还提供了run until line按步调度模式(lldb) thread until 100这条命令会运行当前线程，直到当前帧(frame)所在文件的第100行。</code></pre><h5 id="线程："><a href="#线程：" class="headerlink" title="线程："></a>线程：</h5><pre><code>获取当前所有线程(lldb) thread list* thread #1: tid = , where = , stop reason = , queue =  thread #1: tid = , where = , stop reason = , queue =   thread #1: tid = , where = , stop reason = , queue = 星号(*)表示thread #1为当前线程。获取线程调用栈(lldb) thread backtrace (=bt)获取当前线程信息(lldb) thread info获取调用栈当前帧可见变量(lldb) frame variable获取调用栈当前帧信息(lldb) frame info切换调用栈的当前帧(lldb) frame select (=f)</code></pre><h5 id="内存："><a href="#内存：" class="headerlink" title="内存："></a>内存：</h5><pre><code>读出指定地址内存内容(lldb)memory read(lldb)x (=memory read)写入指定地址内存内容(lldb)memory write</code></pre><h5 id="表达式："><a href="#表达式：" class="headerlink" title="表达式："></a>表达式：</h5><p>expression/<a href="https://sourceware.org/gdb/onlinedocs/gdb/Output-Formats.html">格式</a>：</p><pre><code>在LLDB中执行一个表达式(lldb)expression执行没有返回值的表达式(lldb)call (=&#39;expression --&#39;)执行基本类型的表达式(lldb)p (=&#39;expression --&#39;)执行objc对象类型的表达式(lldb)po (=&#39;expression -o --&#39;)同p(lldb)print (=&#39;expression --&#39;)</code></pre><h5 id="寄存器："><a href="#寄存器：" class="headerlink" title="寄存器："></a>寄存器：</h5><pre><code>获取调用栈当前帧的寄存器值(lldb) register read异常中断时，通过访问寄存器(Mac和Simulator用$rax，Device用$r0)获得异常信息(lldb) po [$rax class](lldb) po [$rax name](lldb) po [$rax reason]</code></pre><h5 id="目标模块："><a href="#目标模块：" class="headerlink" title="目标模块："></a>目标模块：</h5><pre><code>(lldb)image (=target modules)查看程序和依赖共享库(lldb)image list查看程序和依赖共享库的信息(lldb)image lookup当程序崩溃时，可以使用image来查找崩溃所在的具体位置NSArray *array = @[@1, @2];NSLog(@&quot;item 3: %@&quot;, array[2]);这段代码运行后会抛出异常： 0 CoreFoundation   0x00007fff8e06f66c __exceptionPreprocess + 172 1 libobjc.A.dylib  0x00007fff886ad76e objc_exception_throw + 43 2 CoreFoundation   0x00007fff8df487de -[__NSArrayI objectAtIndex:] + 190 3 test             0x0000000100000de0 main + 384 4 libdyld.dylib    0x00007fff8f1b65c9 start + 1根据以上信息，能判断崩溃在模块test中，要想知道具体文件具体位置(lldb) image lookup --address 0x0000000100000de0Address: test[0x0000000100000de0] (test.__TEXT.__text + 384)Summary: test`main + 384 at main.m:23当想查看一个符号的信息时，可以使用image来查找(lldb) image lookup --name当想查看一个类型的信息时，可以使用image来查找(lldb) image lookup --type</code></pre><h5 id="目标暂停钩子："><a href="#目标暂停钩子：" class="headerlink" title="目标暂停钩子："></a>目标暂停钩子：</h5><p>使用LLDB进行调试时，大多数时候需要让程序暂停，不管是breakpoint还是watchpoint。需要在每次stop时执行的命令可以使用暂停钩子实现(只对breakpoint和watchpoint的程序stop生效，对直接点击Xcode上的pause或者debug view hierarchy不会生效)：</p><pre><code>添加暂停钩子(lldb) target stop-hook add (=display)删除暂停钩子(lldb) target stop-hook delete (=undisplay)查看钩子所有暂停钩子(lldb) target stop-hook list启用暂停钩子(lldb) target stop-hook enable禁用暂停钩子(lldb) target stop-hook disable</code></pre><h5 id="目标符号："><a href="#目标符号：" class="headerlink" title="目标符号："></a>目标符号：</h5><p>程序要运行之前，都会编译成二进制文件，同时会生成dSYM文件(记录了源代码和二进制映射关系)，这样对代码打断点就会对应到二进制上。当Xcode找不着dSYM文件时无法调试，通过手动地将对应的dSYM文件添加到对应的目标，建立源代码和二进制的关映射系：</p><pre><code>(lldb) image symbol add (=add-sym)</code></pre><h5 id="别名系统："><a href="#别名系统：" class="headerlink" title="别名系统："></a>别名系统：</h5><p>LLDB的别名机制能为常用的命令创建一个别名，方便使用：</p><pre><code>(lldb) breakpoint set --file foo.c --line 12等价于：(lldb) command alias bfl breakpoint set -f %1 -l %2(lldb) bfl foo.c 12如果不想要已有的别名了，可以取消：(lldb) command unalias b</code></pre><h5 id="常见问题："><a href="#常见问题：" class="headerlink" title="常见问题："></a>常见问题：</h5><p>LLDB的expression parser有一个bug，不兼容非ASCII字符，需要处理一下才行，否则会报错“An Objective-C constant string’s string initializer is not an array”</p><pre><code>(lldb) expression @&quot;哈哈&quot;Internal error [IRForTarget]: An Objective-C constant string&#39;s string initializer is not an arrayerror: 0 errors parsing expressionerror: The expression could not be prepared to run in the target(lldb) expression [NSString stringWithUTF8String:&quot;哈哈&quot;](__NSCFString *) $5 = 0x0000618000025ca0 @&quot;哈哈&quot;</code></pre><p>类型不明或不匹配</p><pre><code>(lldb) p NSLog(@&quot;%@&quot;,[self.view  viewWithTag:1001])error: &#39;NSLog&#39; has unknown return type; cast the call to its declared return typeerror: 1 errors parsing expression如果在使用LLDB命令中发现有unknown type的类似错误(多见于id类型)，就必须显式声明类型。p (void)NSLog(@&quot;%@&quot;,[self.view  viewWithTag:1001])</code></pre><p>找不到方法</p><pre><code>(lldb) po self.view.frameerror: unsupported expression with unknown typeerror: unsupported expression with unknown typeerror: 2 errors parsing expression无法通过点属性访问的方法(lldb) p (CGRect)[self.view frame](CGRect) $0 = origin=(x=0, y=0) size=(width=320, height=480)</code></pre><p>不过已经有解决方法了</p><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ez5zykcmevj20gb07ajsw.jpg"></p><hr><h3 id="在Xcode中调试"><a href="#在Xcode中调试" class="headerlink" title="在Xcode中调试"></a>在Xcode中调试</h3><p>Xcode集成了LLDB(代替了原来的GDB)，在Xcode启动Run时自动将App关联到LLDB并启动调试。LLDB的调试窗口在ConsoleView，那里可以输入LLDB的命令进行调试。下面从Xcode的UI调试说起。</p><h5 id="一般断点-Normal-Breakpoint-："><a href="#一般断点-Normal-Breakpoint-：" class="headerlink" title="一般断点(Normal Breakpoint)："></a>一般断点(Normal Breakpoint)：</h5><p>快捷键Command+\</p><p>在代码编译器左边的行数栏处，可以用鼠标点击生成一个断点标签。</p><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ez5xzqmt7fj204605k3ym.jpg"></p><p>右键标签对断点进行编辑、禁用启用、删除。</p><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ez5xzwlkgpj20h0098gn8.jpg"></p><p>在编辑里，可以添加响应条件、忽略次数、执行动作和暂停继续。这些都可以在命令行设置。</p><p><img src="http://ww3.sinaimg.cn/mw690/9460be12gw1ez5y02isz8j20qk09a0uy.jpg"></p><p>执行的动作包括执行Apple脚本、截取GPU参数、LLDB命令、日志信息、Shell命令和发声。</p><p><img src="http://ww3.sinaimg.cn/mw690/9460be12gw1ez5y0a8e44j20r60fqn1c.jpg"></p><h5 id="异常断点-Exception-Breakpoint-："><a href="#异常断点-Exception-Breakpoint-：" class="headerlink" title="异常断点(Exception Breakpoint)："></a>异常断点(Exception Breakpoint)：</h5><p>Objc中的异常是一个常被忽略的地方，大部分错误信息，系统框架都会以异常的形式throw出来。添加异常断点后，每次当程序发生了异常时，会被中断并定位在异常产生的代码，有利于跟踪定位。</p><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ez5y0flvipj20ek070taj.jpg"></p><p>在编辑里，可以选择异常种类(Objc和C++)、响应时机、执行动作和暂停继续。</p><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ez5y0lk2cxj20qw092gp3.jpg"></p><h5 id="符号断点-Symbolic-Breakpoint-："><a href="#符号断点-Symbolic-Breakpoint-：" class="headerlink" title="符号断点(Symbolic Breakpoint)："></a>符号断点(Symbolic Breakpoint)：</h5><p>快捷键Option+Command+\</p><p>符号断点是指在某个特定的函数或方法<strong>开始</strong>的地方，暂停程序执行，通过这种方式添加断点，就不需要知道在源文件中添加，也不需要知道断点设置在文件的第几行。</p><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1ez5y17e5zoj20ek06odhl.jpg"></p><p>在编辑里，可以选择响应符号(C函数或C++方法或Objc选择器的名字)、响应模块、相应条件、忽略次数、执行动作和暂停继续。</p><p><img src="http://ww3.sinaimg.cn/mw690/9460be12gw1ez5y1cwc3ej20qq0bq77x.jpg"></p><p>常用的符号有**”objc_exception_throw”<strong>(等价于异常断点)和</strong>“-[NSObject(NSObject) doesNotRecognizeSelector:]”**(跟踪objc方法调用失败)。</p><h5 id="测试断点："><a href="#测试断点：" class="headerlink" title="测试断点："></a>测试断点：</h5><p>在测试用例编辑器或者断点导航栏里添加，这个类型的断点会在测试用例失败时，暂停程序执行并定位在失败的地方。</p><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ez5y8kj751j20e8080dhl.jpg"></p><h5 id="观察点：-1"><a href="#观察点：-1" class="headerlink" title="观察点："></a>观察点：</h5><p>观察点也可以在Xcode设置，不过不像断点在编辑器里，观察点在Variable View里。右键点击想要观察的点，选择Watch。</p><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ez5y1ineehj20ji05m0ts.jpg"></p><p>观察点同样列在了断点导航器里面进行管理。注意，Xcode默认是创建的读写观察，如果想要只读和只写观察，还是得用命令行。同时，无效的观察点记得及时禁用或者删除，因为观察点数目有限很珍贵，也可以减少不必要的中断。</p><h5 id="内存：-1"><a href="#内存：-1" class="headerlink" title="内存："></a>内存：</h5><p>除了在命令行里使用x或者memory read读取指定地址的内存外，也可以在Xcode设置。同观察点一样，内存查看在Variable View里。右键点击想要观察的变量，选择View Memory。</p><p><img src="http://ww3.sinaimg.cn/mw690/9460be12gw1ez5y1os0ztj20jk05k0tt.jpg"></p><p>或者Debug-&gt;Debug Workflow-&gt;View Memory或者快捷键Shift+Command+M。这里你可以输入任何想要查看的内存地址，查看的篇幅，以后翻页。</p><h5 id="界面："><a href="#界面：" class="headerlink" title="界面："></a>界面：</h5><p>Xcode6前有许多第三方的界面调试工具，比如最著名的Reveal。Xcode6后提供了DebugViewHierarchy功能，它可以让开发者在程序运行时，动态的查看当前界面的显示情况，包括视图的层次，控件的大小和位置，而且会以3D效果显示当前视图的层次。虽然功能没有Reveal丰富，但是足够使用，界面调试以后再专门学习介绍。</p><p><img src="http://ww3.sinaimg.cn/mw690/9460be12gw1ez5y223hmvj20ly05675m.jpg"></p><p>或者在调试导航栏里选择查看方法为UI。</p><p><img src="http://ww1.sinaimg.cn/mw690/9460be12gw1ez5y287542j20j205g75u.jpg"></p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于lldb相关的调试项，在Xcode开始就可以设置好一些断点，比如全局的异常断点，常用的符号断点-[NSObject(NSObject) doesNotRecognizeSelector:]，并设置好action和sound，这样能在运行时截获大部分常见的错误，也能获取详细的信息和形象的提醒。在命令行中使用<a href="https://github.com/facebook/chisel"><strong>Chisel</strong></a>能帮助提升调试效率。</p><hr><h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><ul><li><a href="http://www.cocoachina.com/industry/20130701/6514.html">Xcode中断点的威力</a></li><li><a href="http://www.starfelix.com/blog/2014/03/17/lldbdiao-shi-ming-ling-chu-tan/">LLDB调试命令初探</a></li><li><a href="http://southpeak.github.io/blog/2015/01/25/tool-lldb/">LLDB调试器使用简介</a></li><li><a href="http://www.cocoachina.com/ios/20150803/12805.html">breakpoints、lldb 和 chisel 的使用</a></li><li><a href="http://www.jianshu.com/p/e89af3e9a8d7">小笨狼与LLDB的故事</a></li><li><a href="http://objccn.io/issue-19-1/">调试：案例学习</a></li><li><a href="http://objccn.io/issue-19-2/">与调试器共舞 - LLDB 的华尔兹</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Objc高级编程之Block-读书笔记</title>
    <link href="/2015/12/12/2015-12-12-Objc%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8BBlock-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2015/12/12/2015-12-12-Objc%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8BBlock-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="Block存储域"><a href="#Block存储域" class="headerlink" title="Block存储域"></a>Block存储域</h3><p>Block也是Objc对象，其类型有以下几种：</p><ul><li>_NSConcreteStatckBlock</li><li>_NSConcreteGlobalBlock</li><li>_NSConcreteMallocBlock</li></ul><p>目前ARC已经不再创建_NSConcreteStatckBlock类型的Block对象，进一步确保了block在使用时候的有效性，不过本书的内容我还是如实记录。_NSConcreteStatckBlock类的对象存储在栈(Stack)上，_NSConcreteGlobalBlock类的对象存储在数据区(.data)上，_NSConcreteMallocBlock类的对象存储在堆(Heap)上。</p><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1eyxyexv5omj20zi0t6tdm.jpg"></p><p>因为_NSConcreteGlobalBlock类型的block内部不依赖执行时的状态，所以能够用结构体存储在与全局变量相同的数据区域中。在整个程序周期内都可以安全地使用。但是在栈上_NSConcreteStatckBlock类的block，如果其所在作用域结束后就会被销毁，__block变量也一样。</p><p><img src="http://ww3.sinaimg.cn/mw690/9460be12gw1eyxyf5zapgj21eq0pwwl4.jpg"></p><p>Apple提供了将block和__block变量从栈<strong>复制</strong>到堆的方法解决了这个问题，这样即使block的作用域结束，我们还是可以继续安全地访问堆上的block。</p><p><img src="http://ww3.sinaimg.cn/mw690/9460be12gw1eyxyffcaq6j21do15c7db.jpg"></p><p>通过block结构体成员变量__forwarding的帮助，__block变量无论在栈上还是在堆上都能够被正确地访问(后面详细说明)。</p><pre><code>typedef int (^blk_t)(int);blk_t func(int rate) &#123;    return ^(int count) &#123;return rate * count;&#125;;&#125;//等价于typedef int (^blk_t)(int);blk_t func(int rate) &#123;    blk_t tmp = &amp;__func_block_impl_0(__func_block_func_0, &amp;__func_block_desc_0_DATA, rate);    tmp = objc_retainBlock(tmp);    return objc_autoreleaseReturnValue(tmp);&#125;//而objc_retainBlock实际上就是_Block_copy</code></pre><p>大多数情况下编译器会适当地判断block的内存管理，不过少数情况还是需要开发者手动管理。比如向方法的参数传递block时，编译器就不能判断是否对block进行copy。这主要以来方法内部的实现是否自己对作为参数的block进行copy，对于copy过的方法，使用时就不用再对block手动copy。相反，就需要考虑手动复制(当然，目前已经没有_NSConcreteStatckBlock类的block存在也不存在这样的问题了)。</p><pre><code>- (id)getBlockArray &#123;    int val = 10;    return @[[^&#123;NSLog(@&quot;blk0:%d&quot;, val);&#125; copy], [^&#123;NSLog(@&quot;blk1:%d&quot;, val);&#125; copy]];&#125;</code></pre><p>不管block之前存储在哪，用copy复制都不会引起任何问题，如果不确定时最好copy。</p><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1eyxyh6kwg9j21xm0l8n2b.jpg"></p><h3 id="block变量存储域"><a href="#block变量存储域" class="headerlink" title="__block变量存储域"></a>__block变量存储域</h3><p>当block从栈copy到堆时，其使用的所有__block变量也全部从栈复制到堆。如果block已经在堆上，对block再次copy也不会对__block变量有任何影响。</p><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1eyxyfmyecjj212y0smtdw.jpg"></p><p>多个block使用同一个__block变量时，任何一个block先从栈copy到堆后，__block变量也被copy到堆上并被持有，当其他block再copy到堆上时，仅仅增加__block变量的引用计数。</p><p><img src="http://ww3.sinaimg.cn/mw690/9460be12gw1eyxyfy0c8rj21qq1ceand.jpg"></p><p>block从堆中被销毁时，其使用的__block变量也会被销毁。block的内存管理和objc对象的内存管理完全相同。</p><p><img src="http://ww3.sinaimg.cn/mw690/9460be12gw1eyxygbkd1rj21tw1d87kg.jpg"></p><p>不管__block变量存储在栈上还是堆上，都能够正确地访问对应的变量。所有栈中的__block变量，将其架构体内部的forwarding值从自己替换为堆上的__block变量，这样无论栈上__block还是堆上__block都是forwarding指向同一个堆上结构体。</p><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1eyxygqh06uj21qa1bwqfc.jpg"></p><h3 id="截获对象"><a href="#截获对象" class="headerlink" title="截获对象"></a>截获对象</h3><pre><code>blk_t blk;&#123;   id array = [[]NSMutableArray alloc] init];   blk = [^(id obj) &#123;       [array addObject:obj];       NSLog(@&quot;array count = %ld&quot;, [array count]);   &#125; copy];&#125;blk([[NSObject alloc] init]);blk([[NSObject alloc] init]);blk([[NSObject alloc] init]);</code></pre><p>作用域结束后block调用正常，意味着变量array其超出作用域而存在并没有被销毁。</p><pre><code>//编译器模拟代码struct __block_impl &#123;    void *isa;    int Flags;    int Reserved;    void *FuncPtr;&#125;;static void __main_block_copy_0(struct __main_block_impl_0 *dst, struct __main_block_impl_0 *src) &#123;    _Block_object_assign(&amp;dst-&gt;array, src-&gt;array, BLOCK_FIELD_IS_OBJECT);&#125;static void __main_block_dispose_0(struct __main_block_impl_0 *src) &#123;    _Block_object_dispose(src-&gt;array, BLOCK_FIELD_IS_OBJECT);&#125;static struct __main_block_desc_0 &#123;    unsigned long reserved;    unsigned long Block_size;    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);    void (*dispose)(struct __main_block_impl_0*);&#125;__main_block_desc_0_DATA = &#123;    0,    sizeof(struct __main_block_impl_0),    __main_block_copy_0,    __main_block_dispose_0&#125;;struct __main_block_impl_0 &#123;    struct __block_impl impl;    struct __main_block_desc_0* Desc;    id __strong array;    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, id __strong _array, int flags=0) : array(_array) &#123;        impl.isa = &amp;_NSConcreteStackBlock;        impl.Flags = flags;        impl.FuncPtr = fp;        Desc = desc;    &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself, id obj) &#123;    id __strong array = __cself-&gt;array;    [array addObject:obj];    NSLog(@&quot;array count = %ld&quot;, [array count]);&#125;blk_t blk;&#123;    id __strong array = [[NSMutableArray alloc] init];    blk = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, array, 0x22000000);    blk = [blk copy];&#125;(*blk-&gt;impl.FuncPtr)(blk, [[NSObject alloc] init]);(*blk-&gt;impl.FuncPtr)(blk, [[NSObject alloc] init]);(*blk-&gt;impl.FuncPtr)(blk, [[NSObject alloc] init]);</code></pre><p>作用域的局部自动变量array赋值给了block结构体中的成员变量，按照之前的描述，C语言结构体不能含有strong修饰符变量，因为编译器不知道应该何时对C语言结构体进行初始化和销毁从而管理内存，但是objc的runtime能够准确把握block从栈copy到堆以及从堆中销毁的时机，因此能够自动管理block结构体的初始化和销毁时机。</p><p><img src="http://ww1.sinaimg.cn/mw690/9460be12gw1eyxyhiguv6j21xi0f8n0z.jpg"></p><p>具体表现如下：</p><ul><li>调用block的copy方法时</li><li>block作为方法的返回值返回时</li><li>将block赋值给类的__strong修饰符id类型成员变量</li><li>方法名中含有usingBlock的Cocoa框架方法和GCD方法中传递block作为参数时</li></ul><p>实现该功能需要在block描述结构体(XX_block_desc_X)中添加copy和dispose方法。在main_block_copy_0方法里，**_Block_object_assign<strong>相当于retain，持有对象并赋值给block实现结构体(XX_block_impl_X)中的成员变量。在main_block_dispose_0方法里，</strong>_Block_object_dispose**相当于release，释放赋值在block实现结构体中的成员变量。其中，参数BLOCK_FIELD_IS_OBJECT和BLOCK_FIELD_IS_BYREF用语区分对象类型和__block类型。</p><h3 id="block变量和对象"><a href="#block变量和对象" class="headerlink" title="__block变量和对象"></a>__block变量和对象</h3><pre><code>__block id obj = [[NSObject alloc] init];//编译器模拟代码struct __Block_byref_obj_0 &#123;    void *__isa;    __Block_byref_obj_0 *__forwarding;    int __flags;    int __size;    void (*__Block_byref_id_object_copy)(void*, void*);    void (*__Block_byref_id_object_dispose)(void*);    __strong id obj;&#125;;static void __Block_byref_id_object_copy_131(void *dst, void *src) &#123;    _Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);&#125;static void __Block_byref_id_object_dispose_131(void *src) &#123;    _Block_object_dispose(*(void * *) ((char*)src + 40), 131);&#125;__Block_byref_obj_0 obj = &#123;    0,    &amp;obj,    0x2000000,    sizeof(__Block_byref_obj_0),    __Block_byref_id_object_copy_131,    __Block_byref_id_object_dispose_131,    [[NSObject alloc] init]&#125;;</code></pre><p>由此看出，__block变量虽然是个结构体，但实际上也是一个objc对象，并有持有和释放方法，其中使用_Block_object_assign持有__block对象，使用_Block_object_dispose释放__block对象。__block对象可以为__strong、__weak和__unsafe_unretained，不过使用__unsafe_unretained时注意出现野指针访问无效对象的情况，而__autoreleasing与__block编译时不通过。</p><h3 id="copy-release"><a href="#copy-release" class="headerlink" title="copy/release"></a>copy/release</h3><p>由于block时C语言的扩展，所以在C语言中也可以使用block语法。此时，使用Block_copy和Block_release代替objc的copy和release方法即可。另外，ARC无效时，__block修饰符被用来避免block中的循环引用。因为block从栈copy到堆时，__block成员变量如果是对象类型，则block不会retain它，反之则retain它。这样来避免block的循环引用。由于ARC和MRC时，__block修饰符的用途有很大区别，因为在开发时，必须要知道编译环境是ARC还是MRC，这一点需要特别注意。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Objc高级编程之ARC-读书笔记</title>
    <link href="/2015/12/06/2015-12-06-Objc%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8BARC-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2015/12/06/2015-12-06-Objc%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8BARC-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="内存管理原则"><a href="#内存管理原则" class="headerlink" title="内存管理原则"></a>内存管理原则</h3><p>MRC和ARC都使用引用计数方式来对内存进行管理，简单地说就是下面几条原则：</p><ul><li>自己生成的对象，自己所持有。</li><li>非自己生成的对象，自己也能持有。</li><li>自己不再需要持有对象时需要释放。</li><li>非自己持有的对象无法释放。</li></ul><p>以上对对象的操作与Objc方法的映射关系为：</p><ul><li>生成并持有对象 ＝ alloc/new/copy/mutableCopy等</li><li>持有对象 ＝ retain</li><li>释放对象 ＝ release</li><li>销毁对象 ＝ dealloc</li></ul><p>实际上以上这些方法并不是语言本身，而是Cocoa/CocoaTouch Framework的Foundation里面的NSObject的方法。Apple建议所有的Objc对象都继承自NSObject，这样可以依赖已有的稳定安全内存管理不用自己操心。</p><p>GNUstep是一个盒Cocoa Framework兼容的实现，虽然不能期望它是完全和Apple一样实现的，但是它有相同的表现所以实现上也应该很相似。</p><p><img src="http://ww3.sinaimg.cn/mw690/9460be12gw1eyxxjmtzfhj21x41b4duo.jpg"></p><p>理解了GNUstep的源代码可以帮助我们猜测Apple的Cocoa是如何实现的。以下是<strong>GNUstep</strong>的实现：</p><pre><code>struct obj_layout &#123;    NSUInteger retained;&#125;;+ (id)alloc &#123;    return [self allocWithZone:NSDefaultMallocZone()];&#125;+ (id)allocWithZone:(NSZone *)z &#123;    return NSAllocateObject(self, 0, z);&#125;inline id NSAllocateObject(Class aClass, NSUInteger extraBytes, NSZone *zone) &#123;    int size = baseBytes + extraBytes    id new = NSZoneMalloc(zone, size);    memset(new, 0, size);    new = (id)&amp;((struct obj_layout *)new)[1];&#125;</code></pre><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1eyxxk6u6tlj218q0mwn0q.jpg"></p><pre><code>- (NSUInteger)retainCout &#123;    return NSExtraRefCount(self) + 1;&#125;inline NSUInteger NSExtraRefCount(id anObject) &#123;    return ((struct obj_layout *)anObject)[-1].retained;&#125;</code></pre><p><img src="http://ww1.sinaimg.cn/mw690/9460be12gw1eyxxkkgy1rj215e0oswih.jpg"></p><pre><code>- (id)retain &#123;    NSIncrementExtraRefCount(self);    return self;&#125;inline void NSIncrementExtraRefCount(id anObject) &#123;    if (((struct obj_layout *)anObject)[-1].retained == UINT_MAX - 1) &#123;        NSString *format = @&quot;NSIncrementExtraRefCount() asked to increment too far&quot;;        [NSException raise:NSInternalInconsistencyException format:format];    &#125;    ((struct obj_layout *)anObject)[-1].retained++;&#125;- (void)release &#123;    if (NSDecrementExtraRefCountWasZero(eslf)) &#123;        []self dealloc];    &#125;&#125;inline BOOL NSDecrementExtraRefCountWasZero(id anObject) &#123;    if (((struct obj_layout *)anObject)[-1].retained == 0) &#123;        return YES;    &#125; else &#123;        ((struct obj_layout *)anObject)[-1].retained--;        return NO;    &#125;&#125;- (void)dealloc &#123;    NSDeallocateObject(self);&#125;inline void NSDeallocateObject(id anObject) &#123;    struct obj_layout *o = &amp;((struct obj_layout *)anObject)[-1];    free(o);&#125;</code></pre><p>可以看出每个Objc对象，在其内存布局前都有一个NSUInteger类型变量，用来表示引用计数。alloc/new/copy/mutableCopy/retain都会增加计数，release会减少计数，当计数减至为0时调用dealloc从内存中销毁该对象。</p><p>研究<strong>Apple</strong>的实现之前因为NSObject的源代码没有公开，通过使用Xcode的调试器(lldb)来研究其实现。在NSObject类的alloc里设置端点，可以发现栈中的调用顺序为：</p><pre><code>+alloc+allocWithZone:    class_createInstancecalloc</code></pre><p>大体上Apple和GNUstep的实现没有什么差别。同样的方法能够得到retainCount和retain还有release的调用顺序。</p><pre><code>-retainCount__CFDoExternRefOperationCFBasicHashGetCountOfKey-retain__CFDoExternRefOperationCFBasicHashAddValue-release__CFDoExternRefOperationCFBaseHashRemoveValue</code></pre><p>在Core Foundation Framework中找到__CFDoExternRefOperation：</p><pre><code>int __CFDoExternRefOperation(uintptr_t op, id obj) &#123;    CFBasicHashRef table = get hashtable from obj;    int count;    switch (op) &#123;        case OPERATION_retainCount:            count = CFBasicHashGetCountOfKey(table, obj);            return count;        case OPERATION_retain:            CFBasicHashAddValue(table, obj);            return obj;        case OPERATION_release:            count = CFBasicHashRemoveValue(table, obj);            return 0 == count;    &#125;&#125;</code></pre><p>由此可以猜测，retainCount和retain还有release的实现大致是这样：</p><pre><code>- (NSUInteger)retainCount &#123;    return (NSUInteger)__CFDoExternRefOperation(OPERATION_retainCount, self);&#125;- (id)retain &#123;    return (id)__CFDoExternRefOperation(OPERATION_retain, self);&#125;- (void)release &#123;    return __CFDoExternRefOperation(OPERATION_release, self);&#125;</code></pre><p>同时也可以猜测，Apple的实现大概是采用Hash散列表(引用计数表)完成的：</p><p><img src="http://ww3.sinaimg.cn/mw690/9460be12gw1eyxxktjifvj21140twaeo.jpg"></p><p>GNUstep将引用计数保存在对象内存块头部的变量中，Apple将引用计数保存在一张散列表中。GNUstep的实现看起来简单又高效，但Apple这样实现也必然有它的好处。GNUstep的好处是：少量代码就能实现；引用计数内存和对象内存能统一管理。Apple的好处是：为对象分配内存时无需考虑引用计数，不用担心对象内存块头部问题；散列表用对象内存地址作为Key，这样能追溯各个对象内存块位置，在调试时非常有用。即使出现错误导致对象内存块损坏，只要散列表没问题，就能找到正确的内存块位置。</p><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1eyxxl5ffx8j21fw0oodm4.jpg"></p><p>另外利用Instrument检查内存泄漏时，散列表的记录也有助于帮助检测各对象持有者是否存在。</p><hr><h3 id="GNUstep实现的Autorelease"><a href="#GNUstep实现的Autorelease" class="headerlink" title="GNUstep实现的Autorelease"></a>GNUstep实现的Autorelease</h3><pre><code>- (id)autorelease &#123;    [NSAutoreleasePool addObject:self];&#125;</code></pre><p>实际上，GNUstep应用了IMP缓存技术，缓存了不变的Class，SEL，IMP使得运行效率能满足频繁调用的autorelease</p><pre><code>id autorelease_class = [NSAutoreleasePool class];SEL autorelease_sel = @selector(addObject:);IMP autorelease_imp = [autorelease_class methodForSelector: autorelease_sel];- (id)autorelease &#123;    (*autorelease_imp)(autorelease_class, autorelease_sel, self);&#125;</code></pre><p>NSAutoreleasePool：</p><pre><code>+ (void)addObject:(id)anObj &#123;    NSAutoreleasePool *pool = //获取当前的autoreleasePool;    if (pool != nil) &#123;        [pool addObject:anObj];    &#125; else &#123;        NSLog(@&quot;autorelease is called without active NSAutoreleasePool.&quot;);    &#125;&#125;- (void)drain &#123;    [self dealloc];&#125;- (void)dealloc &#123;    [self emptyPool];&#125;- (void)emptyPool &#123;    for (id obj in array) &#123;        [obj release];    &#125;&#125;</code></pre><h3 id="Apple实现的Autorelease"><a href="#Apple实现的Autorelease" class="headerlink" title="Apple实现的Autorelease"></a>Apple实现的Autorelease</h3><pre><code>class AutoreleasePoolPage &#123;    static inline void *push() &#123;        //生成或持有NSAutoreleasePool对象    &#125;    static inline void pop(void *token) &#123;        //废弃NSAutoreleasePool对象        releaseAll();    &#125;    static inline id autorelease(id obj) &#123;        //相当于NSAutoreleasePool的类方法addObject        AutoreleasePoolPage *autoreleasePoolPage = //获取当前的autoreleasePool;        autoreleasePoolPage-&gt;add(obj);    &#125;    id *add(id obj) &#123;        //添加对象到内部数组    &#125;    void releaseAll() &#123;        //对内部数组里的每一个对象调用release方法    &#125;&#125;;void *objc_autoreleasePoolPush(void) &#123;    return AutoreleasePoolPage::push();&#125;void objc_autoreleasePoolPop(void *ctxt) &#123;    AutoreleasePoolPage::pop(ctxt);&#125;id objc_autorelease(id obj) &#123;    return AutoreleasePoolPage::autorelease(obj);&#125;</code></pre><p>使用<strong>extern void _objc_autoreleasePoolPrint()<strong>私有方法可以查看AutoreleasePool的状态。如果对AutoreleasePool对象进行autorelease的话，会产生</strong>NSInvalidArgumentException</strong>的异常。</p><hr><h3 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h3><p>ARC有效时，objc的对象类型必须附加所有权修饰符，一共有4种：</p><p><strong>__strong</strong>表示对修饰的对象的“强引用”，持有强引用的变量在<strong>超出其作用域时失效</strong>，其引用的对象会被释放。默认情况下，缺省所有权声明的对象类型变量，都隐式声明为__strong类型。通过遵循内存管理原则的__strong修饰符，不必再依赖retain或release，也能正确管理内存。</p><p><strong>__weak</strong>的设计主要是解决循环引用的问题。__weak修饰符与__strong相反，仅仅引用但不持有。同时__weak的另一个优点是，其所引用的对象如果被销毁，该变量将被<strong>自动安全地设置为nil</strong>，再也不会出现指向已经释放的对象内存块的野指针了。</p><p><strong>__unsafe_unretained</strong>正如其名unsafe所示，是<strong>不安全</strong>的所有权修饰符。其基本与__weak表现一致，除了在引用对象销毁时不被自动设置为nil。</p><p><strong>__autoreleasing</strong>修饰符的变量被某对象赋值时，就代表该对象在MRC时调用了autorelease的方法，即对象被注册到了AutoreleasePool里。同时，使用@autoreleasepool{}块代替NSAutoreleasePool的方法调用。</p><h3 id="隐式使用-autoreleasing"><a href="#隐式使用-autoreleasing" class="headerlink" title="隐式使用__autoreleasing"></a>隐式使用__autoreleasing</h3><p><img src="http://ww1.sinaimg.cn/mw690/9460be12gw1eyxxm9s493j21aq0pwq7y.jpg"></p><p>获取并持有非自己生成的对象时，该对象已经被注册到了autoreleasepool。这是由于编译器会检查方法名是否以alloc/new/copy/mutableCopy开头，如果不是则自动将方法返回的对象注册到autoreleasepool(当然init方法不会)。这些方法里，return使得对象变量超出其作用域，__strong类型变量会释放其持有的对象，所以编译器会使用__autorelease修饰符将对象注册到autoreleasePool延迟释放。</p><pre><code>+ (id)array &#123;    return [[NSArray alloc] init];&#125;等价于+ (id)arrya &#123;    __autoreleasing obj = [[NSArray alloc] init];    return obj;&#125;</code></pre><p>使用__weak类变量时，因为该变量只有引用并不持有，而在访问该变量的过程中有被销毁的可能性。如果把指向的对象注册到autoreleasePool中，那么在@autoreleasePool{}结束前都能保证期间对象存在。</p><pre><code>id _weak obj = XXX;NSLog(@&quot;Class = %@&quot;, [obj class]);等价于id _weak obj = XXX;id __autoreleasing tmp = obj;NSLog(@&quot;Class = %@&quot;, [tmp class]);</code></pre><p>默认情况下，缺省所有权声明对象的指针变量，都隐式声明为__autoreleasing。因为编译器将alloc/new/copy/mutableCopy开头的方法产生的新对象看作自己生成并持有，其他情况下产生的新对象都应该看作非自己生成并持有。虽然strong类型变量也能够传递，但还是应该统一遵循内存管理原则。同时，<strong>对象指针的赋值操作时所有权修饰符必须一致</strong>否则编译不通过。</p><pre><code>- (BOOL)doSomething:(NSError *)error &#123;    //发生错误    *error = [[NSError alloc] init];    return NO;&#125;NSError *error = nil;BOOL result = [self doSomething:&amp;error];等价于- (BOOL)doSomething:(__autoreleasing NSError *)error &#123;    //发生错误    *error = [[NSError alloc] init];    return NO;&#125;__autoreleasing NSError *error = nil;BOOL result = [self doSomething:&amp;error];</code></pre><p>另外，在显示地指定__autoreleasing修饰符时，必须注意修饰的对象要为<strong>自动变量</strong>(包括局部变量、方法参数)。</p><h3 id="ARC使用规则"><a href="#ARC使用规则" class="headerlink" title="ARC使用规则"></a>ARC使用规则</h3><p>在ARC有效时必须要遵循以下规则：</p><ul><li>不能使用retain/release/retainCount/autorelease</li><li>不能使用NSAllocateObject/NSDeallocateObject(分别实现了影响内存管理的alloc和dealloc)</li><li>方法命名需遵循内存管理原则</li><li>不再显示调用dealloc(遵循无法显示影响内存管理)</li><li>使用@autoreleasepool{}代替NSAutoreleasePool</li><li>不能使用NSZone</li><li>objc对象类型变量不能作为C语言结构体(struct/union)的成员(没有方法管理C语言结构体成员的生命周期)</li><li>id和void*之间转换需要显示指明所有权变化(C语言类型变量超出ARC对objc对象类型变量的管理范围，需手动指明所有权变化)</li></ul><p><strong>__bridge</strong>对象所有权不变，编译器继续自动管理；</p><p><strong>__bridge_retained</strong>或<strong>CFBridgingRetain</strong>移交对象所有权从编译器到开发者，至此开发者需手动管理；</p><p><strong>__bridge_transfer</strong>或<strong>CFBridgingRelease</strong>移交对象所有权从开发者到编译器，至此编译器能自动管理</p><hr><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>Apple称ARC是“右边一起进行内存管理”的，但实际上只有编译器是无法完全胜任的，在此基础上还需要Runtime的支持。也就是说，ARC是由Clang(LLVM编译器)3.0＋和Objc Runtime493.9＋实现的。编译器选项“-S”运行clang，可以取得程序汇编输出。通过阅读汇编和objc4库源代码，可以模拟ARC是如何实现的。</p><h5 id="strong修饰符"><a href="#strong修饰符" class="headerlink" title="__strong修饰符"></a>__strong修饰符</h5><pre><code>&#123;    id __strong obj = [[NSObject alloc] init];&#125;//编译器模拟代码&#123;    id obj = objc_msgSend(NSObject, @selector(alloc));    objc_msgSend(obj, @selector(init));    objc_release(obj);&#125;</code></pre><p>由此可知，对于自己生成并持有的对象，编译器自动地在作用域结束前插入release。</p><pre><code>+ (id)array&#123;    return [[NSMutableArray alloc] init];&#125;&#123;    id __strong obj = [NSMutableArray array];&#125;//模拟器代码+ (id)array&#123;    id obj = objc_msgSend(NSMutableArray, @selector(alloc));    objc_msgSend(obj, @selector(init));    return objc_autoreleaseReturnValue(obj);&#125;&#123;    id obc = objc_msgSend(NSMutableArray, @selector(array));    objc_retainAutoreleasedReturnValue(obj);    objc_release(obj);&#125;</code></pre><p>由此可知，对于非标准对象生成方法里，编译器自动地在作用域结束前插入<strong>objc_autoreleaseReturnValue</strong>方法(该方法将生成的对象autorelease－即注册到autorelresepool)。而对于非自己生成能持有的对象，和之前一样编译器自动地在作用域结束前插入release，同时在获取对象后，会插入<strong>objc_retainAutoreleasedReturnValue</strong>方法(该方法将持有返回得到的autoreleased对象)。</p><p>不过，objc_autoreleaseReturnValue和objc_autorelase不同的是，前者是要用于最优化程序。objc_retainAutoreleasedReturnValue会检查调用方的执行命令列表(参见<a href="http://hllovesgithub.github.io/2015/11/15/2015-11-15[Autorelease]/">Autorelease</a>)，如果发现调用房在调用非标准对象生成方法(例如+array)后紧结着调用了objc_retainAutoreleasedReturnValue的话，那么就<strong>不</strong>将生成的对象autorelease－即注册到autorelresepool，而是直接返回。同理，且objc_retainAutoreleasedReturnValue和objc_retain不同的是，如果之前调用过objc_autoreleaseReturnValue，那么就<strong>不</strong>将返回的对象retain，而是直接使用。这两个方法共同协作，可以将生成的对象不注册到autoreleasepool中直接使用，省去了2次objc的msgSend方法，达到最优化。同时，也解决了非标准方法在ARC和MRC模块之间传递对象的问题。</p><p><img src="http://ww1.sinaimg.cn/mw690/9460be12gw1eyxxmjmwutj21v418atl5.jpg"></p><h5 id="weak修饰符"><a href="#weak修饰符" class="headerlink" title="__weak修饰符"></a>__weak修饰符</h5><pre><code>&#123;    id __weak obj = another;&#125;//编译器模拟代码&#123;    id obj = 0;    objc_initWeak(&amp;obj, another);    objc_destroyWeak(&amp;obj);&#125;//等价于&#123;    id obj = 0;    objc_storeWeak(&amp;obj, another);    objc_storeWeak(&amp;obj, 0);&#125;</code></pre><p>objc_storeWeak方法将__weak修饰符变量的地址(即第1个参数)作为Value，将被引用的对象(即第2个参数)作为Key，注册到runtime维护的weak关系映射表(Hash散列表)中，当Key为0时，将Value从对应的weak关系映射表中删除。使用weak表，将销毁的对象进行检索，就能快速地获得weak引用它的所有变量的地址。对象的销毁过程：</p><ul><li>objc_release</li><li>当引用计数为0时而执行dealloc</li><li>_objc_rootDealloc</li><li>object_dispose</li><li>objc_destructInstance</li><li>objc_clear_deallocating</li></ul><p>最后调用objc_clear_deallocating时，首先从weak表中获取销毁对象为Key的所有Value(即所有weak变量的地址)，然后通过指针将weak变量的值设为nil，再在weak表中删除销毁对象对应记录，最后把销毁对象也从计数表中删除对应记录。由此可知，如果有大量__weak修饰符变量，则会在引用的对象被销毁时大量被设置为nil消耗CPU，所以应该尽可能在需要的地方使用__weak。</p><p>使用__weak修饰符变量即是使用autoreleased对象：</p><pre><code>&#123;    id __weak obj = another;    NSLog(@&quot;%@&quot;, obj);&#125;//编译器模拟代码&#123;    id obj = 0;    objc_initWeak(&amp;obj, another);    id tmp = objc_loadWeakRetained(&amp;ojc);    objc_autorelease(tmp);    NSLog(@&quot;%@&quot;, tmp);    objc_destroyWeak(&amp;obj);&#125;</code></pre><p><strong>objc_loadWeakRetained</strong>取出__weak修饰符变量引用的对象并持有，objc_autorelease将获取的对象注册到autoreleasepool中延迟释放。所以，__weak引用的对象在@autoreleasepool{}期间都是有效的可以放心使用。但是，如果大量地使用__weak变量，会产生大量的autoreleased对象，因为在使用__weak变量时最好暂时赋值给一个__strong变量再使用__strong。</p><pre><code>&#123;    id __weak objc = another;    NSLog(@&quot;1 %@&quot;, obj);    NSLog(@&quot;2 %@&quot;, obj);    NSLog(@&quot;3 %@&quot;, obj);&#125;//等价于&#123;    id _weak objc = another;    id tmp1 = objc_loadWeakRetained(&amp;ojc);    objc_autorelease(tmp1);    NSLog(@&quot;1 %@&quot;, tmp1);    id tmp2 = objc_loadWeakRetained(&amp;ojc);    objc_autorelease(tmp2);    NSLog(@&quot;2 %@&quot;, tmp2);    id tmp3 = objc_loadWeakRetained(&amp;ojc);    objc_autorelease(tmp3);    NSLog(@&quot;3 %@&quot;, tmp3);&#125;//使用__strong&#123;    id __weak objc = another;    id __strong tmp = objc;    NSLog(@&quot;1 %@&quot;, tmp);    NSLog(@&quot;2 %@&quot;, tmp);    NSLog(@&quot;3 %@&quot;, tmp);&#125;//等价于&#123;    id _weak objc = another;    id tmp = objc_loadWeakRetained(&amp;ojc);    NSLog(@&quot;1 %@&quot;, tmp);    NSLog(@&quot;2 %@&quot;, tmp);    NSLog(@&quot;3 %@&quot;, tmp);    objc_release(tmp);&#125;</code></pre><h5 id="autoreleasing修饰符"><a href="#autoreleasing修饰符" class="headerlink" title="__autoreleasing修饰符"></a>__autoreleasing修饰符</h5><pre><code>@autoreleasepool &#123;    id __autoreleasing obj = [[NSObject alloc] init];&#125;@autoreleasepool &#123;    id __autoreleasing obj = [NSMutableArray array];&#125;//等价于id pool = objc_autoreleasePoolPush();id obj = objc_msgSend(NSObject, @selector(alloc));objc_msgSend(obj, @selector(init));objc_autorelease(obj);objc_autoreleasePoolPop(pool);id pool = objc_autoreleasePoolPush();id obj = objc_msgSend(NSMutableArray, @selector(array));objc_retainAutoreleasedReturnValue(obj);objc_autorelease(obj);objc_autoreleasePoolPop(pool);</code></pre><hr><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>ARC虽然不能使用retainCount查看引用计数，但能参考**extern uintptr_t _objc_rootRetainCount(id obj)**私有方法查看。不过也不能够完全信任该方法。对于已经销毁的对象已经地址不正确的对象，有时候也返回“1”。另外，在多线程环境中使用时，因为存在静态条件的问题，所以取得的数值不一定完全可信。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Test</title>
    <link href="/2015/12/06/2015-11-29-Test/"/>
    <url>/2015/12/06/2015-11-29-Test/</url>
    
    <content type="html"><![CDATA[<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单元是应用的最小可测试部件。单元测试(又称为模块测试，Unit Testing)是针对程序模块(软件设计的最小单位)来进行正确性检验的测试工作。如果代码之间的耦合度很小，那么可以将其分解成多个小单元，从而更易于测试。TDD(Test-Driven Development测试驱动开发)要求开发者在编写功能前先将其测试代码写好，然后边编写实现代码边进行测试，从而保证实现尽早发现并修改问题，因此整个项目将由测试来驱动，有助于开发出高质量的代码。</p><h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><p>黑盒测试是一种测试方法，盒子是指被测试的软件，黑是指盒子是不可视，测试者不清楚也不关心盒子内部的构造以及运作。白盒测试又称功能测试，它是以用户的角度，对外部进行测试，只检查功能是否能够按照需求正常使用。</p><h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><p>白盒测试是一种测试方法，盒子是指被测试的软件，白是指盒子是可视的，测试者清楚盒子内部是如何构造以及如何运作。白盒测试又称结构测试，它是以实现者的角度，对内部进行测试，需检查功能是否能够按照需求正常实现。</p><h3 id="懵懂认知"><a href="#懵懂认知" class="headerlink" title="懵懂认知"></a>懵懂认知</h3><p>刚工作时，我以为测试只是测试干的事，开发只要做完自己的工作，交给测试去测就行。后来发现，从前面定义来看，测试干的是黑盒测试。对于开发而言，为什么要进行白盒测试呢？</p><ul><li>黑盒测试测出的问题归根结底还是开发实现的问题。测试的确不清楚功能是如何实现的，也不想知道。白盒测试也只能由清楚实现的细节开发来完成，可以针对具体的功能实现进行细致全面地测试。</li><li>黑盒测试一般由人工操作，会因为人的习惯、偏好、心情、态度而存在耗时耗力、范围局限、路径随意、深浅不均等等问题。而白盒测试一般都有工具辅助，只要了解细节的开发编写好全面的测试用例，就可以快速全面专注平均地测试。</li><li>一般项目需要进行到一定程度，能够出现可测试的样品时，才可以进行黑盒测试。也就是说，问题的暴露从开发阶段推迟到测试阶段才被发现。而白盒测试可以脱离软件整体真对单独模块(比如framework、library、class、methods)在开发阶段就提前进行。</li><li>黑盒测试需要有软件样品，对于每一次修改了测出的问题后，构建生成新的软件样品再进行黑盒测试不太现实。而脱离软件整体的白盒测试可以独立地对问题所涉及到的地方修改后进行多次快速地测试。</li><li>接口设计好后，即接口功能、接口名称、参数个数、参数类型、返回类型都明确稳定后，白盒测试就可以开始编写测试用例并测试。这有助于实现在早期就能发现问题，为软件提供稳定健壮的组件。甚至对于实现的内部有任何改变，只要有一套完整的白盒测试用例，都可以快速检查是否修复旧问题是否产生新问题。</li></ul><p>所以，无论是自身充满好奇心，还是对自己严格要求，即使是测试，都会有助于培养良好习惯和提高编码水平。</p><h3 id="Xcode测试"><a href="#Xcode测试" class="headerlink" title="Xcode测试"></a>Xcode测试</h3><p>由于Xcode5以后内嵌了XCTest(兼容iOS7+和OS X10.8+)这个测试框架，可以很方便地进行测试，且能满足一般测试需求，所以OCUnit和SenTest我目前就不再深入研究。</p><p>Xcode里，目标(Target)通过构建(Build)生成产品(Production)。测试目标构建后会生成测试包。如果测试过程需要使用不同类型的数据(文件图片音频视频等)，可以把它们添加到测试包中，并在测试方法里使用[NSBundle bundleForClass:测试类]，在运行时获取正确的测试包，便可以取得正确的数据。</p><p>快捷键Command+U是起动当前Scheme配置的测试包的测试任务。Scheme(方案)控制着构建(Build)、运行(Run)、测试(Test)、调试(Profile)、分析(Analyse)和归档(Archive)这些命令的行为。其中，可以通过添加或删除、启用或关闭，来控制测试范围。可以在测试导航栏找到所有的测试包、测试类、测试方法，可以分不同抽象级别进行测试。也可以在源文件测试整个类或者某个方法。</p><h3 id="XCTestCase"><a href="#XCTestCase" class="headerlink" title="XCTestCase"></a>XCTestCase</h3><p>每一个创建的测试类都是基于XCTestCase的子类型。对于每个测试类，测试方法都是以test开头、没有参数、返回void、用于测试不同目的的实例方法。对于每个测试方法，其通用代码(比如打开关闭文件或者网络)可以写在setUp(测试开始前)和tearDown(测试结束后)里面。执行测试时，一个测试类会创建对应测试方法数量的该类实例，每个实例在setup后执行一个对应的测试方法接着tearDown。这样连续重复执行所有的测试方法，测完一个类，接着下个类。一直重复直到测完所有测试类的所有测试方法。</p><h3 id="XCTest断言"><a href="#XCTest断言" class="headerlink" title="XCTest断言"></a>XCTest断言</h3><p>测试方法中，对测试的表达式进行预期判断。只有不符合预期判断的表达式才算是测试失败。XCTest提供了很多内建的预判断言。</p><p><strong>无条件报错</strong></p><ul><li>XCTFail</li></ul><p><strong>等价测试</strong></p><ul><li>XCTAssertEqualObjects</li><li>XCTAssertNotEqualObjects</li><li>XCTAssertEqual</li><li>XCTAssertNotEqual</li><li>XCTAssertEqualWithAccuracy</li><li>XCTAssertNotEqualWithAccuracy</li></ul><p><strong>nil测试</strong></p><ul><li>XCTAssertNil</li><li>XCTAssertNotNil</li></ul><p><strong>布尔测试</strong></p><ul><li>XCTAssertTrue</li><li>XCTAssert(与XCTAssertTrue同义)</li><li>XCTAssertFalse</li></ul><p><strong>异常测试</strong></p><ul><li>XCTAssertThrows</li><li>XCTAssertThrowsSpecific</li><li>XCTAssertThrowsSpecificNamed</li><li>XCTAssertNoThrow</li><li>XCTAssertNoThrowSpecific</li><li>XCTAssertNoThrowSpecificNamed(对AppKit和Foundation非常有用)</li></ul><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><p>在断点导航栏中，通过Add Test Failure Breakpoint添加一个测试失败断点。当测试方法失败触发了失败端点时，这个断点会终止测试的执行，并停止在测试代码发生错误点，这可以快速找到问题发生的位置。测试时异常断点捕获异常也会终止测试执行，所以测试运行时通常会关闭异常断点以避免不适当的定位。当然，寻找一个特定问题并想终止测试来修复它时，也可以打开异常断点恢复捕获。</p><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>在Xcode6以后，Apple提供了内建的measureBlock以确定一个性能基准。可以使用它们，方便地在测试用例中确认重要的算法以及随着时间的推移程序保持高性能。</p><pre><code>- (void)testPerformanceExample &#123;    // This is an example of a performance test case.    [self measureBlock:^&#123;        // Put the code you want to measure the time of here.    &#125;];&#125;</code></pre><h3 id="异步测试"><a href="#异步测试" class="headerlink" title="异步测试"></a>异步测试</h3><p>之前在介绍GCD的时候，曾经提到过可以使用GCD实现异步测试：</p><pre><code>- (void)testAsyncWithGroup &#123;    dispatch_group_t group = dispatch_group_create();    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;        sleep(1);    &#125;);    XCTAssertEqual(0,         dispatch_group_wait(group,         dispatch_time(DISPATCH_TIME_NOW, 2         * NSEC_PER_SEC)));&#125;- (void)testAsyncWithSemaphore &#123;    dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;        if (!dispatch_semaphore_wait(semaphore, DISPATCH_TIME_NOW)) &#123;            sleep(1);            dispatch_semaphore_signal(semaphore);        &#125;    &#125;);    long value = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC));    if (!value) &#123;        dispatch_semaphore_signal(semaphore);    &#125;    XCTAssertEqual(0, value);&#125;</code></pre><p>在Xcode6以后，Apple提供了内建的XCTestExpectation(期望)以支持异步测试。首先使用expectationWithDescription:创建一个期望；然后在调用异步方法后使用waitForExpectationsWithTimeout，指定一个超时回调函数，如果在规定的时间内期望没有得到实现便会执行回调函数；最后在异步方法里使用fulfill完成实现。注意，如果一个测试用例里有多个期望，只有所有的期望都实现了才算等待成功。</p><pre><code>- (void)testDocumentOpening &#123;    XCTestExpectation *documentOpenExpectation = [self expectationWithDescription:@&quot;document open&quot;];    NSURL *URL = [[NSBundle bundleForClass:[self class]] URLForResource:@&quot;TestDocument&quot; withExtension:@&quot;mydoc&quot;];    UIDocument *doc = [[UIDocument alloc] initWithFileURL:URL];    [doc openWithCompletionHandler:^(BOOL success) &#123;        XCTAssert(success);        [documentOpenExpectation fulfill];    &#125;];    [self waitForExpectationsWithTimeout:1 handler:^(NSError *error) &#123;        [doc closeWithCompletionHandler:nil];    &#125;];&#125;</code></pre><h3 id="编码指南"><a href="#编码指南" class="headerlink" title="编码指南"></a>编码指南</h3><p>通过测试达到的稳定水平取决于编写测试的质量，而编写测试的难易程度也取决于编码方式。为测试设计的编码方式有助于减小编写难度，写出良好测试。</p><ul><li><strong>定义API：</strong>每个API是为了满足对应的需求而设计的。越早定义好API形成明确稳定的标准，就越好写测试代码，即使没有实现API。只要API的定义不变，实现有了变动也可以使用相同的测试代码进行测试。API的定义包括功能描述、输入范围、输出范围，异常抛出，使用条件和返回类型。</li><li><strong>边写边测：</strong>每当设计和编写一个方法时，就可以编写对应的测试用例来确保API的正确性。因为此时是对该API最熟悉的时段，随着时间的流逝，回过头来重新为很久前写过的实现编写测试用例，会有理解偏差的风险和重新学习的成本。</li><li><strong>测试边界：</strong>对超越方法输入范围外的输入值进行测试。</li><li><strong>测试出错：</strong>对能使方法出错的条件进行测试，确保方法正面响应错误，比如抛出异常或返回错误代码。</li><li><strong>测试全面：</strong>尽量编写全面复杂的测试代码(比如多线程环境)，测试实现在各个方面的表现，发现潜在问题。</li><li><strong>测试Bug：</strong>每当修复完一个Bug，都需要重复对应的测试，来验证此次修复的有效性。</li></ul><h3 id="命令行测试"><a href="#命令行测试" class="headerlink" title="命令行测试"></a>命令行测试</h3><p>命令行工具xcodebuild的test可以进行测试，参数-destination指定不同的测试目的。</p><p>在64位OSX测试：xcodebuild test -project MyAppProject.xcodeproj -scheme MyApp -destination ‘platform=OS X,arch=x86_64’</p><p>在一个iPod测试：xcodebuild test -project MyAppProject.xcodeproj -scheme MyApp -destination ‘platform=iOS,name=iPod Name’</p><p>在iOS模拟器测试：xcodebuild test -project MyAppProject.xcodeproj -scheme MyApp -destination ‘platform=iOS Simulator,name=iPhone,0S=7.0’</p><p>-destination参数可以被连接在一起，这样就可以多个目标共享同一个方案(scheme)：xcodebuild test -project MyAppProject.xcodeproj -scheme MyApp</p><p>-destination ‘platform=OS X,arch=x86_64’</p><p>-destination ‘platform=iOS,name=iPod Name’</p><p>-destination ‘platform=iOS Simulator,name=iPhone,0S=7.0’</p><p>如果测试失败，xcodebuild将返回一个非零的退出代码。</p><hr><p>延伸阅读</p><p><a href="https://developer.apple.com/library/prerelease/ios/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/01-introduction.html">Testing with Xcode</a></p><p><a href="http://www.cocoachina.com/ios/20140805/9314.html">Xcode 6单元测试</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NSNotification</title>
    <link href="/2015/11/21/2015-11-21-NSNotification/"/>
    <url>/2015/11/21/2015-11-21-NSNotification/</url>
    
    <content type="html"><![CDATA[<p>NSNotificationCenter是Cocoa上实现观察者模式的中间桥梁，NSNotification抽象了观察者和被观察者之间的通信。因为观察者和被观察者没有类型限制的广播性，所以一般作为程序中用来解耦模块之间纵深通信的方法(MVC中主要用作M向C通信)。NSNotificationCenter是线程安全的，意味着可以在多线程中不用担心同步问题而轻松访问和使用，例如注册观察者，移除观察者，发送与执行等。</p><h3 id="添加观察者"><a href="#添加观察者" class="headerlink" title="添加观察者"></a>添加观察者</h3><pre><code>// A- (void)addObserver:(id)notificationObserver           selector:(SEL)notificationSelector               name:(NSString *)notificationName             object:(id)notificationSender// B- (id&lt;NSObject&gt;)addObserverForName:(NSString *)name                            object:(id)obj                             queue:(NSOperationQueue *)queue                        usingBlock:(void (^)(NSNotification *note))block                        </code></pre><p>A是传统的方法，B是支持block之后的方法。需要注意的是，NSNotificationCenter<strong>不会retain</strong>方法A的观察者notificationObserver(目前看来也不是weak，我个人认为是为了更本质地暴露问题，而是unsafe_unretained类型的引用)，<strong>但会retain</strong>方法B的返回值id<NSObject>，都将作为记录观察者和被观察者之间映射关系。而且每次添加都会重新注册一次，即使同一对象监听同一消息，而不是去覆盖原来的监听。</p><p>在涉及到block的方法B中，需要注意到不要产生循环引用的内存问题。因为block参数为返回的观察对象(__NSObserver类型)拥有，如果观察对象是成员变量而block中又引用了类本身，就构成了循环引用。</p><h3 id="移除观察者"><a href="#移除观察者" class="headerlink" title="移除观察者"></a>移除观察者</h3><pre><code>// A- (void)removeObserver:(id)notificationObserver                  name:(NSString *)notificationName                object:(id)notificationSender// B- (void)removeObserver:(id)</code></pre><p>方法A移除了观察者、被观察者和通知名都匹配的映射关系，方法B移除了匹配观察者的所有映射关系。良好的编码习惯，就像allloc和dealloc，open和close，需要添加和移除配对出现。否则，当观察者已经无效而被观察者继续发送通知时，通知中心中还记录者映射关系(此时为野指针)，调用方法A的观察者的处理方法就会crash；方法B虽然不会crash，但是block内部引用的对象永远不会释放。</p><p>方法A适合于在阶段性周期性的方法中调用，以避免不知情的情况下移除了可视范围外其他与对象关联的映射关系，即具体地移除自己控制的映射关系。方法B适合于在终极性一次性的方法中调用，这样可以确保清除与对象关联的映射关系；</p><h3 id="通知与执行"><a href="#通知与执行" class="headerlink" title="通知与执行"></a>通知与执行</h3><pre><code>- (void)postNotification:(NSNotification *)notification- (void)postNotificationName:(NSString *)notificationName                      object:(id)notificationSender- (void)postNotificationName:(NSString *)notificationName                      object:(id)notificationSender                    userInfo:(NSDictionary *)userInfo</code></pre><p>可以根据需要指定通知名(notificationName)、发送者(notificationSender)和额外信息(userInfo)，所有这些信息封装在一个NSNotification中，由postNotification:发送，其中参数notification不能为空，否则会引发异常。添加观察者的方法A和B都会<strong>同步地</strong>通知观察者并等待其执行完毕，只不过A在通知发生当前的线程中，而B则是在注册时指定队列的线程中。</p><p>但是，当有通知发送时，NSNotificationCenter是通过遍历所有的观察者映射关系，来找到每一个需要通知的观察者的。所以一旦注册到NSNotificationCenter的观察者过多，那么整个发送到响应通知的过程的效率就比较低，也不是什么需求都通过通知来解决，还是需要仔细思考适不适合。如果的确适合，也尽可能晚地注册，不再使用时也尽可能早地移除，这样使得内部的映射关系保持在最低量。</p><h3 id="通知重定向"><a href="#通知重定向" class="headerlink" title="通知重定向"></a>通知重定向</h3><p>添加观察者的方法B已经很好地解决了这个问题，如果有需要尽量采用方法B，不过实现的原理还是值得研究一下的。下面的方法针对方法A(有可能方法B就是这么在NSNotificationCenter内部实现的)。Apple的<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Notifications/Articles/Threading.html#//apple_ref/doc/uid/20001289-CEGJFDFG">官方文档</a>这么说的：</p><blockquote><p>For example, if an object running in a background thread is listening for notifications from the user interface, such as a window closing, you would like to receive the notifications in the background thread instead of the main thread. In these cases, you must capture the notifications as they are delivered on the default thread and redirect them to the appropriate thread.</p></blockquote><p>思路是自定义一个缓存需要重定向NSNotification的集合(比如数组)。当通知来了时，先检查发送这个通知的线程是不是期望的线程，如果不是，则将这个通知缓存到集合中，并告诉期望的线程有通知需要处理。期望的线程得知后，从集合中移除通知，并进行处理。</p><pre><code>@interface AppDelegate () &lt;NSMachPortDelegate&gt;@property (nonatomic,readwrite,strong) NSMutableArray *notifications;@property (nonatomic,readwrite,strong) NSThread *notificationThread;@property (nonatomic,readwrite,strong) NSLock *notificationLock;@property (nonatomic,readwrite,strong) NSMachPort *notificationPort;@end@implementation AppDelegate- (void)applicationDidFinishLaunching:(NSNotification *)aNotification &#123;    NSLog(@&quot;current thread = %@&quot;, [NSThread currentThread]);    self.notifications = [[NSMutableArray alloc] init];    self.notificationLock = [[NSLock alloc] init];        self.notificationThread = [NSThread currentThread];    self.notificationPort = [[NSMachPort alloc] init];    self.notificationPort.delegate = self;        [[NSRunLoop currentRunLoop] addPort:self.notificationPort forMode:(__bridge NSString *)kCFRunLoopCommonModes];    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(processNotification:) name:@&quot;TestNotification&quot; object:nil];    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;        [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;TestNotification&quot; object:nil userInfo:nil];    &#125;);&#125;- (void)handleMachMessage:(void *)msg &#123;    [self.notificationLock lock];    while ([self.notifications count]) &#123;        NSNotification *notification = [self.notifications objectAtIndex:0];        [self.notifications removeObjectAtIndex:0];        [self.notificationLock unlock];        [self processNotification:notification];        [self.notificationLock lock];    &#125;;    [self.notificationLock unlock];&#125;- (void)processNotification:(NSNotification *)notification &#123;    if ([NSThread currentThread] != _notificationThread) &#123;        [self.notificationLock lock];        [self.notifications addObject:notification];        [self.notificationLock unlock];        [self.notificationPort sendBeforeDate:[NSDate date] components:nil from:nil reserved:0];    &#125; else &#123;        NSLog(@&quot;current thread = %@&quot;, [NSThread currentThread]);        NSLog(@&quot;process notification&quot;);    &#125;&#125;@end</code></pre><h3 id="多线程安全"><a href="#多线程安全" class="headerlink" title="多线程安全"></a>多线程安全</h3><p>NSNotificationCenter之所以在同一个线程中同步发送和执行通知，应该是Apple出于线程安全的原因，但是并不代表没有线程安全的问题。因为通知的发送和执行没有限制必须在某一个线程(例如主线程)，所以在线程A执行通知的期间，会有线程B释放观察者的可能性。如果观察者的执行方法里访问了观察者自己，那么这种情况下就会因访问野指针而crash：</p><pre><code>@interface Poster : NSObject@end@implementation Poster- (instancetype)init &#123;    self = [super init];    if (self)&#123;        [self performSelectorInBackground:@selector(postNotification) withObject:nil];    &#125;    return self;&#125;- (void)postNotification &#123;    [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;Test&quot; object:nil];&#125;@end@interface Observer : NSObject &#123;    Poster  *_poster;&#125;@property (nonatomic, assign) NSInteger i;@end@implementation Observer- (instancetype)init &#123;    self = [super init];    if (self) &#123;        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:@&quot;Test&quot; object:nil];        _poster = [[Poster alloc] init];    &#125;    return self;&#125;- (void)handleNotification:(NSNotification *)notification &#123;    NSLog(@&quot;handle notification begin&quot;);    sleep(1);    self.i = 10;    NSLog(@&quot;handle notification end&quot;);&#125;- (void)dealloc &#123;    [[NSNotificationCenter defaultCenter] removeObserver:self];    NSLog(@&quot;Observer dealloc&quot;);&#125;@end@implementation AppDelegate- (void)applicationDidFinishLaunching:(NSNotification *)aNotification &#123;    __autoreleasing Observer *observer = [[Observer alloc] init];&#125;@end</code></pre><p>总之一句话，如何才能保证方法所有涉及到的对象，在方法执行期间有效？不过这类问题已经很典型了，在方法开始时确保所有对象的有效性后再执行，ARC下使用strong，MRC下使用retain+autorelease。今天写这篇文章的时候(XCode7.1.1)，我检测了引用文章的例子，惊奇的是已经<strong>没有问题</strong>了。我认为Apple解决了这个问题，应该是在执行通知方法前，内部strong或者retain+autorelease观察者。这能做到通知方法<strong>执行期间</strong>至少不会产生观察者都无效，如果执行前观察者都已经无效就会直接crash。引用文的例子是方法A，我认为方法B本身就不会有问题，因为它是个block对象，内部strong了观察者，而__NSObserver必须通过NSNotificationCenter的removeObserver方法才能移除。</p><hr><h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><ul><li><a href="http://southpeak.github.io/blog/2015/03/20/cocoa-foundation-nsnotificationcenter/">Foundation: NSNotificationCenter</a></li><li><a href="http://southpeak.github.io/blog/2015/03/14/nsnotificationyu-duo-xian-cheng/">Notification与多线程</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Autorelease</title>
    <link href="/2015/11/15/2015-11-15-Autorelease/"/>
    <url>/2015/11/15/2015-11-15-Autorelease/</url>
    
    <content type="html"><![CDATA[<h3 id="它的意义"><a href="#它的意义" class="headerlink" title="它的意义"></a>它的意义</h3><p>对于Apple开发而言，ARC已经没有MRC容易内存出错了。在MRC的年代，一切都需要手动写，而计算机永远不会犯错，犯错的总是人，说不定在某个时刻大脑短路了或者打了一下哈欠，忘记少加了或者无意多加了个retain或者release，或者在业务逻辑交错复杂，或者在代码量显著增加，都有可能出一点小错。虽然MRC的年代已经有Static Analyse的工具，但是也不能确保是万能的。</p><p>我在MRC年代学习Autorelease时，觉得它的意义是方便内存使用：</p><pre><code>- (void)foo &#123;    id objc1 = [[NSObject alloc] init];    // 逻辑1    return;        // 逻辑2    if (flag1) &#123;        id objc2 = [[NSObject alloc] init];        // ...        return;    &#125;        // 逻辑3    while (flag2) &#123;        // ...    &#125;&#125;</code></pre><p>在一个方法中，根据业务逻辑很可能出现多个分支，而有的分支会提前返回(对于方法返回的出口本身就是个值得研究且有争议的话题，我个人认为出口尽量越少越好)。对于MRC而言，如果有多个分支，就要做到在该分支结束返回前，把所有经过该分支上手动生成的内存全部手动释放掉。但是，所有这些因素都会引起方法中内存管理出错：</p><ul><li>业务逻辑波动可能性大导致分支结构不稳定。</li><li>方法可能过长导致追溯检查生成对象很麻烦。</li><li>多个分支出有相同对象释放会引诱代码拷贝。</li></ul><h3 id="良好习惯"><a href="#良好习惯" class="headerlink" title="良好习惯"></a>良好习惯</h3><p>代码也是给人看的，代码是由人写的，养成良好的编码习惯，避免问题远比解决问题更有意义。比如打开关闭文件，好的习惯是open和close一起写，然后再在中间写其他逻辑。成对写好open和close后，大脑就可以放下文件管理的问题，不用在写中间逻辑时提心吊胆地不断提醒自己不要忘记close文件(往往还就真容易忘记)。这个确保了大脑逻辑最简单最清晰的时候，最安全可靠地尽早完成该完成的任务。</p><p>对于Coder，概念越抽象越好，规则越简单越好，牵挂越稀少越好。所以，反观和文件管理一样的内存管理，Autorelease(在机制上是<strong>延迟释放</strong>内存，所以内存管理还是平衡的)就能做到，在你生成对象内存的时候，就提前相应做好释放对象内存，而不用在以后的任何地方再去操心内存释放问题。有了[[[Class alloc] init] autorelease]之后，你想怎么飞就怎么飞，不用管何时返回，不用管分支有多少，不用管业务逻辑怎么变化。</p><p>同样的良好习惯的应用，还有<a href="https://github.com/jspahrsummers/libextobjc">libextobjc</a>中的@onExit功能(用到了GCC编译的功能，设置了方法返回后的调用)，在方法开头就写好返回收尾的工作，确保了安全工作就可以任性地飞，这个库以后再介绍。</p><h3 id="言归正传"><a href="#言归正传" class="headerlink" title="言归正传"></a>言归正传</h3><p>autorelease的主要作用是，和其他语言能够返回创建的临时对象一样，返回方法创建的对象。</p><ul><li>MRC：方法内部栈上变量会在方法返回后被回收，而objc对象都在堆上，不存在返回后对象被释放。</li><li>ARC：方法内部所有strong指向的对象都会在{}作用域结束时被释放。</li></ul><p>当然，无论MRC还是ARC，autorelease都保证对象延迟释放，方法的调用者不用操心获返回对象的内存管理，放心的使用。而延迟释放的时机就在<a href="http://hllovesgithub.github.io/2015/10/01/2015-10-01[Thread-Runloop]/">Runloop</a>。主线程会自动创建Runloop，每有一个系统事件时，Runloop都会调用一次对应的处理方法，但是进行任何处理之前会先创建autoreleasepool，在所有所有处理结束后，会drain掉autoreleasepool里所有的对象。所以能够保证，autorelease的对象在使用期间保证有效，使用之后也安全销毁。使用autorelease一般遇到的问题是，大量延迟释放的对象需要尽早销毁而不是等到Runloop这一次处理结束，从而让内存消耗平滑，常见于大量循环内部。不过，很简单，在需要的地方内嵌autoreleasepool即可。另外，Apple很多带有block的API都默认有局部autoreleasepool。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>ARC中使用@autoreleasepool{}来使用autoreleasepool，编译器将它编译成如下：</p><pre><code>void *context = objc_autoreleasePoolPush();// &#123;&#125;中的代码objc_autoreleasePoolPop(context);</code></pre><p>这2个方法都试对AutoreleasePoolPage(一个C++实现的类)的简单封装。</p><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ey1kylimp0j20f109m3zl.jpg"></p><ul><li>AutoreleasePool由多个AutoreleasePoolPage组合的双向链表(parent和child)</li><li>AutoreleasePool和线程一一对应(每个Page中thread的值都相同)</li><li>AutoreleasePoolPage每个对象会开辟4096字节内存(虚拟内存一页的大小)，低地址空间存放以上成员变量，其余全部储存注册的autorelease对象地址</li><li>next指针指向存放下一个add进来autorelease对象地址的位置</li><li>当一个Page空间被占满时，再新建一个Page并设好以前关系，以后add的autorelease对象将在新page中</li></ul><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1ey1kyxf74jj20dy0cx756.jpg"></p><p>每当调用objc_autoreleasePoolPush时，runtime向当前的Page中add进一个<strong>哨兵对象</strong>，值为0(=nil)，其方法的返回值正是哨兵对象的地址，在调用objc_autoreleasePoolPop时作为内存释放的目的位置：</p><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ey1kz6ifh1j20ji0dewff.jpg"></p><p>释放时，将整个双向链表中从最新的Page起到哨兵对象所处的Page，所有晚于哨兵的autorelease对象都发送一次release消息，并移动next到正确位置：</p><p><img src="http://ww1.sinaimg.cn/mw690/9460be12gw1ey1kzc7yvdj20dz0bqdgi.jpg"></p><p>嵌套的AutoreleasePool就非常简单了，pop的时候总会释放到上次push的位置为止，多层的pool就是多个哨兵对象。</p><h3 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h3><p><strong>Thread Local Storage</strong>(TLS)线程局部存储，将一块内存作为线程专有存储，以key-value形式进行读写，比如在非arm架构下，使用pthread提供的方法实现：</p><pre><code>void* pthread_getspecific(pthread_key_t);int pthread_setspecific(pthread_key_t , const void *);</code></pre><p>ARC对autorelease返回值有优化：</p><pre><code>// 编译前+ (instancetype)createSark &#123;    return [self new]; &#125;// callerSark *sark = [Sark createSark];// 编译后+ (instancetype)createSark &#123;    id tmp = [self new];    return objc_autoreleaseReturnValue(tmp); // 代替我们调用autorelease&#125;// callerid tmp = objc_retainAutoreleasedReturnValue([Sark createSark]) // 代替我们调用retainSark *sark = tmp;objc_storeStrong(&amp;sark, nil); // 相当于代替我们调用了release</code></pre><p>编译后的代码使用<strong>objc_autoreleaseReturnValue</strong>和<strong>objc_retainAutoreleasedReturnValue</strong>代替原来将对象放入AutoreleasePool中。其中objc_autoreleaseReturnValue将返回对象储存在TLS中，然后直接返回这个object(不调用autorelease)。外部接收返回值的objc_retainAutoreleasedReturnValue发现TLS中正好存了这个对象，那么直接返回这个object(不调用retain)。</p><p>但调用方不是ARC呢？通过**__builtin_return_address**得到方法的返回地址。加上偏移量能够定位到调用方在调用方法后的代码，根据代码判断调用方是否为ARC。如果是，则按照此优化处理，否则按照原来autorelease方法处理。</p><hr><h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><ul><li><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">黑幕背后的Autorelease</a></li><li>《Objective-C高级编程 iOS与OS X多线程和内存管理》</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Runtime应用</title>
    <link href="/2015/11/07/2015-11-07-Runtime%E5%BA%94%E7%94%A8/"/>
    <url>/2015/11/07/2015-11-07-Runtime%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Runtime的能力很强大，有很多优秀的第三方库基于Runtime实现了不可思议的功能。Apple也有原生框架使用Runtime使得奇妙的技术得以被自然合理地使用。这里介绍4种：Associated Object、Method Swizzling(Aspect Oriented Programming)、KVO和NSZombie。</p><h3 id="Associated-Objects"><a href="#Associated-Objects" class="headerlink" title="Associated Objects"></a>Associated Objects</h3><p>对象关联(或称为关联引用)是Runtime2.0(起始于OSX10.5和iOS4)的一个特性，它允许你在运行时向对象动态赋值关联、获取关联和删除关联：</p><ul><li>objc_setAssociatedObject</li><li>objc_getAssociatedObject</li><li>objc_removeAssociatedObjects</li></ul><p>这意味着可以对已经存在的类在Category中添加自定义属性，这几乎弥补了Objc最大的缺点。对于第2个参数key而言，通常应该是常量、唯一的、在适用范围内用getter和setter访问到的：</p><pre><code>static char kAssociatedObjectKey;objc_getAssociatedObject(self, &amp;kAssociatedObjectKey);</code></pre><p>但是，因为SEL被编译器确保了其是常量又是唯一的，所以更简单的方式是用SEL实现：</p><pre><code>@interface NSObject (AssociatedObject)@property (nonatomic, strong) id associatedObject;@end@implementation NSObject (AssociatedObject)@dynamic associatedObject;- (void)setAssociatedObject:(id)object &#123;    objc_setAssociatedObject(self, @selector(associatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (id)associatedObject &#123;    return objc_getAssociatedObject(self, @selector(associatedObject));&#125;@end</code></pre><p>而对象的关联策略由类型objc_AssociationPolicy指定：</p><ul><li>OBJC_ASSOCIATION_ASSIGN ＝ @property(assign)或者@property(unsafe_unretained)</li><li>OBJC_ASSOCIATION_RETAIN_NONATOMIC = @property (nonatomic,strong)</li><li>OBJC_ASSOCIATION_COPY_NONATOMIC = @property (nonatomic, copy)</li><li>OBJC_ASSOCIATION_RETAIN = @property (atomic, strong)</li><li>OBJC_ASSOCIATION_COPY = @property (atomic, copy)</li></ul><p>删除关联时，根据文档描述不要使用objc_removeAssociatedObjects，因为这样是删除所有关联，也许别的关联使用者添加过你不知道的关联过早被一起删除了。正确的方法是使用objc_setAssociatedObject将对应的关联设置为nil。</p><p>无论是帮助内部实现的私有属性，还是帮助外部调用的公有属性，在已有类需要属性时能实现这种需求。但是关联不是万能药，再有适合需求更好的实现时(比如Delegate，NSNotification，KVO或者Subclass)，关联应该被视为最后的选择。</p><h3 id="Method-Swizzling-Aspect-Oriented-Programming"><a href="#Method-Swizzling-Aspect-Oriented-Programming" class="headerlink" title="Method Swizzling(Aspect Oriented Programming)"></a>Method Swizzling(Aspect Oriented Programming)</h3><p>类(Class)维护一张调度表(dispatch table)在运行时解析消息；表中每项(entry)都是一个方法(Method)，其key是一个唯一的名字选择器(SEL)-字符串，对应着一个方法实现(IMP)-指向标准C函数的指针。Method swizzling通过Runtime，改变类调度表里选择器与方法实现之间的映射关系，从而让消息解析时从一个选择器对应到另外一个的实现：</p><ul><li>class_addMethod</li><li>class_replaceMethod</li><li>method_exchangeImplementations</li></ul><p>举个例子：</p><pre><code>#import &lt;objc/runtime.h&gt;@implementation UIViewController (Tracking)+ (void)load &#123;    static dispatch_once_t onceToken;    dispatch_once(&amp;onceToken, ^&#123;        Class class = [self class];                // When swizzling a class method, use the following:        // Class class = object_getClass((id)self);                SEL originalSelector = @selector(viewWillAppear:);        SEL swizzledSelector = @selector(xxx_viewWillAppear:);                Method originalMethod = class_getInstanceMethod(class, originalSelector);        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);                BOOL didAddMethod =        class_addMethod(class,                        originalSelector,                        method_getImplementation(swizzledMethod),                        method_getTypeEncoding(swizzledMethod));                if (didAddMethod) &#123;            class_replaceMethod(class,                                swizzledSelector,                                method_getImplementation(originalMethod),                                method_getTypeEncoding(originalMethod));        &#125; else &#123;            method_exchangeImplementations(originalMethod, swizzledMethod);        &#125;    &#125;);&#125;- (void)xxx_viewWillAppear:(BOOL)animated &#123;    [self xxx_viewWillAppear:animated];     NSLog(@&quot;viewWillAppear: %@&quot;, self); &#125;@end</code></pre><p>因为Method Swizzling影响全局，所以减少冒险情况就很重要。+load能够保证类初始化时就被调用，这为改变系统行为提供了统一性。而+initialize并不能保证在何时被调用直到第一次调用类的方法，这使得不同类之间没有统一性。所以Swizzling应该在+load方法中实现。同时，为了确保Swizzling即使在多线程时也只被执行一次，Swizzling应该在dispatch_once中实现。</p><p>乱用Swizzling容易导致不可预料的行为和结果，在没有足够的沟通的前提下，很容易造成看似理所当然实则莫名其妙的问题。除了显示说明和沟通以外，应用时始终调用原始实现能够保证至少正常API功能，同时给替换方法添加前缀避免和其他地方的代码产生冲突。</p><blockquote><p>An aspect can alter the behavior of the base code by applying advice (additional behavior) at various join points (points in a program) specified in a quantification or query called a pointcut (that detects whether a given join point matches).   —Wikipedia</p></blockquote><p>AOP是对OOP的一个补充，利用Runtime和AOP，可以把琐碎事务逻辑从主逻辑中分离出来，作为单独模块。有很多方式可以实现AOP，Method Swizzling就是其中之一。<a href="https://github.com/steipete/Aspects">Aspects</a>就是一个不错的AOP库。</p><h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><p>KVO是观察者模式在Objc的实现，是MVC中解耦MC通信的方法，是实现Cocoa Bindings的基础。</p><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1extbrpbvxvj213r0m8aex.jpg"></p><p>KVO的优美在于，使用时的自然合理是建立在Runtime底层一系列复杂处理换来的。简单来说，当某个对象第一次被观察时，Runtime会创建一个新的原类子类，重写所有被观察key的setter方法，并将该对象isa指向子类变成子类的实例。被重写的方法实现了如何通知观察者。有趣的是，Apple甚至也重写了-class方法，使得子类依旧返回原类，让使用者看起来什么都没发生一样。举个例子：</p><pre><code>#import &lt;Foundation/Foundation.h&gt;#import &lt;objc/runtime.h&gt;@interface TestClass : NSObject@property int x;@property int y;@property int z;@end@implementation TestClass@endstatic NSArray *ClassMethodNames(Class c) &#123;    NSMutableArray *array = [NSMutableArray array];    unsigned int methodCount = 0;    Method *methodList = class_copyMethodList(c, &amp;methodCount);    for(unsigned int i = 0; i &lt; methodCount; i++) &#123;        [array addObject: NSStringFromSelector(method_getName(methodList[i]))];    &#125;    free(methodList);    return array;&#125;static void PrintDescription(NSString *name, id obj) &#123;    NSString *str = [NSString stringWithFormat:                     @&quot;%@: %@\n\tNSObject class %s\n\tlibobjc class %s\n\timplements methods &lt;%@&gt;&quot;,                     name,                     obj,                     class_getName([obj class]),                     class_getName(object_getClass(obj)),                     [ClassMethodNames(object_getClass(obj)) componentsJoinedByString:@&quot;, &quot;]];    printf(&quot;%s\n&quot;, [str UTF8String]);&#125;int main(int argc, char **argv) &#123;    [NSAutoreleasePool new];        TestClass *x = [[TestClass alloc] init];    TestClass *y = [[TestClass alloc] init];    TestClass *xy = [[TestClass alloc] init];    TestClass *control = [[TestClass alloc] init];        [x addObserver:x forKeyPath:@&quot;x&quot; options:0 context:NULL];    [xy addObserver:xy forKeyPath:@&quot;x&quot; options:0 context:NULL];    [y addObserver:y forKeyPath:@&quot;y&quot; options:0 context:NULL];    [xy addObserver:xy forKeyPath:@&quot;y&quot; options:0 context:NULL];        PrintDescription(@&quot;control&quot;, control);    PrintDescription(@&quot;x&quot;, x);    PrintDescription(@&quot;y&quot;, y);    PrintDescription(@&quot;xy&quot;, xy);        SEL setX = @selector(setX:);    printf(&quot;Using NSObject methods, normal setX: is %p, overridden setX: is %p\n&quot;,           [control methodForSelector:setX], [x methodForSelector:setX]);    printf(&quot;Using libobjc functions, normal setX: is %p, overridden setX: is %p\n&quot;,           method_getImplementation(class_getInstanceMethod(object_getClass(control), setX)),           method_getImplementation(class_getInstanceMethod(object_getClass(x), setX)));        return 0;&#125;</code></pre><p>执行结果为(测试结果在撰写原文和本文时不一样，本文的methodForSelector:结果没有隐藏修改，但是为了阐述KVO知识，我还是引用原文的结果)：</p><pre><code>control: &lt;TestClass: 0x104b20&gt;    NSObject class TestClass    libobjc class TestClass    implements methods &lt;setX:, x, setY:, y, setZ:, z&gt;x: &lt;TestClass: 0x103280&gt;    NSObject class TestClass    libobjc class NSKVONotifying_TestClass    implements methods &lt;setY:, setX:, class, dealloc, _isKVOA&gt;y: &lt;TestClass: 0x104b00&gt;    NSObject class TestClass    libobjc class NSKVONotifying_TestClass    implements methods &lt;setY:, setX:, class, dealloc, _isKVOA&gt;xy: &lt;TestClass: 0x104b10&gt;    NSObject class TestClass    libobjc class NSKVONotifying_TestClass    implements methods &lt;setY:, setX:, class, dealloc, _isKVOA&gt;Using NSObject methods, normal setX: is 0x195e, overridden setX: is 0x195eUsing libobjc functions, normal setX: is 0x195e, overridden setX: is 0x96a1a550</code></pre><p>可以看出，没有被Observer过的对象control它的信息没有改变，无论是类型还是方法。被观察过的对象，无论被观察的property有多少，类型都会被动态地修改为另一个动态创建的子类NSKVONotifying_TestClass。这个子类重写了所有被观察property的setter方法，其内部除了调用父类实现以外，还通知观察者。</p><pre><code>(lldb)p (IMP)0x96a1a550$1 = 0x96a1a550 (Foundation`_NSSetIntValueAndNotify)</code></pre><p>所以，子类内部应该会有一份维护property映射观察者们的数据结构(根据文档，观察者和被观察者都没有内存retain，只是简单的映射关系。比如add不remove且观察者已经release，再有property变化时就会crash)，也需要重写dealloc方法至少清理该数据结构。而class的重写是为了封装变化，让使用者感到自然。_isKVOA看起来像是一个私有方法。NSObject的addObserver和removeObserver内部除了动态创建NSKVONotifying_Class子类以外，应该还有添加和删除观察者到子类中。</p><p>另外，Foundation中有一系列这样的函数：</p><pre><code>__NSSetBoolValueAndNotify__NSSetCharValueAndNotify__NSSetDoubleValueAndNotify__NSSetFloatValueAndNotify__NSSetIntValueAndNotify__NSSetLongLongValueAndNotify__NSSetLongValueAndNotify__NSSetObjectValueAndNotify__NSSetPointValueAndNotify__NSSetRangeValueAndNotify__NSSetRectValueAndNotify__NSSetShortValueAndNotify__NSSetSizeValueAndNotify__NSSetUnsignedCharValueAndNotify__NSSetUnsignedIntValueAndNotify__NSSetUnsignedLongLongValueAndNotify__NSSetUnsignedLongValueAndNotify__NSSetUnsignedShortValueAndNotify</code></pre><p>Apple为每一种primitive type都写了对应的实现。object会用到的其实只有__NSSetObjectValueAndNotify，但看起来也没有实现完全，比如long dobule或通用指针类型(generic pointer type)提供方法。所以，不在这个方法列表里的属性其实是不支持KVO的。</p><h3 id="NSZombie"><a href="#NSZombie" class="headerlink" title="NSZombie"></a>NSZombie</h3><p>僵尸对象(NSZombie)用于调试内存管理问题的时相当有用，具体是当发送消息到已经释放的对象时，僵尸对象就能检测到。一个比较常见的就是”use after free”错误。</p><p>通常情况下，对象释放后，其内存内容或者被重写或者不变。无论是哪种结果，都是无效会引发冲突。如果说这段内存恰好重写成一个新对象，那么消息可能就会发送给与原来风马牛不相及的对象，而且往往会由于无法识别选择器而抛出异常，假如这个错误的对象恰好也有该方法的话，那么就会发生更奇怪的问题。如果对象没有被重写尚未改变，处于将被销毁的状态，那么这会引起更匪夷所思的错误，比如多次调用释放占有的资源。</p><p>而僵尸对象会与对象的dealloc挂钩，最后一步不是真正释放所占内存，而是将其动态改为一个僵尸类对象，并拦截所有发送给该对象的消息。这样，再有任何消息发给该对象时都会检测到，而不是像正常调试下那样出现五花八门的状况。</p><p><strong>如何拦截信息？</strong></p><p>一个空的对象什么方法都不实现，对它发送消息后，Runtime会启动消息转发机制，所以重写forwardInvocation:是拦截消息的最佳位置。而与其对应的，需要实现methodSignatureForSelector:。</p><p><strong>如何保留类型？</strong></p><p>通过动态创建Zombie类型，指明其类名和原类产生映射，比如NSZombie_Class，这样保持原始大小，Zombie类不用额外的空间保留原类型引用。</p><p><strong>如何改变类型？</strong></p><p>Zombie主要是检测错误向已释放对象发送消息的问题，所以在原类型对象的dealloc处最适合动态修改对象类型。而重写所有对象的dealloc，需要用到上面的Method Swizzling。</p><p>总而言之，对于类型系统中原本没有的Zombie类型，通过Swizzling修改NSObject的dealloc方法，使得在运行期间任意类型对象dealloc时，动态创建和注册包含该类名信息的Zombie子类，动态添加methodSignatureForSelector:和forwardInvocation:的实现，再将原本要释放的对象的类型设置为Zombie子类。这样如果还有消息发送给本已无效的僵尸对象时，都会根据Runtime的消息转发机制最终找不到实现而产生异常(可观察释放对象信息)不至于直接crash。</p><pre><code>#import &lt;Foundation/Foundation.h&gt;#import &lt;objc/runtime.h&gt;void EmptyIMP(id obj, SEL _cmd) &#123;&#125;NSMethodSignature *ZombieMethodSignatureForSelector(id obj, SEL _cmd, SEL selector) &#123;    Class class = object_getClass(obj);    NSString *className = NSStringFromClass(class);    className = [className substringFromIndex: [@&quot;MAZombie_&quot; length]];    NSLog(@&quot;Selector %@ sent to deallocated instance %p of class %@&quot;, NSStringFromSelector(selector), obj, className);    abort();&#125;Class ZombifyClass(Class class) &#123;    NSString *className = NSStringFromClass(class);    NSString *zombieClassName = [@&quot;MAZombie_&quot; stringByAppendingString: className];    Class zombieClass = NSClassFromString(zombieClassName);    if(zombieClass) return zombieClass;    zombieClass = objc_allocateClassPair(nil, [zombieClassName UTF8String], 0);    class_addMethod(zombieClass, @selector(methodSignatureForSelector:), (IMP)ZombieMethodSignatureForSelector, &quot;@@::&quot;);    class_addMethod(object_getClass(zombieClass), @selector(initialize), (IMP)EmptyIMP, &quot;v@:&quot;);    objc_registerClassPair(zombieClass);    return zombieClass;&#125;void ZombieDealloc(id obj, SEL _cmd) &#123;    Class c = ZombifyClass(object_getClass(obj));    object_setClass(obj, c);&#125;void EnableZombies(void) &#123;    Method m = class_getInstanceMethod([NSObject class], @selector(dealloc));    method_setImplementation(m, (IMP)ZombieDealloc);&#125;int main(int argc, const char * argv[]) &#123;    EnableZombies();    NSObject *test = [[NSObject alloc] init];    [test release];    [test description];    return 0;&#125;</code></pre><p>每个类及其子类在被第一次发送消息前都会先调用+initialize，从而使其能够初始化本身。如果Runtime发现该类没有实现+initialize方法，就会将消息转发。如果在此让消息转发的话，Zombie类也就没什么用了。所以需要添加一个空的+initialize方法来避免这个问题。</p><hr><h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><ul><li><a href="http://nshipster.cn/associated-objects/">Associated Objects</a></li><li><a href="http://nshipster.com/method-swizzling/">Method Swizzling</a></li><li><a href="https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html">How KVO is actually implemented</a></li><li><a href="https://mikeash.com/pyblog/friday-qa-2011-05-20-the-inner-life-of-zombies.html">The Inner Life of Zombies</a></li><li><a href="https://mikeash.com/pyblog/friday-qa-2014-11-07-lets-build-nszombie.html">Let’s Build NSZombie</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Block</title>
    <link href="/2015/10/31/2015-11-01-Block/"/>
    <url>/2015/10/31/2015-11-01-Block/</url>
    
    <content type="html"><![CDATA[<p>尝试自己写了篇介绍block，由于文章写得太少加上技术沉淀不够，阅读起来不够舒服，所以基本知识就转载<a href="http://blog.devtang.com/blog/2013/07/28/a-look-inside-blocks/">谈Objective-C Block的实现</a>了，再额外加点自己的理解。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>在我看来，block有以下几个特点：</p><ul><li>匿名性：减少函数命名冲突</li><li>闭包性：使上下文持续有效</li><li>闭包性：增强抵抗参数变化</li><li>直观性：代码逻辑连贯紧凑</li><li>抽象性：分离变化解耦结构</li></ul><p><strong>匿名性</strong>：block块之所以能够像函数一样调用，是因为block是闭包在objc中的实现。而闭包简而言之就是，一个函数及其持有的变量环境。根据clang的-rewrite-objc查看到的代码，很清楚block是一个struct类型(当然其第一个参数是个void＊类型，可以看作为一个objc对象)，其内部有一个函数指针，刚刚好指向了由编译器根据block包涵代码编译的C静态函数(同时保证了函数的访问安全性)，而函数的命名规则目前来看是：__所在的类名__所在的函数名__block_func_索引值(区分同一类中同一函数里多个block)。命名本身是非常讲究的事儿，良好的命名(不管是函数，而是编程过程所有的概念对象：类、属性、方法、参数等等等等)能够帮助一目了然地理解和维护。而block在编译器的帮助下，coder不需要关心block的实现函数怎么命名，只需要给block起个有意义的名字即可(如果有必要的话)。</p><p><strong>闭包性</strong>：实现block的struc类型其内部会保留所引用到的外部变量(稍后讲到)，而函数同步执行完后栈会回收跳转到另一个函数继续重新使用栈，这就使得在函数异步执行前不用手动保存所需要的栈上变量，延长了局部变量的生命周期。block能够灵活地保留引用变量并和参数变量隔离开来，参数变量应设计为对block稳定的影响，引用变量应设计为对block变化的影响。举个例子：</p><pre><code>- (BOOL)isName:(NSString *)name in:(NSArray *)names &#123;    __block BOOL flag = NO;    name = [name copy];    [names enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;        if ([obj isMemberOfClass:[NSString class]]) &#123;            NSString *str = (NSString *)obj;            flag = [str isEqualToString:name];            *stop = flag;        &#125;    &#125;];    return flag;&#125;</code></pre><p>block抽象的是逻辑。对带有block的API的设计，其参数变量是稳定的，block的逻辑因业务需求的变化而变化，这个变化就可以通过改变block的引用变脸来实现，隔离了变化对API参数的影响。</p><p><strong>直观性</strong>：block分解地来看，其实还是对函数的调用。更详细一点，是对回调函数的调用。而无论是Targer-Action，Delegate，Notification还是block，其本质都是回调函数。只不过是面向不同层级的抽象，以淡化类型污染，分离结构耦合。block能做到的事儿，delegate都能做到。是的，比方说用到多少个block就写多少个对应的回调。但是，不仅delegate获取的变量固定有限不能相迎变化的参数需求，而且有函数名竞争和潜在函数名写错的风险，最主要的是，查看delegate声明和实现需要多个文件之间来回跳转，逻辑容易中断(特别是异步调用)。而block，作为objc能够FP(Functional Programming)的基础，能够当作参数传递，使得多个不同的代码块能够写在一起，阅读维护时风格简单直观逻辑清晰连贯。业务的不同层级交互可以写在一个地方，不用污染功能模块。举个例子：</p><pre><code>RACSignal *networkRequest = [RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;    AFHTTPRequestOperation *operation = [client        HTTPRequestOperationWithRequest:request        success:^(AFHTTPRequestOperation *operation, id response) &#123;            [subscriber sendNext:response];            [subscriber sendCompleted];        &#125;        failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123;            [subscriber sendError:error];        &#125;];    [client enqueueHTTPRequestOperation:operation];    return [RACDisposable disposableWithBlock:^&#123;        [operation cancel];    &#125;];&#125;];</code></pre><p><strong>抽象性</strong>：</p><p>block抽象的是一段，公开了可以影响执行结果的参数接口的，执行逻辑。因为block可以作为参数传递，所以可以将变化的逻辑作为功能的参数暴露出来，而稳定的逻辑写在函数里面。分离外部变化和内部实现，最大限度地维护代码稳定。功能调用者不用关心内部实现是什么，只用关心外部业务是什么。</p><pre><code>- (Result)processBussness:(Change (^)(Steady a, Steady b, Steady c))external &#123;    // PreProcess Steady    Steady a = ...    Steady b = ...    Steady c = ...    // Get The Change    Change change = external(a, b, c);    // PostProcess Result Using Steady And Change    Result result = ...&#125;- (void)bussnessA &#123;    [self processBussness:^(Steady a, Steady b, Steady c)&#123;        // Make Change By Rule A        return changeA    &#125;];&#125;- (void)bussnessB &#123;    [self processBussness:^(Steady a, Steady b, Steady c)&#123;        // Make Change By Rule B        return changeB    &#125;];&#125;- (void)bussnessC &#123;    [self processBussness:^(Steady a, Steady b, Steady c)&#123;        // Make Change By Rule C        return changeC    &#125;];&#125;</code></pre><h3 id="保留引用变量"><a href="#保留引用变量" class="headerlink" title="保留引用变量"></a>保留引用变量</h3><pre><code>#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123;    NSInteger intN = 123;    __block NSInteger intY = 321;    NSMutableArray *aryN = [[NSMutableArray alloc] initWithArray:@[@(123)]];    __block NSMutableArray *aryY = [[NSMutableArray alloc] initWithArray:@[@(321)]];    NSLog(@&quot;IntN:%p   AryN:%p   IntY:%p   AryY:%p&quot;, &amp;intN, &amp;aryN, &amp;intY, &amp;aryY);    dispatch_block_t block = ^(void)&#123;        NSLog(@&quot;IntN:%p   AryN:%p   IntY:%p   AryY:%p&quot;, &amp;intN, &amp;aryN, &amp;intY, &amp;aryY);    &#125;;    block();    dispatch_block_t blockCopy = [block copy];    blockCopy();    return 0;&#125;MRC原本：IntN:0x7fff5fbff840   AryN:0x7fff5fbff818   IntY:0x7fff5fbff838   AryY:0x7fff5fbff800栈上：IntN:0x7fff5fbff7c8   AryN:0x7fff5fbff7b0   IntY:0x7fff5fbff838   AryY:0x7fff5fbff800堆上：IntN:0x000100600948   AryN:0x000100600930   IntY:0x000100600968   AryY:0x000100600328ARC原本：IntN:0x7fff5fbff840   AryN:0x7fff5fbff818   IntY:0x7fff5fbff838   AryY:0x7fff5fbff800栈上：IntN:0x000100500848   AryN:0x000100500830   IntY:0x000100500868   AryY:0x000100500028堆上：IntN:0x000100500848   AryN:0x000100500830   IntY:0x000100500868   AryY:0x000100500028</code></pre><ul><li>类型维度：基本类型和对象类型</li><li>读写维度：默认只读和__block可写</li><li>堆栈维度：栈和堆</li><li>ARC维度：MRC和ARC</li></ul><p><strong>类型维度</strong>：基本类型可在栈或堆上，而对象类型一直都在堆上。</p><p><strong>读写维度</strong>：对于__block符号，无则引用的是原类型(基本类型变量或者对象类型指针)，有则引用的是新类型(包含原类型信息的结构体指针)，并且在结构体内分别有2个函数负责管理包含的对象的内存：</p><pre><code>void (*__Block_byref_id_object_copy)(void*, void*);void (*__Block_byref_id_object_dispose)(void*);</code></pre><p>结构体在创建后调用Block_byref_id_object_copy函数来retain对象，结构体在释放前调用Block_byref_id_object_dispose函数来release对象。使得新类型结构体在有效期间内，包含的对象始终有效。</p><p><strong>ARC维度</strong>：MRC有3种类型的block(_NSConcreteGlobalBlock，_NSConcreteStackBlock和_NSConcreteMallocBlock)，而ARC用_NSConcreteMallocBlock替换了_NSConcreteStackBlock，即ARC下不会再在栈上临时分配block，而是把所有block(除了编译期间就能确定实现的_NSConcreteGlobalBlock全局block)都创建在堆上。</p><p><strong>堆栈维度</strong>：当block从栈copy到堆时，会调用_Block_object_assign函数来retain所有新类型结构体。当block从堆中释放时，会调用_Block_object_dispose函数来release所有新类型结构体。使得block对象在有效期间，包含的所有__block新类型结构体都有效。</p><p><strong>总结</strong>：(其中ARC和MRC的堆情况一致)</p><ul><li>栈上只读基本类型变量：栈上block有一个栈上原变量新副本，变量值不受栈上原变量改变影响。</li><li>栈上可写基本类型变量：变成一个新类型结构体(内部有个等值变量)，栈上block有一个指向栈上结构体指针，block内外都能通过指针影响栈上结构体内部变量值。</li><li>栈上只读对象类型指针：栈上block有一个栈上原对象指针新副本，指向对象不受栈上原指针改变影响，但指向对象的信息可被改变。</li><li>栈上可读对象类型指针：变成一个新类型结构体(内部有个等值指针)，栈上block有一个指向栈上结构体指针，block内外都能通过指针影响栈上结构体内部指向对象，且指向对象的信息可被改变。</li><li>堆上只读基本类型变量：堆上block有一个堆上原变量新拷贝，变量值不受栈上原变量改变影响。</li><li>堆上可写基本类型变量：变成一个新类型结构体(内部有个等值变量)，堆上block有一个指向堆上结构体指针，栈上结构体重定向到堆上结构体，block内外都能通过指针影响堆上结构体内部变量值。</li><li>堆上只读对象类型指针：堆上block有一个堆上原对象指针新拷贝，指向对象不受栈上原指针改变影响，但指向对象的信息可被改变。</li><li>堆上可写对象类型指针：变成一个新类型结构体(内部有个等值指针)，堆上block有一个指向堆上结构体指针，栈上结构体重定向到堆上结构体，block内外都能通过指针影响堆上结构体内部指向对象，且指向对象的信息可被改变。</li></ul><p>我认为，ARC用_NSConcreteMallocBlock替换_NSConcreteStackBlock，第一是统一类型方便管理内存，第二是减少MRC时潜在问题。比如对于带有block的API设计，如果API是同步执行，block在调用时所引用的外部变量都还在栈中有效，如果API是异步执行，而API实现者在内部没有或者忘记对block进行copy到堆中，那么block执行的时候就会出错。MRC时Apple所有带有block的API内部默认应该都是有拷贝过的，但不能保证Coder自己构造API时不会出错。所以ARC统一block的类型为_NSConcreteMallocBlock保证了都至少在堆上存在有效。</p><h3 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h3><p>block的类型声明并没有什么需要特别注意的，除了参数类型为()代表的不是(void)，而是缺省类型。在某些时候，是可以做到跟id或者协议一样范型编程的：</p><pre><code>typedef void(^BLOCK)();int main(int argc, const char * argv[]) &#123;    BLOCK blk0 = ^(void)&#123;        NSLog(@&quot;No Value&quot;);    &#125;;    BLOCK blk1 = ^(NSString *str)&#123;        NSLog(@&quot;Value is %@&quot;, str);    &#125;;    BLOCK blk2 = ^(NSInteger a, CGFloat b)&#123;        NSLog(@&quot;Valus are %ld and %f&quot;, a, b);    &#125;;    blk0();    blk1(@&quot;Test&quot;);    blk2(1,2.3);    return 0;&#125;</code></pre><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p>block的实现里指明了reference的作用，将栈上的结构体重定向到堆上结构体，从而访问正确的引用。在ARC下已经没有栈上结构体了所以不要紧，在MRC下也只有出现堆上block后还执行栈上block的情况下才有真正起到作用：</p><pre><code>#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123;    __block NSInteger intN = 123;    dispatch_block_t blockN = ^(void)&#123;        intN = 0;    &#125;;    blockN();    [blockN copy];        __block NSInteger intY = 123;    dispatch_block_t blockY = ^(void)&#123;        intY = 0;    &#125;;    [blockY copy];    blockY();        return 0;&#125;</code></pre><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>循环引用循环是使用block的一个最主要的内存问题。因为block是个对象也会保留引用的对象，所以如果被引用的对象恰好也保留了该block，那么就构成了循环引用。其实此类问题基本性质都是一样的，只是犹豫block的匿名性导致不太注意而引起。原则就是：block不要直接引用拥有block的对象。对于GCD的block，没有对象引用它，所以可以大胆地写，但是作为对象的属性或者API的参数，都需要注意该对象和调用者之间的拥有关系<a href="http://tanqisen.github.io/blog/2013/04/19/gcd-block-cycle-retain/">正确使用Block避免Cycle Retain和Crash</a>。这里介绍一个优秀库<a href="https://github.com/jspahrsummers/libextobjc">libextobjc</a>，其定义了**@weakify<strong>，</strong>@unsafeify<strong>，</strong>@strongify**语法糖，优雅地解决了block循环引用问题，下次专门写篇blog来介绍它。</p><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>block作为objc的闭包实现，为FP(Functional Programming)打下坚实的基础。BlocksKit就是结合block实现的对象函数式扩展。ReactiveCocoa就是利用block实现的响应函数式编程。不过，如果block嵌套较多后，很容易出错也很难调试。函数式编程又是另一个庞大复杂的课题了，我也学习了一段时间，也觉得是将来的发展方向，以后慢慢花时间写点东西。</p><hr><h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><ul><li><a href="http://www.devtang.com/blog/2013/07/28/a-look-inside-blocks/">谈Objective-C Block的实现</a></li><li><a href="http://chun.tips/blog/2014/11/13/hei-mu-bei-hou-de-blockxiu-shi-fu/">黑幕背后的__block修饰符</a></li><li><a href="http://tanqisen.github.io/blog/2013/04/19/gcd-block-cycle-retain/">正确使用Block避免Cycle Retain和Crash</a></li><li><a href="http://tech.meituan.com/block-in-Meituan-iOS.html">block在美团iOS的实践</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GCD 扩展</title>
    <link href="/2015/10/25/2015-10-25-GCD%20%E6%89%A9%E5%B1%95/"/>
    <url>/2015/10/25/2015-10-25-GCD%20%E6%89%A9%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h3 id="调度源"><a href="#调度源" class="headerlink" title="调度源"></a>调度源</h3><p>GCD提供一些调度源接口来监测底层系统对象(比如Unix文件描述符、Mach端口、Unix信号、Unix虚拟文件系统节点、自定义源等等)的活动。不像阻塞等待事件发生或者反复轮询查看那样浪费资源也无法度量，调度源像<a href="https://en.wikipedia.org/wiki/Kqueue">kquque</a>一样自动异步地提交任务到指定调度队列响应处理。</p><ul><li><strong>dispatch_source_create</strong>：创建一个新的调度源来检测底层系统对象，并响应事件自动提交事件回调任务到指定队列执行。调度源开始都是暂停状态，需要使用<strong>dispatch_resume</strong>启动。不再使用时需要调用<strong>dispatch_release</strong>释放资源。</li><li><strong>dispatch_source_set_registration_handler</strong>：调度源底层的事件发送策略是异步设置的。在调度源完全设置好并准备开始发送事件时，注册回调任务就会被提交到指定队列执行。在调度源暂停或者正在执行回调任务期间，如果事件到达，事件会合并在一起，等到调度源启动或者回调任务执行完再发送。</li><li><strong>dispatch_source_set_event_handler</strong>：监测的事件发生时，事件回调任务响应并被提交到指定队列执行。其中使用<strong>dispatch_source_get_data</strong>获取调度源等待处理的数据，其代表意义因调度源类型的不同而不同。</li><li><strong>dispatch_source_set_cancel_handler</strong>：当系统释放了所有对调度源的引用时，取消回调任务响应并被提交到指定队列执行。通常用于清理占用的资源，例如打开的文件或者套接字。</li><li><strong>dispatch_source_cancel</strong>：异步地取消调度源，阻止事件回调任务继续执行。</li></ul><p>dispatch_source_t <strong>dispatch_source_create</strong>(dispatch_source_type_t type, uintptr_t handle, unsigned long mask, dispatch_queue_t queue)中，type是最重要的参数，因为它决定了handle和mask参数将会是什么。</p><ul><li>DISPATCH_SOURCE_TYPE_DATA_ADD监测自定义源逻辑Add数据合并，handle和mask未使用。</li><li>DISPATCH_SOURCE_TYPE_DATA_OR监测自定义源逻辑Or数据合并，handle和mask未使用。</li><li>DISPATCH_SOURCE_TYPE_MACH_RECV监测Mach端口接收，handle代表<strong>Mach端口号</strong>，mask未使用。</li><li>DISPATCH_SOURCE_TYPE_MACH_SEND监测Mach端口发送，handle代表<strong>Mach端口号</strong>，mask代表<strong>发送事件标识</strong>。</li><li>DISPATCH_SOURCE_TYPE_PROC监测进程，handle代表<strong>进程号</strong>，mask代表<strong>进程事件标识</strong>。</li><li>DISPATCH_SOURCE_TYPE_READ监测文件描述符读，handle代表<strong>文件描述符</strong>，mask未使用。</li><li>DISPATCH_SOURCE_TYPE_SIGNAL监测信号，handle代表<strong>信号量</strong>，mask未使用。</li><li>DISPATCH_SOURCE_TYPE_TIMER监测定时器，handle和mask未使用。</li><li>DISPATCH_SOURCE_TYPE_VNODE监测虚拟文件系统节点，handle代表<strong>文件描述符</strong>，mask代表<strong>节点事件标识</strong>。</li><li>DISPATCH_SOURCE_TYPE_WRITE监测文件描述符写，handle代表<strong>文件描述符</strong>，mask未使用。</li><li>DISPATCH_SOURCE_TYPE_MEMORYPRESSURE监测内存压力，handle未使用，mask代表<strong>压力事件标识</strong>。</li></ul><p><strong>自定义源</strong>：通过<strong>dispatch_source_merge_data</strong>主动发送信号产生系统事件。其函数名的来由是，如果当前比较繁忙，GCD会在执行响应方法前，会多次自动联结事件，最终只执行一次响应方法。</p><pre><code>dispatch_queue_t mainQueue = dispatch_get_main_queue();dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);__block unsigned long data = 0;dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, mainQueue);dispatch_source_set_event_handler(source, ^&#123;    unsigned long delta = dispatch_source_get_data(source);    data += delta;&#125;);dispatch_resume(source);dispatch_apply(100, globalQueue, ^(size_t index) &#123;    dispatch_source_merge_data(source, 1);&#125;);</code></pre><p><strong>文件描述符</strong>：使用GCD监测文件描述符读写。</p><pre><code>dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_source_t stdinSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, STDIN_FILENO, 0, globalQueue);dispatch_source_set_event_handler(stdinSource, ^&#123;    char buf[1024];    long len = read(STDIN_FILENO, buf, sizeof(buf));    if(len &gt; 0)        NSLog(@&quot;Got data from stdin: %s&quot;, buf);&#125;);dispatch_resume(stdinSource);    </code></pre><p><strong>进程</strong>：使用GCD监测进程事件，包括进程退出、进程分叉、进程执行和进程信号。</p><pre><code>dispatch_queue_t mainQueue = dispatch_get_main_queue();NSArray *runningApps = [NSRunningApplication runningApplicationsWithBundleIdentifier:@&quot;com.apple.mail&quot;];NSRunningApplication *mail = [runningApps count]? runningApps[0]: nil;if (mail) &#123;    pid_t const pid = mail.processIdentifier;    dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_PROC, pid, DISPATCH_PROC_EXIT, mainQueue);    dispatch_source_set_event_handler(source, ^()&#123;        NSLog(@&quot;Mail Quit&quot;);    &#125;);    dispatch_resume(source);&#125;</code></pre><p><strong>文件系统节点</strong>：使用GCD监测文件系统节点事件，包括节点删除、节点内容写入、节点大小变化、节点属性变化、节点链接数变化、节点名字变化和节点被删除。</p><pre><code>NSURL *directoryURL; // assume this is set to a directoryint const fd = open([[directoryURL path] fileSystemRepresentation], O_EVTONLY);if (fd &lt; 0) &#123;    char buffer[80];    strerror_r(errno, buffer, sizeof(buffer));    NSLog(@&quot;Unable to open \&quot;%@\&quot;: %s (%d)&quot;, [directoryURL path], buffer, errno);    return;&#125;dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE, fd, DISPATCH_VNODE_WRITE | DISPATCH_VNODE_DELETE, DISPATCH_TARGET_QUEUE_DEFAULT);dispatch_source_set_event_handler(source, ^()&#123;    unsigned long const data = dispatch_source_get_data(source);    if (data &amp; DISPATCH_VNODE_WRITE) &#123;        NSLog(@&quot;The directory changed.&quot;);    &#125;    if (data &amp; DISPATCH_VNODE_DELETE) &#123;        NSLog(@&quot;The directory has been deleted.&quot;);    &#125;&#125;);dispatch_source_set_cancel_handler(source, ^()&#123;    close(fd);&#125;);dispatch_resume(source);</code></pre><p><strong>信号</strong>：使用GCD监测信号，这些信号可在signal.h中找到。比如，信号SIGSTOP将会在进程接收到一个无法回避的暂停指令时被发出。LLDB调试器调试应用时使用的也是这个信号。</p><pre><code>dispatch_queue_t mainQueue = dispatch_get_main_queue();__typeof(self) __weak weakSelf = self;static dispatch_source_t source = nil;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;    source = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL, SIGSTOP, 0, mainQueue);    if (source) &#123;        dispatch_source_set_event_handler(source, ^&#123;            NSLog(@&quot;Hi, I am: %@&quot;, weakSelf);        &#125;);        dispatch_resume(source);    &#125;&#125;);</code></pre><p><strong>定时器</strong>：使用GCD监测定时器。GCD不保证计时器100%精准触发，由参数leeway决定了触发精准度。其意义是为了降低资源消耗，因为系统可以让CPU休息足够长的时间，尽量每次醒来时执行一个任务集合，而不是不断醒来只执行一个任务，这样效率更高。比如较大的leeway允许系统拖延计时器触发，尽量拖延到与其他任务一起执行。</p><pre><code>dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, DISPATCH_TARGET_QUEUE_DEFAULT);dispatch_source_set_timer(source, DISPATCH_TIME_NOW, 1ull * NSEC_PER_SEC, 0);dispatch_source_set_event_handler(source, ^()&#123;    NSLog(@&quot;Time flies.&quot;);&#125;);dispatch_resume(source);</code></pre><h3 id="调度I-O管道"><a href="#调度I-O管道" class="headerlink" title="调度I/O管道"></a>调度I/O管道</h3><p>调度I/O通道提供了一种与读写文件描述符不同的方式。有流和随机存取两种类型的管道。比如，硬盘文件可以创建一个随机存取管道(因为文件描述符是可寻址的)，套接字可以创建一个流管道。和文件描述符一样，I/O管道也拥有读写操作，但这些操作都是以非阻塞，异步I/O的形式高效实现的。I/O管道也有同步读写操作的屏障操作，还可以设置最高和最低字节数限制，操作周期。</p><h3 id="调度缓冲区"><a href="#调度缓冲区" class="headerlink" title="调度缓冲区"></a>调度缓冲区</h3><p>以往处理多个小而散的缓冲区数据时，通常会将它们组合成大缓冲区再进行处理，但这样不仅会复制大量数据，而且大量I/O操作会在降低性能占用更多资源。很多旧C的API有个问题是，缓冲区没有所有权的概念，所以不得不将数据再次拷贝以保证使用期间有效。GCD的dispatch_data_t，在某种程度上和Objc的NSData很相似，但是必须记住GCD只是纯C的API不能使用Objc对象。dispatch_data_t(基于栈或基于栈)使得对应的缓冲区有了所有权的概念能确保有效性不产生拷贝操作，而且其相当独特的是可以基于多个零碎的内存区域抽象成一个连续的内存区域来提供使用。</p><ul><li><strong>dispatch_data_create</strong>：创建调度缓冲区对象，指定析构回调任务和执行队列。</li><li><strong>dispatch_data_create_map</strong>：返回一个拷贝原缓冲区对象内容且内存连续分布的新缓冲区对象。</li><li><strong>dispatch_data_create_concat</strong>：返回一完整引用了两个缓冲区对象的新缓冲区对象。</li><li><strong>dispatch_data_create_subrange</strong>：返回一个引用原缓冲区对象部分的新缓冲区对象。</li><li><strong>dispatch_data_apply</strong>：贯穿整个缓冲区对象每一个子区域并执行方法。</li><li><strong>dispatch_data_copy_region</strong>：返回一个拷贝原缓冲区对象部分内容的新缓冲区对象。</li></ul><h3 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h3><p>GCD有一个适合优化代码的灵巧小工具：uint64_t <strong>dispatch_benchmark</strong>(size_t count, void (^block)(void));文件头部声明该函数类型，就能够测量测试代码执行的平均纳秒数：</p><pre><code>size_t const objectCount = 100;uint64_t n = dispatch_benchmark(1000, ^&#123;    @autoreleasepool &#123;        id obj = @42;        NSMutableArray *array = [NSMutableArray array];        for (size_t i = 0; i &lt; objectCount; ++i) &#123;            [array addObject:obj];        &#125;    &#125;&#125;);NSLog(@&quot;-[NSMutableArray addObject:] : %llu ns&quot;, n);</code></pre><hr><h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><ul><li><a href="http://www.anselz.com/2014/04/20/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3gcd%EF%BC%9Apart12/">深入了解GCD：Part 1/2</a></li><li><a href="http://www.anselz.com/2014/05/05/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3gcd%EF%BC%9Apart-22/">深入了解GCD：Part 2/2</a></li><li><a href="http://objccn.io/issue-2-1/#priority_inversion">并发编程：API 及挑战</a></li><li><a href="http://objccn.io/issue-2-3/">底层并发 API</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GCD 基本</title>
    <link href="/2015/10/18/2015-10-18-GCD%E5%9F%BA%E6%9C%AC/"/>
    <url>/2015/10/18/2015-10-18-GCD%E5%9F%BA%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>中央调度(GCD)由语言特征、运行时库和系统改善组成，对运行iOS和OSX系统的多核硬件并行执行代码提供了系统的、全面的支持。BSD子系统，CoreFoundation和Cocoa的API都已扩展来使用这项改善技术来帮助系统和应用程序运行得更快速更有效更响应。考虑到一个应用程序能够有效地使用多核是多么的困难，更不用说在有不同核数的计算设备里和其他应用程序竞争。在系统级工作的GCD可以根据所有正在运行的程序，以最平衡的的方式分配它们有效的系统资源。GCD不光支持在Unix类操作系统的同步异步执行代码，还可以与文件描述符、Mach端口、Unix信号和定时器工作。</p><p>在使用Objc编译器构建App时，所有的dispatch objects(调度对象)都是Objc对象。所以，当ARC(Automatic reference counting)开启时，dispatch objects会像Objc对象一样被编译器自动在适当的地方retain和release。当ARC关闭时，使用dispatch_retain和dispatch_release(而不是retain和release)管理内存。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>**串行并行(Serial &amp; Concurrent)**串行是指同一时间只执行一个任务，并行是指同一时间能执行多个任务。串行执行完前一个任务后才能开始执行后一个任务，严格保证任务之间的执行顺序。并行开始执行一个任务和其他并行任务无关，任务之间的执行顺序也是任意随机。</li><li>**同步异步(Synchronize &amp; Asynchronize)**同步异步是为了描述任务发起者和任务执行者之间的等待关系。同步是指，任务发起者必须要等到任务执行者执行完任务之后再继续做自己的事儿。异步是指，任务发起者不用等到任务执行者执行完任务之后就可以继续做自己的事儿。线程上的表现，同步就是阻塞挂起休眠，异步就是返回继续执行。</li><li>**临界区(Critical Area)**临界区是指一个不能同时被多个线程访问、当有线程进入执行其他线程必须等待的代码块。</li><li>**竞态条件(Race Condition)**静态条件是某任务不能屏蔽被多线程无序执行带来的副作用(执行结果对顺序敏感)。</li><li>**死锁(Dead Lock)**死锁是指多线程由于竞争造成所有相关线程都被阻塞而程序无法继续执行。</li></ul><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p>宏观上并发与并行都是同时执行。微观上并发同一时间只执行一个任务，但执行适当时间后暂停当前任务，切换到新任务再执行适当时间；并行确实真真正正的同一时间都在执行多个任务。其差别在于，系统能够使用的核数目。单核的确只能执行一个任务为了支持多线程才用并发，多核就能够执行多个任务便可以并行。</p><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1exc4cb94oqj20go09gq31.jpg"></p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>dispatch queues(调度队列)是GCD提供用来提交任务并执行的轻量级对象。dispatch queues以FIFO(First In First Out)的顺序开始执行任务。系统管理线程池用来处理分配线程执行提交到dispatch queues的任务。所有dispatch queues都是线程安全的，可以在多线程中访问。GCD提供1个串行队列(主队列)和4个并行队列(全局队列：高、默认<br>低、后台)，也可以创建自定义的串行或者并行队列。</p><p>**串行队列(Serial Queue)**的任务串行执行(以FIFO开始和结束)，因此不会出现竞争资源的临界区访问。</p><ul><li>dispatch_get_main_queue()主队列由系统自动创建并和主线程关联唯一能访问UI的队列</li><li>dispatch_queue_create(“Serial”,DISPATCH_QUEUE_SERIAL)</li></ul><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1exc4cn7yl6j20dc07k3zb.jpg"></p><p>**并行队列(Concurrent Queue)**的任务并行执行(以FIFO开始)。旧任务何时完成，新任务何时开始，某时刻多少个任务在执行完全取决于GCD。</p><ul><li>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH,0)</li><li>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0)</li><li>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW,0)</li><li>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND,0)</li><li>dispatch_queue_create(“Concurrent”,DISPATCH_QUEUE_CONCURRENT)</li></ul><p><img src="http://ww3.sinaimg.cn/mw690/9460be12gw1exc4cto4zaj20dc07k0te.jpg"></p><p><strong>dispatch_queue_create</strong>自定义队列创建时可以用字符串当标签用来在XCode调试、Instruments检测，Crash报告中标识自己。</p><p><img src="http://ww1.sinaimg.cn/mw690/9460be12gw1exk1qtr512j20hg0a33zf.jpg"></p><p><strong>dispatch_set_target_queue</strong>一个对象的目标队列决定了最终在那个队列里处理该对象(调度队列Dispatch Queue、调度源Dispatch Sources、调度I/O管道)。对调度队列而言，如果有目标队列，则其优先级继承自目标队列。使用目标队列可以实现很多满足特定需求的队列体系。动态改变任务优先级，动态改变任务同异步。比如任务组里的任务要同步，且与其他任务组的任务也同步：</p><pre><code>dispatch_queue_t targetQueue = dispatch_queue_create(&quot;com.Banana.Demo&quot;, DISPATCH_QUEUE_SERIAL);dispatch_queue_t serial1 = dispatch_queue_create(&quot;Serial1&quot;, DISPATCH_QUEUE_SERIAL);dispatch_queue_t serial2 = dispatch_queue_create(&quot;Serial2&quot;, DISPATCH_QUEUE_SERIAL);dispatch_queue_t serial3 = dispatch_queue_create(&quot;Serial3&quot;, DISPATCH_QUEUE_SERIAL);dispatch_set_target_queue(serial1, targetQueue);dispatch_set_target_queue(serial2, targetQueue);dispatch_set_target_queue(serial3, targetQueue);dispatch_async(serial1, ^&#123;    // Task 1_1&#125;);dispatch_async(serial1, ^&#123;    // Task 1_2&#125;);dispatch_async(serial2, ^&#123;    // Task 2_1&#125;);dispatch_async(serial2, ^&#123;    // Task 2_2&#125;);dispatch_async(serial3, ^&#123;    // Task 3_1&#125;);dispatch_async(serial3, ^&#123;    // Task 3_2&#125;);</code></pre><h3 id="管理调度对象"><a href="#管理调度对象" class="headerlink" title="管理调度对象"></a>管理调度对象</h3><p>GCD提供调度对象接口让程序管理诸如内存管理、暂停恢复、定义语境和记录日志的功能。</p><p>内存管理：dispatch_retain和dispatch_release(ARC不用)，dispatch_set_finalizer_f(调度对象销毁前用于释放相关连的资源)。<br>暂停恢复：dispatch_resume和dispatch_suspend。<br>定义语境：dispatch_set_context和dispatch_get_context。<br>记录日志：dispatch_debug。</p><p><strong>dispatch_set_context</strong>参数context是一个可以指向任意的void＊，为队列设置任意类型数据，在合适时取出使用。GCD是主要用C编写的底层库，对于C开辟的内存和Cpp创建的对象本身有Coder自己管理内存，但Objc在ARC环境中就需要接管Objc对象的内存管理以免在获取context时已经释放。</p><pre><code>typedef struct TestC &#123;    int number;&#125;TestC;void finalizerC(void *context) &#123;    TestC *testC = (TestC *)context;    NSLog(@&quot;End C: %d&quot;, testC-&gt;number);    free(testC);&#125;@interface TestObjC : NSObject@property(assign, nonatomic) int number;@end@implementation TestObjC- (void)dealloc &#123;    NSLog(@&quot;%@&quot;, NSStringFromSelector(_cmd));&#125;@endvoid finalizerObjC(void *context) &#123;    TestObjC *testObjC = (__bridge_transfer TestObjC *)(context);    NSLog(@&quot;End ObjC: %d&quot;, testObjC.number);&#125;- (void)test &#123;    dispatch_queue_t queueC = dispatch_queue_create(&quot;com.Banana.TestC&quot;, DISPATCH_QUEUE_SERIAL);    dispatch_set_context(queueC, malloc(sizeof(TestC)));    dispatch_set_finalizer_f(queueC, finalizerC);    dispatch_async(queueC, ^&#123;        TestC *testC = dispatch_get_context(queueC);        NSLog(@&quot;Start C: %d&quot;, testC-&gt;number);        testC-&gt;number = 1;    &#125;);        dispatch_queue_t queueObjC = dispatch_queue_create(&quot;com.Banana.TestObjC&quot;, DISPATCH_QUEUE_SERIAL);    dispatch_set_context(queueObjC, (__bridge_retained void *)[[TestObjC alloc] init]);    dispatch_set_finalizer_f(queueObjC, finalizerObjC);    dispatch_async(queueObjC, ^&#123;        TestObjC *testObjC = (__bridge TestObjC *)dispatch_get_context(queueObjC);        NSLog(@&quot;Start ObjC: %d&quot;, testObjC.number);        testObjC.number = 1;    &#125;);&#125;</code></pre><ul><li><strong>__bridge</strong>:只转换类型(Ojbc&lt;-&gt;CF)，不改所有权；</li><li><strong>__bridge_retained</strong>(即CFBridgingRetain)转换类型(Ojbc-&gt;CF)，并从ARC获取所有权，后续负责管理对象内存；</li><li><strong>__bridge_transfer</strong>(即CFBridgingRelease)转换类型(CF-&gt;Objc)，并移交所有权到ARC，不再负责管理对象内存。</li></ul><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><ul><li><strong>sync</strong>所有的dispatch-sync方法同步提交任务到队列并阻塞直到任务结束。</li><li><strong>async</strong>所有的dispatch-async方法异步提交任务到队列并立即返回继续执行。</li><li><strong>dispatch_after</strong>异步提交定时任务并立即返回继续执行。</li><li><strong>dispatch_apply</strong>同步提交多个任务并阻塞直到所有任务结束。任务间根据目标队列(Target Queue)同步(意义不大)或者异步执行。</li><li><strong>dispatch_group_wait</strong>阻塞当前线程直到所有提交的任务结束或者超时。</li><li><strong>dispatch_semaphore_wait</strong>阻塞当前线程直到获取一个信号量。</li><li><strong>dispatch_barrier_sync</strong>同步提交一个屏障任务并阻塞直到任务结束。</li></ul><p>以上方法中所有的同步方法在使用时都需要认真考虑以避免出现死锁。串行队列就很容易出戏：</p><pre><code>SyncMethodA(SerialQueue, ^&#123;    SyncMethodB(SerialQueue, ^&#123;        // The Task    &#125;);&#125;);</code></pre><p>Sync为什么比较容易出现死锁？我个人认为因为封装。方法封装了操作，调用时(该方法，没有源代码，没有API说明，或者Coder根本就没注意或者懒得注意或者开始注意后来不小心忘记)不知道方法里面(或者里面的里面的里面)是否嵌套了同步，如果继续同步调用该方法就很有可能死锁(即使不是在同一个队列)。比较保险的方法就是在符合语义的情况下尽可能使用异步方法，对于在异步部分之后需要同步的内容可以写在异步任务里顺序执行。</p><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1exc4d3mb87j20jg08c40h.jpg"></p><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>单例模式的常见问题是，单例常常在多线程中同时被多个对象访问而线程不安全。<strong>dispatch_once</strong>整个程序生命周期里，以线程安全的方式执行且仅执行一次任务，很适合单例初始化:</p><pre><code>+ (instancetype)sharedname &#123;    static class *_sharedname = nil;    static dispatch_once_t onceToken;    dispatch_once(&amp;onceToken, ^&#123;        _sharedname = initializer;    &#125;);        return _sharedname;&#125;</code></pre><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1exc4dbhlxhj20dc07mq4a.jpg"></p><h3 id="组"><a href="#组" class="headerlink" title="组"></a>组</h3><p>程序可以提交多个任务(任务可以是同步也能是异步，即使在不同队列中)到调度组并跟踪它们直到都结束或者超时。提交到任务组有2种方式：</p><ul><li>dispatch_group_async</li><li>dispatch_group_enter和dispatch_group_leave(必须成对调用)</li></ul><p>任务组结束的通知任务也有同步dispatch_group_wait和异步dispatch_group_notify2种方式。</p><pre><code>dispatch_group_t group = dispatch_group_create();dispatch_queue_t mainQueue = dispatch_get_main_queue();dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_group_async(group, globalQueue, ^&#123;    // Task1&#125;);dispatch_group_enter(group);// Task 2dispatch_group_leave(group);dispatch_group_notify(group, mainQueue, ^&#123;    // Async Notify&#125;);dispatch_time_t then = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10 * NSEC_PER_SEC));dispatch_group_wait(group, then);// Sync Notify</code></pre><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>调度信号量是传统计数信号量的有效实现。调度信号量只在调用线程需要被阻塞时才产生内核调用。dispatch_semaphore_signal创建并设置初始信号量，dispatch_semaphore_signal产生一个信号量并唤醒等待信号量的线程，dispatch_semaphore_wait等待阻塞线程直到有一个信号量消耗并恢复执行。</p><pre><code>    dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);    dispatch_time_t then = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC));    dispatch_async(queue, ^&#123;        // Task1        if (!dispatch_semaphore_wait(semaphore, then)) &#123;            NSLog(@&quot;YES 1&quot;);            sleep(1.0);            dispatch_semaphore_signal(semaphore);        &#125; else &#123;            NSLog(@&quot;NO 1&quot;);        &#125;    &#125;);    dispatch_async(queue, ^&#123;        // Task1        if (!dispatch_semaphore_wait(semaphore, then)) &#123;            NSLog(@&quot;YES 2&quot;);            sleep(1.0);            dispatch_semaphore_signal(semaphore);        &#125; else &#123;            NSLog(@&quot;NO 2&quot;);        &#125;    &#125;);    dispatch_async(queue, ^&#123;        // Task1        if (!dispatch_semaphore_wait(semaphore, then)) &#123;            NSLog(@&quot;YES 3&quot;);            sleep(1.0);            dispatch_semaphore_signal(semaphore);        &#125; else &#123;            NSLog(@&quot;NO 3&quot;);        &#125;    &#125;);</code></pre><h3 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h3><p>在线程同步技术中提到过内存屏障同步内存读写操作，GCD使用队列屏障在并行队列里创建一个同步机会，等待已提交的任务执行结束，禁止没提交的任务开始执行。使得执行队列屏障任务时不会有其他任务执行，一旦执行完成，并行队列恢复之前的状态和行为。GCD支持同步提交dispatch_barrier_sync和异步dispatch_barrier_async提交2种方式。</p><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1exc4di0ogrj20dc07kmxy.jpg"></p><pre><code>- (void)setSafeObject:(id)object forKey:(NSString *)key &#123;    key = [key copy];    dispatch_barrier_async(self.ioQueue, ^&#123;        if (key &amp;&amp; object) &#123;            [_dic setObject:object forKey:key];        &#125;    &#125;);    [key release];&#125;- (id)getSafeObjectForKey:(NSString *)key &#123;    __block id result = nil;    dispatch_sync(self.ioQueue, ^&#123;        result = [_dic objectForKey:key];    &#125;);    return result;&#125;</code></pre><hr><h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><ul><li><a href="http://www.anselz.com/2014/04/20/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3gcd%EF%BC%9Apart12/">深入了解GCD：Part 1/2</a></li><li><a href="http://www.anselz.com/2014/05/05/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3gcd%EF%BC%9Apart-22/">深入了解GCD：Part 2/2</a></li><li><a href="http://objccn.io/issue-2-1/#priority_inversion">并发编程：API 及挑战</a></li><li><a href="http://objccn.io/issue-2-3/">底层并发 API</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Runtime</title>
    <link href="/2015/10/07/2015-10-07-Runtime/"/>
    <url>/2015/10/07/2015-10-07-Runtime/</url>
    
    <content type="html"><![CDATA[<p><em>Message-Passing is the important part of Smalltalk (from which Objective-C derives), not objects. - Alan Kay</em></p><p>Runtime是一个实现Objc动态特性的C库(<a href="http://www.opensource.apple.com/source/objc4/">Apple</a>和<a href="http://ftp.gnu.org/gnu/objective-c.README">GNU</a>分别维护并开源自己的实现)，不像C++那样在编译期间就必须严格确定函数与对象之间的关系，Objc在运行期间才能确定具体的执行函数。可以说Runtime就是对象生成的规范(<strong>内存模型</strong>)和消息执行的判断(<strong>动态绑定</strong>)。程序运行的时候，类型系统可以动态删减，对象父类可以动态改变，对象类型可以动态改变，对象方法可以动态改变，对象方法可以动态删减，对象成员可以动态删减，对象能力可以动态自省。看起来好像一切，都能够改变，都可以改变，因为如此灵活，很多第三方库使用Runtime实现了强大的功能。但是，如果没有深刻的理解和经验的积累，语言的灵活性往往会成为程序的不稳定，所以在不得已的情况下请<strong>谨慎使用</strong>Runtime。</p><h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h4><pre><code>//objc_selector未给出定义typedef struct objc_selector *SEL;SEL sel1 = @selector(test);NSLog(@&quot;%s %p&quot;, (char *)sel1, sel1);SEL sel2 = sel_registerName([@&quot;test&quot; UTF8String]);NSLog(@&quot;%s %p&quot;, (char *)sel2, sel2);//输出如下:2015-10-05 17:20:26.195 Demo[1840:142119] test 0x7fff90c121402015-10-05 17:20:26.195 Demo[1840:142119] test 0x7fff90c12140</code></pre><p>编译Objective-C时，编译器根据方法名生成唯一一个表示该方法的ID。<strong>方法名与ID一一对应</strong>。所有方法的SEL构成一个集合，查找某个方法时只需要去找到对应SEL就可以。SEL指向的机构里面应该就存储着一个字符串。</p><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><pre><code>typedef struct objc_object *id;struct objc_object &#123;     Class isa;&#125;;</code></pre><p>id指向结构体objc_object，结构体有一个指向Class的指针isa，Runtime根据对象的isa找到它的类型信息。甚至可以这么说，一个结构体，不管里面有没有数据，有多少数据，只要<strong>第一个变量是Class指针</strong>且能通过它找到对应的类型信息，那么这个结构体就<strong>可以看做是一个对象</strong>(当然结构体的数据布局要和类型要求的一样才合法)。isa即是一个，代表抽象关系：一只猫是一个动物，一个对象是一个类。动物提供了猫的基本的信息(脑身腿脚)和抽象的行为(吃喝玩睡)。</p><h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><pre><code>typedef struct objc_class *Class;struct objc_class &#123;Class isa  OBJC_ISA_AVAILABILITY;#if !__OBJC2__    Class super_class                                        OBJC2_UNAVAILABLE;    const char *name                                         OBJC2_UNAVAILABLE;    long version                                             OBJC2_UNAVAILABLE;    long info                                                OBJC2_UNAVAILABLE;    long instance_size                                       OBJC2_UNAVAILABLE;    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;</code></pre><p>objc_class结构体里存储着父类结构体指针，名称，版本，实例大小，成员变量列表，方法列表，方法缓存，协议列表。因为objc_class结构体里还有isa，由此可见**类也是一个”对象”<strong>，Runtime称之为类对象，而类对象的抽象Runtime称之为</strong>元类(MetaClass)<strong>，而元类的抽象Runtime称之为</strong>根元类(Root Meta Class)**，他们都属于”对象”。对象其实是由类对象的实例方法－对象的类方法－创建出来的。</p><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ewradq1at2j20fa0fzdi5.jpg"></p><h4 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h4><pre><code>typedef struct objc_ivar *Ivar;struct objc_ivar &#123;    char *ivar_name                                          OBJC2_UNAVAILABLE;    char *ivar_type                                          OBJC2_UNAVAILABLE;    int ivar_offset                                          OBJC2_UNAVAILABLE;#ifdef __LP64__    int space                                                OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;//objc_classstruct objc_ivar_list &#123;    int ivar_count                                           OBJC2_UNAVAILABLE;#ifdef __LP64__    int space                                                OBJC2_UNAVAILABLE;#endif    /* variable length structure */    struct objc_ivar ivar_list[1]                            OBJC2_UNAVAILABLE;&#125; OBJC2_UNAVAILABLE;</code></pre><p>Ivar是一个指向objc_ivar结构体的指针，objc_ivar结构体存储着变量名、变量类型编码和变量在该类中的字节偏移量，objc_class结构体(也就是类对象)里的objc_ivar_list存储着该类所有的变量。</p><h4 id="健壮性实例变量-Non-Fragile-ivars"><a href="#健壮性实例变量-Non-Fragile-ivars" class="headerlink" title="健壮性实例变量(Non Fragile ivars)"></a>健壮性实例变量(Non Fragile ivars)</h4><p>Runtime目前有Modern和Legacy两个版本。Modern运行在OSX10.5之后和iOS的64位程序中，Legacy运行在OSX10.5之前的32位程序中。最大区别在于更改类的实例变量布局时，Legacy需要重新编译子类，Modern不需要。当一个类被编译时，该类会生成一个ivar布局，<strong>从isa开始</strong>依次根据实例变量大小产生位移，先是<strong>父类布局接着子类布局</strong>。访问变量的ivar地址＝对象地址＋ivar偏移字节。</p><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1ewragyao98j20cc0393yt.jpg"></p><p>但有个问题，当父类增加了ivar，原来的布局就出错了，在脆弱性实例变量(Fragile ivars)环境中不得不重新编译子类调整ivar布局。</p><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1ewrah4fqv3j20cf03c3yy.jpg"></p><p>在健壮性实例变量(Non Fragile ivars)环境中，编译器生成的子类实例变量布局跟以前一样，但程序启动后，如果Runtime检测到子类与父类布局有冲突便会调整子类布局。这样子类的成员变量就被保护起来了，以后不管父类变不变、怎么变都不会影响子类。<strong>访问变量的ivar地址＝对象地址＋基类大小+ivar偏移字节</strong>。</p><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1ewrahb72tgj20ci04rjs3.jpg"></p><h4 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h4><p>编译时，编译器将Property转换成Ivar，并且添加Setter和Getter。Runtime函数property_getAttributes能获取objc_property的名称和@encode类型字符串：</p><pre><code>//objc_property未给出定义typedef struct objc_property *objc_property_t;typedef struct &#123;    const char *name;           /**&lt; The name of the attribute */    const char *value;          /**&lt; The value of the attribute (usually empty) */&#125; objc_property_attribute_t;</code></pre><h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><pre><code>typedef struct objc_method *Method;struct objc_method &#123;    SEL method_name                                          OBJC2_UNAVAILABLE;    char *method_types                                       OBJC2_UNAVAILABLE;    IMP method_imp                                           OBJC2_UNAVAILABLE;&#125; OBJC2_UNAVAILABLE;//objc_classstruct objc_method_list &#123;    struct objc_method_list *obsolete                        OBJC2_UNAVAILABLE;    int method_count                                         OBJC2_UNAVAILABLE;#ifdef __LP64__    int space                                                OBJC2_UNAVAILABLE;#endif    /* variable length structure */    struct objc_method method_list[1]                        OBJC2_UNAVAILABLE;&#125;</code></pre><p>Method代表类中某个方法，它是一个指向objc_method结构体的指针。objc_method结构体存储着一个SEL类型的名字，一个参数和返回值的类型信息，一个真正实现方法的函数地址。objc_class结构体(也就是类对象)的objc_method_list存储着该类所有的方法。</p><h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h4><pre><code>typedef id (*IMP)(id, SEL, ...);</code></pre><p>IMP是一个编译器编译生成的函数指针，该函数包含一个接收消息的对象id，对应映射的名字SEL，方法参数，返回值id。<strong>Objc函数都会编译成C函数</strong>，ObjC对象接收消息变成普通C函数调用一样。</p><h4 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h4><pre><code>typedef struct objc_cache *Cache//objc_classstruct objc_cache &#123;    unsigned int mask /* total = mask + 1 */                 OBJC2_UNAVAILABLE;    unsigned int occupied                                    OBJC2_UNAVAILABLE;    Method buckets[1]                                        OBJC2_UNAVAILABLE;&#125; OBJC2_UNAVAILABLE;</code></pre><p>每次调用方法后，<strong>Runtime会更新cache，根据算法留住最常用的方法</strong>，以提高代码执行效率。mask表示总共缓冲槽(Cache Bucket)数目。occupied表示有效缓冲槽数目。buckets表示缓冲槽，数目可能不超过mask+1，某槽可能为NULL(表示这个槽无效)，有效槽们也可能是不连续的，缓冲槽可能会动态增加。</p><h4 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h4><pre><code>typedef struct objc_object *Protocol;//objc_classstruct objc_protocol_list &#123;    struct objc_protocol_list *next;    long count;    Protocol *list[1];&#125;;</code></pre><p>Protocol其实是一个对象结构体。类对象的Protocol列表里还有下一个列表的指针，从而让Protocol列表有了继承的能力。</p><h4 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h4><pre><code>typedef struct objc_category *Category;//Astruct objc_category &#123;    char *category_name                          OBJC2_UNAVAILABLE;    char *class_name                             OBJC2_UNAVAILABLE;    struct objc_method_list *instance_methods    OBJC2_UNAVAILABLE;    struct objc_method_list *class_methods       OBJC2_UNAVAILABLE;    struct objc_protocol_list *protocols         OBJC2_UNAVAILABLE;&#125; OBJC2_UNAVAILABLE;</code></pre><p>objc_category存储了分类名、扩展的类、实例方法、类方法和协议列表。分类的实例方法列表是类的实例方法列表的子集，分类的类方法列表是类的类方法列表的子集。不过在objc-runtime-new.h的定义中：</p><pre><code>//Bstruct category_t &#123;    const char *name;    classref_t cls;    struct method_list_t *instanceMethods;    struct method_list_t *classMethods;    struct protocol_list_t *protocols;    struct property_list_t *instanceProperties;&#125;;</code></pre><p>名字name是要扩展的类名而不是分类名。扩展的类cls<strong>不是在编译期而是在运行期</strong>赋值，由Runtime<strong>通过类名name找到对应的类</strong>。属性列表instanceProperties表示分类所有的properties，这就是可以增减关联变量的原因，不过分类的关联变量和类的实例变量是不一样的。</p><p>程序启动时，libSystem调用_objc_init(objc-os.mm)加载并初始化Runtime，map_images(objc-runtime-new.mm)加载map到内存，_read_images开始初始化map并加载所有Class，Protocol和Category(NSObject的+load在这时调用)，Category的实例方法加入Class的方法列表，Category的类方法加入Meta Class的方法列表。</p><h4 id="receiver-message"><a href="#receiver-message" class="headerlink" title="[receiver message]"></a>[receiver message]</h4><p>编译器会根据语义和返回值选择objc_msgSend, objc_msgSend_stret(<strong>st</strong>ruc <strong>ret</strong>urn), objc_msgSendSuper, objc_msgSendSuper_stret四个中的一个。<strong>传给父类</strong>的消息用带有<strong>Super</strong>的函数；<strong>返回值是数据结构不是简单类型</strong>的消息用带有<strong>stret</strong>的函数。objc_msgSend_fpret(<strong>f</strong>loating <strong>p</strong>oint <strong>ret</strong>urn)在i386平台代替返回类型为浮点数时使用的objc_msgSend，因为返回类型为浮点数的函数ABI(Application Binary Interface)与返回整型的函数ABI不兼容。</p><p>当objc_msgSend找到方法的实现后，Runtime将填充消息接收者receiver到第一位self，填充方法名字message到第二位_cmd，再依次将消息中所有参数按顺序填充。Objc发送的消息直到运行的时候才会动态绑定具体的实现：</p><ul><li>检测这个selector是否可以忽略。MacOSX有垃圾回收的话就不理会retain,release这些selector。</li><li>检测这个target如果是nil则忽略。Objc允许对nil发送任何消息且不Crash。</li><li>如果上面都通过便进入类中查询信息。先从cache里所有Method，找到相等selector匹配的IMP后执行。</li><li>如果cache没找到，再查询方法列表所有Method，找到相等selector匹配的IMP后执行。</li><li>如果方法列表没找到，再到父类以同样的过程找，直到找到NSObject为止。</li><li>如果还没找到，就进入动态方法解析和消息转发的机制。</li></ul><p><img src="http://ww3.sinaimg.cn/mw690/9460be12gw1ewraj25j6sg20980f4mx7.gif"></p><h4 id="消息转发机制"><a href="#消息转发机制" class="headerlink" title="消息转发机制"></a>消息转发机制</h4><p>不能确定对象是否能接收某个消息时，可以自省判断。</p><pre><code>if ([reciver respondsToSelector:@selector(message)]) &#123;    [reciver performSelector:@selector(message)];&#125;</code></pre><p>对象接收到无法接收的消息时，进入消息转发机制，告诉对象如何处理未知的消息。默认情况下，对象接收未知消息后，会触发NSObject的doesNotRecognizeSelector方法抛出异常导致程序崩溃。消息转发机制分为以下几步：</p><p><strong>动态方法解析</strong>  对象接收未知消息时，首先会根据消息的类型调用+resolveInstanceMethod:(实例方法)或者+resolveClassMethod:(类方法)。通过Runtime函数class_addMethod动态添加能够接收未知消息的方法到类里，来实现接收该未知消息(主要用在实现@dynamic)：</p><pre><code>void methodForUnknownMessage(id self, SEL _cmd) &#123;   NSLog(@&quot;%@, %p&quot;, self, _cmd);&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;    if ([NSStringFromSelector(sel) isEqualToString:@&quot;methodForUnknownMessage&quot;]) &#123;        class_addMethod(self.class, sel, (IMP)methodForUnknownMessage, &quot;@:&quot;);        return YES;    &#125;    return [super resolveInstanceMethod:sel];&#125;</code></pre><p><strong>备用接收对象</strong>  动态方法解析没能处理未知消息时，Runtime会继续调用forwardingTargetForSelector:返回备用接收对象去接收未知消息。</p><pre><code>- (id)forwardingTargetForSelector:(SEL)aSelector &#123;    if(aSelector == @selector(helperCanRespond:))&#123;        return helper;    &#125;    return [super forwardingTargetForSelector:aSelector];&#125;</code></pre><p><strong>完整转发</strong>  如果没有备用接受对象(返回nil)，Runtime会先用methodSignatureForSelector:获得未知消息的方法签名。</p><pre><code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;    NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];    if (!signature) &#123;        if ([Helper instancesRespondToSelector:aSelector]) &#123;            signature = [Helper instanceMethodSignatureForSelector:aSelector];        &#125;    &#125;    return signature;&#125;</code></pre><p>Runtime再创建一个封装了全部细节(消息的接收对象target、消息的名字selector和消息附带的参数)的NSInvocation，调用forwardInvocation:(其中可以修改消息内容实现复杂功能，比如修改参数等)选择转发给其它对象。处理完未知消息后NSInvocation会保留结果，Runtime会提取结果并发送给原始接收对象。NSObject的forwardInvocation:只是简单调用doesNotRecognizeSelector:引发异常导致崩溃。</p><pre><code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;    NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];    if (!signature) &#123;        if ([SUTRuntimeMethodHelper instancesRespondToSelector:aSelector]) &#123;            signature = [SUTRuntimeMethodHelper instanceMethodSignatureForSelector:aSelector];        &#125;    &#125;    return signature;&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;    if ([SUTRuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) &#123;        [anInvocation invokeWithTarget:_helper];    &#125;&#125;</code></pre><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ewrf8dufpfj20j60adjs5.jpg"></p><h4 id="消息转发和多继承"><a href="#消息转发和多继承" class="headerlink" title="消息转发和多继承"></a>消息转发和多继承</h4><p>转发可以允许一个对象<strong>通过依赖其他对象去处理未知消息</strong>，让该对象表面上有处理未知消息的能力。虽然转发能模拟多继承让对象“继承”其它对象的能力，但区别在于多继承会让对象越来越大，转发只是建立对象间联系。虽然转发类似于继承，但Runtime对两者自省判断不一样，respondsToSelector:和isKindOfClass:和conformsToProtocol:能识别继承，不识别转发。如果想让消息转发看起来像继承，需要重写这些方法。</p><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1ewrajxx1xsg20ag06pdfq.gif"></p><h4 id="Runtime的应用"><a href="#Runtime的应用" class="headerlink" title="Runtime的应用"></a>Runtime的应用</h4><p>Category Ass</p><p>Methods Swizzling</p><p>KVO</p><p>NSZombie</p><hr><h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><ul><li><a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/#jtss-tsina">Objective-C Runtime</a></li><li><a href="http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/">Objective-C Runtime 运行时系列</a></li><li><a href=http://chun.tips/blog/2014/11/05/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(1)%5Bnil%5D-self-and-super/>刨根问底Objective－C Runtime系列</a></li><li><a href="http://springox.w18.net/2015/09/03/objectivecruntime/">Objective-C与Runtime</a></li><li><a href="http://blog.sunnyxx.com/2015/09/13/class-ivar-layout/">Objective-C Class Ivar Layout 探索</a></li><li><a href="http://www.cocoachina.com/industry/20140106/7658.html">详解Objective-C runtime</a></li><li><a href="http://tech.meituan.com/DiveIntoMethodCache.html">深入理解Objective-C：方法缓存</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Thread 同步</title>
    <link href="/2015/10/04/2015-10-04-Thread-%E5%90%8C%E6%AD%A5/"/>
    <url>/2015/10/04/2015-10-04-Thread-%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="同步工具"><a href="#同步工具" class="headerlink" title="同步工具"></a>同步工具</h3><p>涉及线程安全时，一个好的设计是最好的保护。避免共享资源，减少线程交互，这样可以缩小线程间干扰，但是一个完全没有干扰的设计是不可能的，就需要使用同步技术来确保安全。</p><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>原子操作是同步<strong>简单数据类型</strong>一个非常简单的形式，其优势是<strong>不阻塞线程竞争</strong>。对于简单的操作，比如递增一个计数器，原子操作比锁更有性能优势。MacOSX和iOS包含了许多32位和64位执行基本的数学运算和逻辑运算(比较-交换，测试-设值，测试-清理)的原子操作(/usr/include/libkern/OSAtomic.h)。</p><h3 id="内存屏障和Volatile变量"><a href="#内存屏障和Volatile变量" class="headerlink" title="内存屏障和Volatile变量"></a>内存屏障和Volatile变量</h3><p>编译器优化代码时会<strong>重新排序汇编指令</strong>，来使处理器流水线执行指令以达到最佳性能。其中就可能对访问内存的指令进行(其认为可能不产生错误)重新排序，但事实上编译器几乎不可能检测到所有依赖内存的操作。如果看似独立的变量却是相互影响的，那么优化就可能打乱这些变量内存访问指令的顺序，导致潜在问题。</p><p><strong>内存屏障</strong>(Memory Barrier)是一个确保内存操作按照正确顺序工作、非阻塞的同步工具(OSMemoryBarrier系列函数)。内存屏障就像一个栅栏，处理器<strong>必须先完成障碍前所有的内存读取操作，才能执行屏障后的内存读取操作</strong>，这样内存屏障就能确保一个线程的内存操作总是按照预定顺序执行。</p><p><strong>Volatile</strong>是适用于独立变量的另一种内存限制形式。编译器通过把变量的值加载到寄存器(寄存器的访问速度比内存访问速度快)来实现优化。对于非线程竞争的变量不会有问题，反之则会。volatile变量会<strong>强制编译器每次使用变量时都从内存而非寄存器读取</strong>。如果一个变量的值有编译器无法检测更改的可能，那么可以把它声明为volatile。</p><p>内存屏障和volatile变量降低了编译器优化的程度，因此只在的确需要并确保正确的前提下谨慎使用。</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>锁是保护**临界区(Critical Section)**关键代码在同一个时间只被一个线程访问的最常用同步工具。MacOSX和iOS提供了常使用的锁：</p><p><strong>￼Mutex￼(互斥锁)</strong> 互斥锁扮演着资源保护屏障的角色。如果一个线程尝试获取一个已经被获取的互斥锁，那么该线程会阻塞一直到拥有互斥锁的线程释放互斥锁。如果有多个线程竞争获取互斥锁，每次只有一个能成功。</p><p><strong>Recursive lock(递归锁)</strong> 递归锁是互斥锁的变种。一个递归锁允许同一个线程释放前多次获取，其他线程保持阻塞直到拥有递归锁的线程释放同样次数后。递归锁用在递归语句中，也可用在同一线程的多个需要单独获取递归锁的方法里。</p><p><strong>Read-write lock(读写锁)</strong> 读写锁也被称为共享互斥锁。通常用在大规模操作(经常读偶尔写)保护数据中显着提高性能。一般多个线程可以同时读数据，当有另一个线程要写数据时，写线程阻塞直到所有读线程释放后再获取读写锁，进行写操作。当一个写线程在等待锁时，新来的读线程会阻塞直到写线程结束。系统只对POSIX线程支持读写锁。</p><p><strong>Distributed lock(分布锁)</strong> 一个分布锁提供进程间的互斥访问。和互斥锁不一样的是，分布锁不会阻塞进程或阻止进程运行。它只是简单地在尝试获取已被获取的分布锁时通知进程并让其自己决定如何处理。</p><p><strong>Spin lock(自旋锁)</strong> 一个自旋锁会反复查询其锁定条件直到条件成为真。自旋锁通常用在获取锁预期时间很小的多核系统里。这种情况下，切换上下文和更新线程数据通常比阻塞线程更有效率。系统因为自旋锁特性而没有提供支持，但是在一些特别的情况下很容易实现它。</p><p><strong>Double-checked lock(双重检查锁)</strong> 双重检查锁是一种，通过获锁前测试其标准来减少获取过程开销的尝试。因为双重检查锁是潜在不安全的，系统对该锁没有显式的实现并且不鼓励使用。</p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>条件是另一种当判断为真时允许线程间互相发送信号的同步工具。条件通常用来<strong>确认资源可以性或者确保任务以特定的顺序执行</strong>。当一个线程测试条件时，它阻塞直到其他线程显式地改变该条件为真。条件和互斥锁虽然都只允许多个线程中的一个通过，但互斥锁是随机选择，条件可以根据指定判断选择。系统用不同的技术对条件提供支持，条件的正确使用需要仔细思考。</p><h3 id="同步的开销和性能"><a href="#同步的开销和性能" class="headerlink" title="同步的开销和性能"></a>同步的开销和性能</h3><p>同步确保正确性，但同时会牺牲性能(甚至在无竞争时)。<strong>锁和原子操作通常使用内存屏障和内核级同步机制来确保关键代码被正确保护</strong>。同步虽然使关键代码安全，但过多同步的多线程程序和单线程程序相比反而可能会降低性能。安全和性能之间寻找平衡需要大量经验累积。在无竞争时互斥锁和原子操作的近似开销：</p><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1ewoxcqtqfcj21600jetjg.jpg"></p><h3 id="完全避免同步"><a href="#完全避免同步" class="headerlink" title="完全避免同步"></a>完全避免同步</h3><p>设计代码结构和数据结构来避免使用同步是很好的解决办法。如果整体设计导致特定资源的高竞争，可能设计本身就存在问题。实现并发最好的方法是减少并发任务之间的交互和依赖。如果每个任务在它自己的数据集上面操作，则不需要使用同步来保护这些数据。</p><h3 id="注意正确地同步"><a href="#注意正确地同步" class="headerlink" title="注意正确地同步"></a>注意正确地同步</h3><pre><code>// Code 1NSLock* arrayLock = GetArrayLock();NSMutableArray* myArray = GetSharedArray();id anObject;[arrayLock lock];anObject = [myArray objectAtIndex:0];[arrayLock unlock];[anObject doSomething];// Code 2￼￼NSLock* arrayLock = GetArrayLock();NSMutableArray* myArray = GetSharedArray();id anObject;[arrayLock lock];￼￼￼anObject = [myArray objectAtIndex:0];[anObject doSomething];[arrayLock unlock];￼￼// Code 3NSLock* arrayLock = GetArrayLock();NSMutableArray* myArray = GetSharedArray();id anObject;[arrayLock lock];anObject = [myArray objectAtIndex:0];[anObject retain];[arrayLock unlock];[anObject doSomething];</code></pre><p>Code1中anObject在执行doSomething时有野指针的可能。Code2中确保anObject有效，但是doSomething可能耗时很长，引起其他线程长时间等锁释放。Code3才是正确的写法。尽管这个示例很简单，但说明了非常重要的一点，当同步涉及到正确性时，不仅仅需要考虑问题的表面，内存管理和其他因素都有可能因为多线程而受到影响。此外，应该假设编译器总是出现最坏的情况。这种意识和警惕性，可以帮避免潜在问题，确保关键代码正确运行。</p><h3 id="正确使用Volatile"><a href="#正确使用Volatile" class="headerlink" title="正确使用Volatile"></a>正确使用Volatile</h3><p>使用一个互斥锁来保护一段关键代码后，并不还需要用volatile来保护关键代码段里的重要变量。一个互斥锁包含了内存屏障来确保内存读写操作能正确顺序执行。一个临界区里volatile变量会强制每次读写都在内存。这种同步组合在一些特定区域是必要的，但是同样会导致显著的性能损失。如果互斥锁已经可以保护变量，那么不使用volatile同样很重要。通常情况下，互斥锁和其他同步工具比volatile更好。</p><h3 id="使用原子操作"><a href="#使用原子操作" class="headerlink" title="使用原子操作"></a>使用原子操作</h3><p>原子操作以非阻塞方式执行某些简单类型的同步操作且避免锁的开销。尽管锁是同步线程很好的工具，但即使在无竞争状态下，获取一个锁都相对昂贵。相比而言，许多原子操作花费更少时间也能达到和锁一样的效果。原子操作(/usr/include/libkern/OSAtomic.h)在32位或64位处理器上执行简单的数学运算和逻辑运算，<strong>保证执行的操作在被影响内存再次读写前已经完成</strong>。可以使用原子操作和内存屏障组合使用，来保证多线程间内存正确同步。大部分原子操作行为都如其简单明了的函数名所理解那样。</p><p><img src="http://ww3.sinaimg.cn/mw690/9460be12gw1ewp9wuo4z4j20uq0j6gqz.jpg"></p><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1ewp9xuqolzj20um148tqq.jpg"></p><p><img src="http://ww1.sinaimg.cn/mw690/9460be12gw1ewp9yb4innj20uo0c6450.jpg"></p><h3 id="使用POSIX互斥锁"><a href="#使用POSIX互斥锁" class="headerlink" title="使用POSIX互斥锁"></a>使用POSIX互斥锁</h3><pre><code>pthread_mutex_t mutex;void MyInitFunction() &#123;    pthread_mutex_init(&amp;mutex， NULL);&#125;void MyLockingFunction() &#123;    pthread_mutex_lock(&amp;mutex);    // Do work    pthread_mutex_unlock(&amp;mutex);&#125;void MyReleaseFunction() &#123;    pthread_mutex_destroy(metex);&#125;</code></pre><p>以上代码只是简单地展示了POSIX线程互斥锁的过程，应该还要检查函数错误码并做适当处理。</p><h3 id="使用NSLock"><a href="#使用NSLock" class="headerlink" title="使用NSLock"></a>使用NSLock</h3><p><strong>Cocoa所有锁(包括NSLock)都是遵循NSLocking协议(定义了lock和unlock)来获取和释放</strong>。NSLock类除此之外还有tryLock(尝试获取一个锁并马上返回结果)和lockBeforeDate:(尝试获取一个锁，在规定时间内阻塞，最后返回结果)。</p><pre><code>NSLock *theLock = [[NSLock alloc] init];while (YES) &#123;    if ([theLock tryLock]) &#123;        // Do work        [theLock unlock];        break;    &#125;&#125;</code></pre><h3 id="使用-synchronized"><a href="#使用-synchronized" class="headerlink" title="使用@synchronized"></a>使用@synchronized</h3><p>在Objc代码中，@synchronized是一个非常方便创建互斥锁的方法。@synchronized做和其他互斥锁一样的工作，只是不需要直接创建锁对象。只需要简单使用任意Objc对象作为区别临界区的唯一标志符。</p><pre><code>@synchronized(token) &#123;    // Do work&#125;</code></pre><p>作为预防措施，@synchronized会<strong>隐式地添加一个异常处理代码</strong>起保护作用。该代码会在异常抛出时自动释放互斥锁。这意味着使用@synchronized就必须启用异常处理。如果不想要隐式异常处理代码带来的额外开销，应该考虑使用锁。</p><h3 id="使用NSRecursiveLock"><a href="#使用NSRecursiveLock" class="headerlink" title="使用NSRecursiveLock"></a>使用NSRecursiveLock</h3><p>NSRecursiveLock在同一线程多次获取不造成死锁。一个递归锁会自己统计成功获取次数。只有<strong>获取和释放操作次数平衡时，才可以真正被释放给其他线程获取</strong>。这类锁通常用在递归(也可以是类似的非递归)函数里防止递归造成线程阻塞。因为递归锁直到获取和释放操作平衡后才会被释放，而长时间持有一个锁将会导致其他线程阻塞直到递归完成，所以必须仔细权衡使用递归锁对性能的潜在影响。如果重构代码可以消除递归或者消除使用递归锁，那可能会有更好的性能。</p><pre><code>NSRecursiveLock *theLock = [[NSRecursiveLock alloc] init];void MyRecursiveFunction(int value) &#123;    [theLock lock];    if (value != 0) &#123;        --value;        MyRecursiveFunction(value);    &#125;    [theLock unlock];&#125;MyRecursiveFunction(5);</code></pre><h3 id="使用NSConditionLock"><a href="#使用NSConditionLock" class="headerlink" title="使用NSConditionLock"></a>使用NSConditionLock</h3><p>NSConditionLock是一个<strong>使用特定值来获取和释放</strong>的互斥锁，其行为和NSCondition有点类似，但实现非常不同。通常多线程用NSConditionLock实现以特定顺序执行任务，比如生产者消费者模式。NSConditionLock的获取和释放方法可以任意组合：lock和unlockWithCondition:，lockWhenCondition:和unlock 。</p><pre><code>id condLock = [[NSConditionLock alloc] initWithCondition:NO_DATA];// Thread Awhile(true) &#123;    [condLock lock];    // Add data to the queue    [condLock unlockWithCondition:HAS_DATA];&#125;// Thread Bwhile (true) &#123;    [condLock lockWhenCondition:HAS_DATA];    // Remove data from the queue    [condLock unlockWithCondition:(isEmpty ? NO_DATA : HAS_DATA)];    // Process the data locally&#125;</code></pre><h3 id="使用NSCondition"><a href="#使用NSCondition" class="headerlink" title="使用NSCondition"></a>使用NSCondition</h3><p>NSCondition类不仅提供了POSIX条件相同的语义，但又封装互斥锁和条件数据。<strong>可以像互斥锁一样获取和释放它，又可以像条件一样等待它</strong>。可以作为NSLock解决多线程之间的同步问题，但设计出NSCondition更重要的目的是解决线程之间的调度问题（也必须获取锁和释放锁）。某线程调用wait使其阻塞处于等待状态(<strong>其他线程就可以继续进入临界区。这和标准锁不同，标准锁被获取后无论什么情况，只要拥有线程没有释放，其他线程就无法进入临界区</strong>)，直到其他线程调用signal(唤醒多个等待线程中任意一个)或者broadcast(唤醒所有等待线程)才能继续运行。</p><pre><code>// Thread A[cocoaCondition lock];while (timeToDoWork &lt;= 0)    [cocoaCondition wait];timeToDoWork--;// Do work.[cocoaCondition unlock];// Thread B[cocoaCondition lock];timeToDoWork++;[cocoaCondition signal];[cocoaCondition unlock];</code></pre><h3 id="Cocoa多线程指南"><a href="#Cocoa多线程指南" class="headerlink" title="Cocoa多线程指南"></a>Cocoa多线程指南</h3><p>Immutable对象一般都是线程安全的，Mutable对象一般不是线程安全的，在多线程中需要同步。对于线程不安全的对象，只要保证同一时间只有一个线程使用，那么整个程序总体而言还是线程安全的。如果使用多线程绘画视图，绘画代码应放在NSView的lockFocusIfCanDraw和unlockFocus之间。</p><hr><h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><ul><li><a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW1">Synchronization</a></li><li><a href="http://southpeak.github.io/blog/2014/10/17/osatomicyuan-zi-cao-zuo/">OSAtomic原子操作</a></li><li><a href="http://www.cnblogs.com/kenshincui/p/3983982.html#synchronized">iOS开发系列–并行开发其实很容易</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Thread RunLoop</title>
    <link href="/2015/10/01/2015-10-01-Thread-Runloop/"/>
    <url>/2015/10/01/2015-10-01-Thread-Runloop/</url>
    
    <content type="html"><![CDATA[<p>一般一个线程一次只执行一个任务，执行完成后就会退出。如果需要一个机制，<strong>让线程能随时响应处理新的任务并长时间存在不退出</strong>，那么它就是RunLoop。</p><p>RunLoop就是一个<strong>不断调度工作和处理事件的事件处理循环</strong>，对事件处理过程进行了更好的抽象和封装，让客户代码不用关心底层琐碎的消息处理实现的同时，能够轻松动态地添加删除执行任务。目的是<strong>让线程有任务时忙碌工作，没任务时休眠节能</strong>。</p><p>RunLoop不是完全自动的。需要给线程设定代码在合适的时候启动并响应事件。Cocoa和Core Foundation都提供了runloop objects帮助配置和管理线程的RunLoop。每个线程都有关联的RunLoop，主线程启动时自动启动，子线程需要显式地启动。</p><h3 id="RunLoop剖析"><a href="#RunLoop剖析" class="headerlink" title="RunLoop剖析"></a>RunLoop剖析</h3><p>RunLoop接收两种不同输入事件：输入源(<em>input source</em>)传递异步事件，通常来自于其他线程或程序。定时源(<em>timer source</em>)传递同步事件，发生在特定时间或者重复的时间间隔。这两种源事件到达时都使用对应回调函数处理。</p><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1ewmvfz9j1nj20zc0gmgph.jpg"></p><h5 id="RunLoop模式"><a href="#RunLoop模式" class="headerlink" title="RunLoop模式"></a>RunLoop模式</h5><p>RunLoop<strong>模式</strong>是所有<strong>输入源定时源和观察者(CFRunLoopObserverRef实例)的集合</strong>。RunLoop每次只以某个模式运行，只有相关的源才会被监视、传递、处理事件，只有相关的观察者会被通知。否则，不相关的源不被监视，不相关观察者不被通知。Cocoa和Core Foundation定了一个默认模式和几个常用模式:</p><ul><li><strong>Default</strong>(NSDefaultRunLoopMode-Cocoa ， kCFRunLoopDefaultMode-CoreFoundation) 默认模式是最常用的模式。大部分时间你应该用这种模式启动RunLoop配置事件源。</li><li><strong>Connection</strong>(NSConnectionReplyMode-Cocoa) Cocoa用这个模式结合NSConnection对象来检测网络响应。你自己很少会用到这个模式。</li><li><strong>Modal</strong>(NSModalPanelRunLoopMode-Cocoa) Cocoa用这个模式辨别出模态界面想要的事件。</li><li><strong>Event tracking</strong>(NSEventTrackingRunLoopMode-Cocoa) Cocoa用这个模式在MouseDrag循环中和其他需要跟踪用户的界面循环中限制事件输入。</li><li><strong>Common modes</strong>(NSRunLoopCommonModes-Cocoa， kCFRunLoopCommonModes-CoreFoundation) 这是一个常用模式的可配置组合。关联常用模式就是关联组合里每个模式。Cocoa程序里常用模式默认包括default<br>，modal，event tracking。Core Foundation只有default。你可以用CFRunLoopAddCommonMode添加自定义模式到常用模式中。</li></ul><p>创建自定义模式<strong>必须添加至少一个事件源或者观察者</strong>，否则无效。使用特定模式可以过滤事件。比如大多数时间运行在默认模式上，模态界面运行在”Modal”模式下，此时只有模态模式相关信息能传递给线程。</p><h4 id="输入源"><a href="#输入源" class="headerlink" title="输入源"></a>输入源</h4><p>输入源异步发送消息到线程。事件来源取决于种类：<strong>端口源</strong>和<strong>自定义源</strong>。端口源监听程序相应端口，自定义源监听自定义事件源。区别在于如何触发：<strong>端口源由内核自动发送，自定义源则需要手动从其他线程发送</strong>。</p><h4 id="基于端口的输入源"><a href="#基于端口的输入源" class="headerlink" title="基于端口的输入源"></a>基于端口的输入源</h4><p>Cocoa不需要直接创建输入源，只需要创建NSPort对象并添加到RunLoop，它会自己处理创建和配置属于远。Core Foundation必须手动创建端口和输入源用CFMachPortRef，CFMessagePortRef，FSocketRef来创建合适的对象。</p><h4 id="自定义输入源"><a href="#自定义输入源" class="headerlink" title="自定义输入源"></a>自定义输入源</h4><p>创建自定义输入源使用CFRunLoopSourceRef，使用回调函数来进行配置。Core Foundation会在配置、处理、移除调用回调函数。</p><h4 id="Cocoa执行Selector源"><a href="#Cocoa执行Selector源" class="headerlink" title="Cocoa执行Selector源"></a>Cocoa执行Selector源</h4><p>Cocoa定义了允许你在任何线程执行selector的自定义输入源。和端口源一样，执行selector的请求在目标线程上串行排列，避免许多线程上多个方法一起运行引起的同步问题。不像端口源，<strong>一个selector源执行完后会自动从RunLoop里面移除</strong>。RunLoop每次循环处理所有(而不是一个)排列的selector的调用。</p><p><img src="http://ww3.sinaimg.cn/mw690/9460be12gw1ewmy1wfdtgj215w0go47f.jpg"></p><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ewmy2ah70rj21620lmwpj.jpg"></p><h4 id="RunLoop观察者"><a href="#RunLoop观察者" class="headerlink" title="RunLoop观察者"></a>RunLoop观察者</h4><pre><code>typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理Timer    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理Source    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop&#125;;</code></pre><p>通过使用Core Foundation注册为RunLoop的观察者来接收RunLoop行为的通知。和同步或异步事件发生时才触发的事件源不同，RunLoop观察者是在RunLoop本身运行的特定时刻候触发。和定时器类似，RunLoop观察者(在创建时指定)可以只用一次(RunLoop启动后，观察者会从RunLoop里移除)或循环使用。</p><h4 id="RunLoop事件队列"><a href="#RunLoop事件队列" class="headerlink" title="RunLoop事件队列"></a>RunLoop事件队列</h4><p><img src="http://ww3.sinaimg.cn/mw690/9460be12gw1ewn43j8dc5j21jy168tub.jpg"></p><h4 id="何时使用RunLoop"><a href="#何时使用RunLoop" class="headerlink" title="何时使用RunLoop"></a>何时使用RunLoop</h4><p>不需要在任何情况下都启动线程的RunLoop。比如，用线程处理一个预先定义的长时间(虽然长)任务就不用。RunLoop只在需更多交互时才需要：</p><ul><li>使用<strong>端口或自定义输入源</strong>来和其他线程<strong>通信</strong></li><li>使用线程的<strong>定时器</strong></li><li>Cocoa中使用任何<strong>performSelector</strong>方法</li><li>使线程<strong>周期性工作</strong></li></ul><h4 id="获得RunLoop对象"><a href="#获得RunLoop对象" class="headerlink" title="获得RunLoop对象"></a>获得RunLoop对象</h4><pre><code>//CocoaNSRunLoop cocoa = [NSRunLoop currentRunLoop];//Core FoundationCFRunLoopRef coreFoundation = CFRunLoopGetCurrent();</code></pre><h4 id="配置RunLoop"><a href="#配置RunLoop" class="headerlink" title="配置RunLoop"></a>配置RunLoop</h4><p>子线程运行RunLoop前，<strong>必须添加至少一个事件源</strong>。如果没有任何事件源，RunLoop会在启动之际立马退出。使用CFRunLoopAddObserver将观察者添加到RunLoop:</p><pre><code>- (void)threadMain &#123;    NSRunLoop* myRunLoop = [NSRunLoop currentRunLoop];    CFRunLoopObserverContext context = &#123;0， self， NULL， NULL， NULL&#125;;     CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault，kCFRunLoopAllActivities， YES， 0， &amp;myRunLoopObserver， &amp;context);    if (observer) &#123;        CFRunLoopRef cfLoop = [myRunLoop getCFRunLoop];        CFRunLoopAddObserver(cfLoop， observer， kCFRunLoopDefaultMode);    &#125;    [NSTimer scheduledTimerWithTimeInterval:0.1 target:self selector:@selector(doFireTimer:) userInfo:nil repeats:YES];    NSInteger loopCount = 10;    do &#123;        [myRunLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:1]];        loopCount--;            ￼￼￼￼    &#125; while (loopCount);&#125;</code></pre><h4 id="启动RunLoop"><a href="#启动RunLoop" class="headerlink" title="启动RunLoop"></a>启动RunLoop</h4><p><strong>无条件的</strong>启动RunLoop最简单的，但也最不推荐。因为这会使线程永久循环，失去控制。虽然可以添加或删除事件源，但是退出RunLoop的唯一方法是杀死它，也没有任何办法可以让RunLoop运行在自定义模式下。</p><p>更好的办法是用<strong>设置超时时间</strong>来启动RunLoop，这样RunLoop运作直到事件到达或者规定时间超时。如果是事件到达，RunLoop会传递消息给相应的处理方法然后退出。如果是规定时间超时直接退出。重新启动RunLoop进行下一次循环。</p><p><strong>特定模式</strong>启动RunLoop可以限制传递给RunLoop的事件源的类型。</p><pre><code>- (void)skeletonThreadMain &#123;    BOOL done = NO;    do &#123;        SInt32 result = CFRunLoopRunInMode(kCFRunLoopDefaultMode， 10， YES);        if ((result == kCFRunLoopRunStopped) || (result == kCFRunLoopRunFinished)) &#123;            done = YES;        &#125;    &#125; while (!done);&#125;</code></pre><h4 id="退出RunLoop"><a href="#退出RunLoop" class="headerlink" title="退出RunLoop"></a>退出RunLoop</h4><p>如果可以，尽量使用<strong>设置超时时</strong>，它让RunLoop退出前完成所有正常操作，包括通知观察者。<strong>显式停止</strong>(CFRunLoopStop)和超时结果相似，Runloop把所有剩余的通知发送出去再退出。与设置超时的不同的是，显式停止可以在无条件启动的Runloop里面使用。</p><p>尽管移除所有事件源也能导致RunLoop退出，但这并不可靠。系统会添加输入源来处理所需事件。因为移除事件源未必会考虑到这些输入源，可能导致无法退出RunLoop。</p><h4 id="线程安全和RunLoop对象"><a href="#线程安全和RunLoop对象" class="headerlink" title="线程安全和RunLoop对象"></a>线程安全和RunLoop对象</h4><p>线程的否安全取决于API操纵RunLoop的API。<strong>Core Foundation的函数是线程安全的</strong>，可以被任意线程调用。修改RunLoop配置并执行操作，<strong>最好在RunLoop所属线程完成</strong>。</p><p><strong>Cocoa的NSRunLoop则不具有线程安全性</strong>。 如果使用NSRunLoop来修改RunLoop，<strong>应该在RunLoop所属线程完成</strong>。给其他线程的RunLoop添加事件源可能导致崩溃或产生不可预知的行为。</p><h4 id="创建配置自定义输入源"><a href="#创建配置自定义输入源" class="headerlink" title="创建配置自定义输入源"></a>创建配置自定义输入源</h4><ul><li>输入源要处理的信息。</li><li>一个联系客户代码和输入源的调度方法。</li><li>一个处理客户代码请求的执行方法。</li><li>一个使输入源无效的取消方法。</li></ul><p><img src="http://ww1.sinaimg.cn/mw690/9460be12gw1ewntcgsy3aj20yk0f0whi.jpg"></p><p>主线程给子线程分发任务时，主线程给命令缓冲区填充命令和信息(主线程和拥有输入源的子线程必须同步访问命令缓冲区)，然后通知(会唤醒)子线程RunLoop开始工作，子线程RunLoop会调用输入源处理函数来执行命令缓冲区中相应的命令。</p><pre><code>// These are the CFRunLoopSourceRef callback functions.void RunLoopSourceScheduleRoutine (void *info， CFRunLoopRef rl， CFStringRef mode);void RunLoopSourceCancelRoutine (void *info， CFRunLoopRef rl， CFStringRef mode);void RunLoopSourcePerformRoutine (void *info);@interface RunLoopSource : NSObject- (instancetype)init;- (void)addToCurrentRunLoop;- (void)invalidate;- (void)sourceFired;- (void)addCommand:(NSInteger)command withData:(id)data;- (void)fireCommandsOnRunLoop:(CFRunLoopRef)runloop;@end@implementation RunLoopSource &#123;    CFRunLoopSourceRef _runLoopSource;    NSMutableArray *_commands;&#125;- (instancetype)init &#123;    self = [super init];    if (self) &#123;        CFRunLoopSourceContext context = &#123;            0，            (__bridge void *)(self)，            NULL，            NULL，            NULL，            NULL，            NULL，            RunLoopSourceScheduleRoutine，            RunLoopSourceCancelRoutine，            RunLoopSourcePerformRoutine        &#125;;        _runLoopSource = CFRunLoopSourceCreate(NULL， 0， &amp;context);        _commands = [[NSMutableArray alloc] init];    &#125;    return self;&#125;- (void)addToCurrentRunLoop &#123;    CFRunLoopRef runLoop = CFRunLoopGetCurrent();    CFRunLoopAddSource(runLoop， _runLoopSource， kCFRunLoopDefaultMode);&#125;- (void)invalidate &#123;&#125;- (void)sourceFired &#123;&#125;- (void)addCommand:(NSInteger)command withData:(id)data &#123;&#125;- (void)fireCommandsOnRunLoop:(CFRunLoopRef)runloop &#123;    CFRunLoopSourceSignal(_runLoopSource);    CFRunLoopWakeUp(runloop);&#125;@end@interface RunLoopContext : NSObject@property (readonly) CFRunLoopRef runLoop;@property (readonly) RunLoopSource* source;- (instancetype)initWithSource:(RunLoopSource *)src andLoop:(CFRunLoopRef)loop;@end@implementation RunLoopContext &#123;    RunLoopSource *_source;    CFRunLoopRef _runLoop;&#125;- (instancetype)initWithSource:(RunLoopSource *)src andLoop:(CFRunLoopRef)loop &#123;    self = [super init];    if (self) &#123;        _source = src;        _runLoop = loop;    &#125;    return self;&#125;@endvoid RunLoopSourceScheduleRoutine (void *info， CFRunLoopRef rl， CFStringRef mode) &#123;    id appDelegate = [[NSApplication sharedApplication] delegate];    RunLoopSource *obj = (__bridge RunLoopSource *)info;    RunLoopContext *theContext = [[RunLoopContext alloc] initWithSource:obj andLoop:rl];    [appDelegate performSelectorOnMainThread:@selector(registerSource:) withObject:theContext waitUntilDone:NO];&#125;void RunLoopSourceCancelRoutine (void *info， CFRunLoopRef rl， CFStringRef mode) &#123;    id del = [[NSApplication sharedApplication] delegate];    RunLoopSource *obj = (__bridge RunLoopSource *)info;    RunLoopContext *theContext = [[RunLoopContext alloc] initWithSource:obj andLoop:rl];    [del performSelectorOnMainThread:@selector(removeSource:) withObject:theContext waitUntilDone:YES];&#125;void RunLoopSourcePerformRoutine (void *info) &#123;    RunLoopSource *obj = (__bridge RunLoopSource *)info;    [obj sourceFired];&#125;</code></pre><h4 id="配置定时源"><a href="#配置定时源" class="headerlink" title="配置定时源"></a>配置定时源</h4><pre><code>//Cocoa- (void)addTimer &#123;    NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:0.3 target:self selector:@selector(timeFeedback:) userInfo:nil repeats:YES];    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];&#125;- (void)timeFeedback:(NSTimer *)timer &#123;&#125;//Core Foundation- (void)addTimer &#123;    CFRunLoopRef runLoop = CFRunLoopGetCurrent();    CFRunLoopTimerContext context = &#123;0， NULL， NULL， NULL， NULL&#125;;    CFRunLoopTimerRef timer = CFRunLoopTimerCreate(kCFAllocatorDefault， CFAbsoluteTimeGetCurrent()， 0.3， 0， 0， &amp;myCFTimerCallback， &amp;context);    CFRunLoopAddTimer(runLoop， timer， kCFRunLoopCommonModes);&#125;myCFTimerCallback(CFRunLoopTimerRef timer， void *info) &#123;&#125;</code></pre><hr><h4 id="RunLoop与线程"><a href="#RunLoop与线程" class="headerlink" title="RunLoop与线程"></a>RunLoop与线程</h4><p>Apple不允许直接创建RunLoop，只提供了两个自动获取API：CFRunLoopGetMain()和CFRunLoopGetCurrent()，大致如下：</p><pre><code>static CFMutableDictionaryRef loopsDic;static CFSpinLock_t loopsLock;CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123;    OSSpinLockLock(&amp;loopsLock);    if (!loopsDic) &#123;        loopsDic = CFDictionaryCreateMutable();        CFRunLoopRef mainLoop = _CFRunLoopCreate();        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);    &#125;    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));    if (!loop) &#123;        loop = _CFRunLoopCreate();        CFDictionarySetValue(loopsDic, thread, loop);        //注册回调在线程销毁的时候销毁RunLoop        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);    &#125;            OSSpinLockUnLock(&amp;loopsLock);    return loop;&#125;CFRunLoopRef CFRun    LoopGetMain() &#123;    return _CFRunLoopGet(pthread_main_thread_np());&#125;CFRunLoopRef CFRunLoopGetCurrent() &#123;    return _CFRunLoopGet(pthread_self());&#125;</code></pre><p>从代码看出，线程和RunLoop是一一对应的，映射关系保存在一个全局的Dictionary里。线程的RunLoop不自动创建，只有线程主动获取时才创建(第一次调用会确保主线程的RunLoop创建)，在对应线程销毁时销毁。</p><h4 id="RunLoop的Public-API"><a href="#RunLoop的Public-API" class="headerlink" title="RunLoop的Public API"></a>RunLoop的Public API</h4><p>CoreFoundation有5个类：</p><ul><li>CFRunLoopRef</li><li>CFRunLoopModeRef</li><li>CFRunLoopSourceRef</li><li>CFRunLoopTimerRef</li><li>CFRunLoopObserverRef</li></ul><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ewo1cebznfj20pa0ju75l.jpg"></p><p>一个RunLoop有若干个Mode，一个Mode有若干个Source|Timer|Observer(统称为<strong>Mode Item</strong>)。RunLoop每次只能运行在一个Mode中。切换Mode必须先退出运行，再以Mode进入。</p><p>CFRunLoopSourceRef分Source0和Source1：<strong>Source0只有一个回调函数</strong>。需要先CFRunLoopSourceSignal(source)标记带处理，再CFRunLoopWakeUp(runloop)唤醒runloop，以此实现自定义输入源。<strong>Source1有一个mach_port和一个回调函数</strong>，以此实现基于端口的输入源。</p><h4 id="RunLoop的Mode"><a href="#RunLoop的Mode" class="headerlink" title="RunLoop的Mode"></a>RunLoop的Mode</h4><p>CFRunLoopMode和CFRunLoop的大致结构：</p><pre><code>struct __CFRunLoopMode &#123;    CFStringRef _name;            // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;    CFMutableSetRef _sources0;    // Set&lt;CFRunLoopSourceRef&gt;    CFMutableSetRef _sources1;    // Set&lt;CFRunLoopSourceRef&gt;    CFMutableArrayRef _observers; // Array&lt;CFRunLoopObserverRef&gt;    CFMutableArrayRef _timers;    // Array&lt;CFRunLoopTimerRef&gt;    ...&#125;; struct __CFRunLoop &#123;    CFMutableSetRef _commonModes;     // Set&lt;CFStringRef&gt;    CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt;    CFRunLoopModeRef _currentMode;    // Current Runloop Mode    CFMutableSetRef _modes;           // Set&lt;CFRunLoopModeRef&gt;    ...&#125;;</code></pre><p>通过将Mode的_name添加到RunLoop的_commonModes中使其成为commonMode。<strong>当RunLoop内容变化时，RunLoop都会自动将_commonModeItems里的ModeItem同步到所有Common Mode里</strong>。</p><h4 id="App启动后RunLoop的状态："><a href="#App启动后RunLoop的状态：" class="headerlink" title="App启动后RunLoop的状态："></a>App启动后RunLoop的状态：</h4><pre><code>CFRunLoop &#123;    current mode = kCFRunLoopDefaultMode    common modes = &#123;        UITrackingRunLoopMode        kCFRunLoopDefaultMode    &#125;     common mode items = &#123;         // source0 (manual)        CFRunLoopSource &#123;order =-1, &#123;            callout = _UIApplicationHandleEventQueue&#125;&#125;        CFRunLoopSource &#123;order =-1, &#123;            callout = PurpleEventSignalCallback &#125;&#125;        CFRunLoopSource &#123;order = 0, &#123;            callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;         // source1 (mach port)        CFRunLoopSource &#123;order = 0,  &#123;port = 17923&#125;&#125;        CFRunLoopSource &#123;order = 0,  &#123;port = 12039&#125;&#125;        CFRunLoopSource &#123;order = 0,  &#123;port = 16647&#125;&#125;        CFRunLoopSource &#123;order =-1, &#123;            callout = PurpleEventCallback&#125;&#125;        CFRunLoopSource &#123;order = 0, &#123;port = 2407,            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;        CFRunLoopSource &#123;order = 0, &#123;port = 1c03,            callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;        CFRunLoopSource &#123;order = 0, &#123;port = 1b03,            callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;        CFRunLoopSource &#123;order = 1, &#123;port = 1903,            callout = __IOMIGMachPortPortCallback&#125;&#125;         // Ovserver        CFRunLoopObserver &#123;order = -2147483647, activities = 0x1, // Entry            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;        CFRunLoopObserver &#123;order = 0, activities = 0x20,          // BeforeWaiting            callout = _UIGestureRecognizerUpdateObserver&#125;        CFRunLoopObserver &#123;order = 1999000, activities = 0xa0,    // BeforeWaiting | Exit            callout = _afterCACommitHandler&#125;        CFRunLoopObserver &#123;order = 2000000, activities = 0xa0,    // BeforeWaiting | Exit            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;        CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;         // Timer        CFRunLoopTimer &#123;firing = No, interval = 3.1536e+09, tolerance = 0,            next fire date = 453098071 (-4421.76019 @ 96223387169499),            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;    &#125;,     modes ＝ &#123;        CFRunLoopMode  &#123;            sources0 =  &#123; /* same as &#39;common mode items&#39; */ &#125;,            sources1 =  &#123; /* same as &#39;common mode items&#39; */ &#125;,            observers = &#123; /* same as &#39;common mode items&#39; */ &#125;,            timers =    &#123; /* same as &#39;common mode items&#39; */ &#125;,        &#125;,         CFRunLoopMode  &#123;            sources0 =  &#123; /* same as &#39;common mode items&#39; */ &#125;,            sources1 =  &#123; /* same as &#39;common mode items&#39; */ &#125;,            observers = &#123; /* same as &#39;common mode items&#39; */ &#125;,            timers =    &#123; /* same as &#39;common mode items&#39; */ &#125;,        &#125;,         CFRunLoopMode  &#123;            sources0 = &#123;                CFRunLoopSource &#123;order = 0, &#123;                    callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;            &#125;,            sources1 = (null),            observers = &#123;                CFRunLoopObserver &gt;&#123;activities = 0xa0, order = 2000000,                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;            )&#125;,            timers = (null),        &#125;,         CFRunLoopMode  &#123;            sources0 = &#123;                CFRunLoopSource &#123;order = -1, &#123;                    callout = PurpleEventSignalCallback&#125;&#125;            &#125;,            sources1 = &#123;                CFRunLoopSource &#123;order = -1, &#123;                    callout = PurpleEventCallback&#125;&#125;            &#125;,            observers = (null),            timers = (null),        &#125;,                CFRunLoopMode  &#123;            sources0 = (null),            sources1 = (null),            observers = (null),            timers = (null),        &#125;    &#125;&#125;</code></pre><h4 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h4><p>App启动后，Apple在主线程RunLoop里注册了两个Observer，其回调都是_wrapRunLoopWithAutoreleasePoolHandler()。第一个Observer监视Entry(即将进入Loop)，其回调内会调用_objc_autoreleasePoolPush()创建自动释放池。<strong>其优先级最高，保证创建行为发生在其他所有回调之前</strong>。第二个Observer监视了两个事件：BeforeWaiting(即将进入休眠)时调用_objc_autoreleasePoolPop()和_objc_autoreleasePoolPush()从而释放旧池创建新池；Exit(即将退出Loop) 时调用_objc_autoreleasePoolPop()来释放旧池。<strong>其优先级最低，保证释放行为生在其他所有回调之后</strong>。RunLoop处理事件过程中的代码被自动释放池的创建和释放环绕着，所以不会出现内存泄漏。</p><h4 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h4><p>App启动后，Apple在主线程RunLoop里注册了一个Source1(基于mach port的)用来接收系统事件，其回调函数为__IOHIDEventSystemClientQueueCallback()。当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先IOKit.framework生成一个IOHIDEvent事件，发送给SpringBoard(接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种Event)，SpringBoard再用mach port转发给对应的App。随后该Source1会被触发并回调_UIApplicationHandleEventQueue()，把IOHIDEvent处理封装成UIEvent分发给UIWindow等。</p><h4 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h4><p>当_UIApplicationHandleEventQueue()识别了一个手势时，其首先会调用Cancel打断当前touchesBegin/Move/End，随后将对应UIGestureRecognizer标记为待处理。App启动后，Apple在主线程RunLoop注册了一个Observer监测BeforeWaiting(即将进入休眠)，其回调内会调用_UIGestureRecognizerUpdateObserver()获取所有待处理的 GestureRecognizer并执行回调。</p><h4 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h4><p>当在操作UI(改变Frame、更新UIView/CALayer层次)或者手动调用UIView/CALayer的setNeedsLayout/setNeedsDisplay后，这个<strong>UIView/CALayer被标记为待处理，并被提交到一个全局容器</strong>。App启动后，Apple在主线程RunLoop里注册了一个Observer监听BeforeWaiting(即将进入休眠)和Exit(即将退出Loop)，其回调内会调用_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()去遍历所有待处理的UIView/CAlayer并执行绘制和调整，最后更新UI界面。</p><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>NSTimer即(toll-free bridged)CFRunLoopTimerRef。一个NSTimer注册到RunLoop时会在未来重复时间点提前注册好事件，<strong>不过为了节省资源，并不会非常准确触发。Timer有个属性Tolerance(宽容度)表示时间点容许的最大误差</strong>。如果某个时间点被错过了，比如在执行一个长任务，那么对应的回调也会跳过去，不会延后执行。CADisplayLink是一个和屏幕刷新率一致的定时器(和NSTimer不一样，其用Source实现，且原理更复杂）。如果两次屏幕刷新之间在执行一个长任务，那么其中一帧就被跳过(和NSTimer相似)，造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会有所察觉。Facebook开源的AsyncDisplayLink(内部也用到RunLoop)就是为了解决界面卡顿的问题。</p><h4 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h4><p>调用performSelector系列方法时，实际都会创建一个Timer并添加到对应线程RunLoop中，如果对应线程没有RunLoop则该方法会失效。</p><h4 id="关于GCD"><a href="#关于GCD" class="headerlink" title="关于GCD"></a>关于GCD</h4><p>实际上RunLoop底层也会用到GCD，比如RunLoop是用dispatch_source_t实现的Timer。同时GCD的某些接口也用到RunLoop，例如dispatch_async()。当调用dispatch_async(dispatch_get_main_queue(), block)时，libDispatch会向主线程RunLoop发送消息，主线程RunLoop被唤醒并从消息中取得block，在回调__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()里执行这个block。但仅限于dispatch到主线程，dispatch到其他线程仍然是由libDispatch处理的。</p><hr><h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><ul><li><a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1">Run Loops</a></li><li><a href="http://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Thread 基本概念</title>
    <link href="/2015/09/26/2015-09-26-Thread-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2015/09/26/2015-09-26-Thread-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h4 id="线程是什么"><a href="#线程是什么" class="headerlink" title="线程是什么"></a>线程是什么</h4><p>线程是一个在程序里实现多个执行路径的相对轻量级的方法。系统根据各个程序的需要分配不同的时间片段，让程序之间并行执行。程序内部存在至少一个线程，线程之间又同时执行不同的任务。系统本身直接管理这些线程，在可用的执行单元上运行。</p><p>一个线程是用来管理代码执行的<strong>内核级和程序级数据结构的组合</strong>。内核级数据用来协助完成线程调度和抢占式执行。程序级数据包括函数调用需要的堆栈和线程属性和状态。</p><p>单线程程序只有一个执行线程，该线程起止于main。多线程程序开始有一个，需要的时候创建额外的线程。每个新线程有它自己的执行入口。多线程有2个优点：</p><ul><li>多线程可以提高程序的感知响应。</li><li>多个线程可以提高程序在多核系统上的实时性能。</li></ul><p>如果只有一个线程，那么它要做所有的事情：响应事件，更新界面，完成其他计算来实现程序功能等等。单线程的问题是，每个时刻只能做一件事。当程序需要执行一个长时间任务时会发生什么呢？程序会停止响应用户操作来更新界面。如果任务很长，用户会以为程序死了并强制退出。但是，如果把计算任务移到另一个线程去做，那么主线程就很轻松地响应用户操作。</p><p>多核电脑能够让执行不同任务的线程在不同的执行单元上同时运行，使得程序在给定的时间内完成更多的任务成为可能。</p><p>当然，线程也不总是解决程序性能的万能药。线程带来好处的同时也带来潜在的问题。程序有多个执行路径会增加代码复杂度。每个线程都需要和其他线程协同，来防止信息状态被破坏。因为同一程序的线程共享同一内存地址空间，都可以访问所有的数据。如果两个线程同时操作同一个数据，就有可能破坏该数据。</p><h4 id="线程术语"><a href="#线程术语" class="headerlink" title="线程术语"></a>线程术语</h4><ul><li>线程(thread)表示一个<strong>独立的代码执行路径</strong>。</li><li>进程(process)表示一个<strong>正在运行的程序</strong>，它可以包含多个线程。</li><li>任务(task)表示一个<strong>需要运行的任务的抽象</strong>。</li></ul><h4 id="线程备选方案"><a href="#线程备选方案" class="headerlink" title="线程备选方案"></a>线程备选方案</h4><p>创建线程给代码带来了不确定性，因为线程相对底层和复杂，如果不完全理解，就很容易遇到同步问题和效率问题。需要考虑清楚是否真的需要多线程。</p><ul><li><strong>Opertation objects</strong> 10.5引入，执行对象是对一个通常在另一个线程执行的任务的封装。这个封装隐藏了执行任务的线程管理细节，更专注于任务本身。通常执行对象和执行队列对象(Operation Queue Object)一起配合使用，执行队列在一个或多个线程上管理这些执行对象的运行。</li><li><strong>Grand Central Dsipatch(GCD)</strong> 10.6引入，用中央调度能专注于任务而不是线程管理。有了GCD，定义要执行的任务，然后加入到负责调度合适线程来执行任务的工作队列里。工作队列相比手动管理，会权衡可用执行单元数量和当前运行状态来更有效地执行任务。</li><li><strong>Idle-time notifications</strong> 对于时间短又不急的任务，空闲时间通知会在程序不忙的时候执行任务。Cocoa用NSNotificationQueue对象支持，通过向NSNotificationQueue默认对象发送包含NSPostWhenIdle选项的通知来请求。NSNotificationQueue会延迟发送通知直到程序空闲。</li><li><strong>Asynchronous functions</strong> 系统接口有很多提供原子同步的异步函数。这些API或者使用系统后台进程或者创建自定义线程来执行任务并返回结果。(实际怎么实现无关要紧，因为它与应用代码隔离。)当设计程序时，查查提供异步功能的函数，考虑用它们代替创建一个新线程同步执行相同的任务。</li><li><strong>Timers</strong> 在主线程用定时器执行不重要到用线程但又需要定期执行的周期性任务。</li><li><strong>Separate processes</strong> 进程虽然比线程重量级，但是当任务与程序无关的时候，创建新的进程来执行或许会有用。如果一个任务需要大量内存或者更高权限时也许用进程实现更好。</li></ul><h2 id="线程支持"><a href="#线程支持" class="headerlink" title="线程支持"></a>线程支持</h2><h4 id="线程包"><a href="#线程包" class="headerlink" title="线程包"></a>线程包</h4><p>多线程的底层实现机制是Mach，但是很少直接使用，而是更多使用方便的POSIX API或者他的衍生方法。Mach没有提供线程所有特征，但是至少包括抢占式的执行模型和调度线程的能力，所以它们相互独立。</p><ul><li><strong>Cocoa threads</strong> Cocoa用NSThreads实现线程。Cocoa也给NSObject添加了方法用新线程或者已经存在的线程来执行代码。</li><li><strong>POSIX threads</strong> POSIX线程为创建线程提供了标准C接口。如果不是写一个Cocoa程序，这是创建线程最好的方法。POSIX接口对配置线程来说相对简单又足够灵活。</li><li><strong>Multiprocessing Services</strong> 略</li></ul><p>应用层上，和其他平台一样，所有线程的行为本质上都是一样的。启动后就进入三个状态的任何一个：运行(running)、就绪(ready)、阻塞(blocked)。如果一个线程当前没有运行,那么它不是处于阻塞，就是等待外部输入，或者已经准备就绪等待分配CPU。线程持续在这三个状态之间切换，直到它运行完或者被终止。</p><p>创建新线程时，必须指定入口函数。当函数返回或者中断时，线程永久停止并被系统回收。因为创建线程需要一些时间和内存，是相对比较昂贵的操作，建议在入口函数里多做些任务或者启动一个Runloop进行持久性的任务。</p><h4 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h4><p>Runloop是管理异步到达线程的事件的基本。Runloop为线程监测一个或多个事件源。当事件到达时，系统唤醒线程并把事件分发到Runloop，Runloop再分配给指定的处理方法进行处理。如果没有事件存在或都被处理过，Runloop又会把线程置于休眠状态。</p><p>Runloop使用最小资源来创建较长时间运行的线程。因为在没有事件处理时线程会被Runloop置于休眠状态，它没有消耗CPU周期轮询，可以让处理器休眠进而节省电源。</p><p>配置Runloop，启动线程，获得Runloop对象，匹配好事件处理方法，告诉Runloop对象开始运行。Cocoa程序的主线程自动配好，子线程必须自己配制。</p><h4 id="同步工具"><a href="#同步工具" class="headerlink" title="同步工具"></a>同步工具</h4><p>线程编程危险之一就是多线程之间的资源争夺。多线程同一时间使用同一资源就会出现问题。解决方法之一就是，消除共享资源，确保每个线程都只有它能够操作的资源。但完全保持独立是不可行的，所以不得不通过锁，条件，原子操作等其他技术来同步资源访问。</p><p>锁提供了同一时刻只有一个线程能执行代码的保护。最普遍的是互斥锁(mutual exclusion)，即通常所说的”mutex”。当一个线程试图获取一个已经被其他线程占据的互斥锁时，他会被阻塞直到该锁被释放。</p><p>条件确保了程序多线程任务执行的顺序。一个条件是一个看门人，阻塞对应线程直到条件为真。(Operation之间的依赖关系的顺序确定了执行顺训，这和Condition很像。)</p><p>原子操作是另一种保护并同步数据访问的方法。当执行标量数据类型的数学运算或者逻辑运算时，原子操作是一种轻量级的方法。原子操作用特殊的硬件指令来确保对一个变量的改变在另一个线程访问它之前就已经完成。</p><h4 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h4><p>好的设计应最大限度减少线程间通信量，不过不可避免完全没有通信。(线程的任务就是分担程序工作，如果不通信去使用这些工作结果，那程序有什么意义呢?)因为线程共享相同的进程空间，意味着有大量的可选项来进行通信。</p><ul><li><strong>Direct messaging</strong> Cocoa程序支持直接某线程在任何线程上执行方法。因为这些方法在目标线程的上下文中等待被执行，所以这个机制执行的方法在目标线程上被串行执行。</li><li><strong>Global variables, shared memory, and objects</strong> 另一个简单的线程间通信的机制是全局变量，共享对象，或者共享内存块。虽然共享变量又快又简单，但是相比发送消息而言还是更容易引起问题。共享变量必须用同步机制严格保护访问来确保代码正确执行，如果做得不好，可能引起条件竞争，数据损坏，或者崩溃。</li><li><strong>Conditions</strong> 条件控制何时执行一段特定代码。可以把条件看成看门人，只有在条件为真时让线程运行。</li><li><strong>Runloop sources</strong> 设置一个自定义Runloop源用来在线程里接收特定的程序信号。因为它是事件驱动，当没事时让线程休眠节省电源。</li><li><strong>Ports and sockets</strong> 基于端口的通信是线程间通信中又精确又可靠的方法。更重要的是，端口和套接字可以用来和外部对象(其他进程和服务)通信。为了考虑电源，端口被实现为Runloop事件源，所以端口上没有数据等待的时候线程会休眠。</li><li><strong>Message queues</strong> 传统多处理队列定义了一个先进先出的队列，用来管理进出数据。虽然它简单又方便，但是和其他方法比起来不够高效。</li><li><strong>Cocoa distributed objects</strong> 略</li></ul><h2 id="设计要点"><a href="#设计要点" class="headerlink" title="设计要点"></a>设计要点</h2><h4 id="避免显式创建线程"><a href="#避免显式创建线程" class="headerlink" title="避免显式创建线程"></a>避免显式创建线程</h4><p>尽量避免手动编写线程，这样容易容易出错，应该尽量使用隐式创建线程的API。可以考虑使用异步API，GCD或者操作对象实现多线程机制。这些技术背后做了相关工作，并保证无误。其中GCD和NSOperation被设计用来管理线程，比手动实现根据当前负载调整活动线程的数量更高效。</p><h4 id="保持线程合理的忙碌"><a href="#保持线程合理的忙碌" class="headerlink" title="保持线程合理的忙碌"></a>保持线程合理的忙碌</h4><p>如果准备手动创建和管理线程，因为线程消耗系统的宝贵资源，应该尽量确保分配的线程运行适当时间做了很多事。同时，不要害怕终止那些消耗了大量空闲时间的线程。线程占用一定量的内存，所以释放空闲线程不但减少程序内存，而且释放更多物理内存给系统其他进程使用。</p><h4 id="避免共享数据结构"><a href="#避免共享数据结构" class="headerlink" title="避免共享数据结构"></a>避免共享数据结构</h4><p>避免造成线程访问资源冲突最简单有效的方法是，给每个线程一份独立的数据副本。最小化线程间通信和资源竞争时并行代码会最有效执行。</p><p>即使代码里面所有共享资源的地方都有保护，代码依然可能语义不安全。比如，一个特定的顺序会修改共享数据结构。将代码改为原子方式，来弥补多线程可能产生的性能损耗。把避免资源争竞争放在首位考虑，通常能得到简单的设计和高效的性能。</p><h4 id="线程和用户界面"><a href="#线程和用户界面" class="headerlink" title="线程和用户界面"></a>线程和用户界面</h4><p>如果程序有用户界面，建议在主线程里接收界面事件和更新界面。这有助于避免处理界面事件和更新界面之间的同步问题。有些框架，例如Cocoa，通常需要这样的行为，但即使不需要的框架，这么做也简化了程序用户界面的逻辑管理。</p><p>也有在子线程里执行图形任务更好的列外。比如，可以用子线程来创建和处理图片或者其他图形相关计算。这么做通常会地提高性能。如果不确定一个任务是否和图像处理相关，那么就在主线程上执行它。</p><h4 id="注意线程退出时的行为"><a href="#注意线程退出时的行为" class="headerlink" title="注意线程退出时的行为"></a>注意线程退出时的行为</h4><p>进程一直运行直到所有非分离线程都退出为止。默认只有主线程是以非分离方式创建，但也可以用同样方式创建子线程。当要退出程序时，立即中断所有分离线程通常被认为是合适的，因为分离线程所做的工作是可选的。如果程序使用后台线程来保存数据到硬盘或者其他关键工作，那么可以把这些线程创建为非分离的，来保证退出程序时不丢失数据。</p><p>以非分离方式(又称为可连接)创建线程需要做一些额外工作。因为大部分上层线程封装技术默认不创建可连接线程。必须使用POSIX API来创建。此外，还必须在程序主线程里添加代码，在非分离线程最终退出的时连接它们。</p><p>如果是Cocoa程序，也可以通过使用applicationShouldTerminate:的代理方法来延迟程序的终止直到一段时间后或者取消。当延迟终止时，需要等到所有关键线程都完成任务后，再调用replyToApplicationShouldTerminate:方法。</p><h4 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h4><p>当一个异常抛出时，异常的处理机制根据于当前调用堆栈来执行必要的清理工作。因为每个线程都有它自己的调用堆栈，所以每个线程都负责捕获自己的异常。如果子线程捕获一个抛出的异常失败，那么主线程也同样捕获该异常失败：它所属的进程就会终止。不能抛出一个不能被捕获的异常给另一个线程去处理。</p><p>如果需要通知另一个线程(比如主线程)在此线程中的一个异常情况，应该先捕捉该异常，并简单地发送消息到其他线程告知发生了什么事。根据设计和意图，捕获异常的线程可以继续运行(如果可能的话)，等待命令，或者干脆退出。</p><p><code>注意：在Cocoa里面，一个NSException对象是一个自包含对象，可以被从一个线程传递到另外一个线程。</code></p><p>在一些情况下，异常处理被自动创建。比如@synchronized包含了一个隐式的异常处理。</p><h4 id="干净地终止线程"><a href="#干净地终止线程" class="headerlink" title="干净地终止线程"></a>干净地终止线程</h4><p>线程自然退出的最好方式是让它达到入口结束点。虽然有不少函数可以立即终止线程，但是这些函数应作为最后的手段。在线程达到它自然结束点之前终止它，会妨碍它完成清理。如果线程已经分配了内存，打开了文件，或者获取了其他类型资源，可能没法回收这些资源，造成内存泄漏或者其他潜在的问题。</p><h4 id="库的线程安全"><a href="#库的线程安全" class="headerlink" title="库的线程安全"></a>库的线程安全</h4><p>虽然程序开发者能控制是否多线程，但库的开发者不能控制。当开发库时，必须假设库的调用程序是多线程，或者是和否可以随时切换。因此应该总是在临界区使用锁功能。</p><p>对库开发者而言，只当程序是多线程时才创建锁是不明智的。如果代码中某些部分需要被锁定，在库早期开发时就应该创建锁对象来使用，最好是库有显式的初始化并在其中创建锁。虽然也可以使用静态库的初始化函数来创建这些锁，但是仅当没有其他方法时才应该这样做。执行初始化函数会延长加载库的时间，且可能对程序性能造成不利影响。</p><p><code>注意：库里保持锁的占据和释放平衡。应该依赖库里加锁保护数据结构，而不是依赖库外的调用代码，来提供线程安全。</code></p><p>开发Cocoa的类库，在NSWillBecomeMultiThreadedNotification注册一个观察者，程序变成多线程的时候收到通知。不过不要过于依赖它，因为可能在类库被调用之前已经发出了。</p><hr><h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><ul><li><a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/Multithreading/AboutThreads/AboutThreads.html#//apple_ref/doc/uid/10000057i-CH6-SW2">About Threaded Programming</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS Programming Guide(2nd) 读书笔记</title>
    <link href="/2015/09/19/2015-09-19-iOS-Programming-Guide-2nd-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2015/09/19/2015-09-19-iOS-Programming-Guide-2nd-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>这是一本iOS4的入门书籍，有一些概念过时，有一些概念没有，但不妨碍学习一些最基本的概念。从头学起，从最基础学起。</p><h2 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h2><h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h4><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ewgybn3huqj21ge0s2n6b.jpg"></p><h4 id="Xib"><a href="#Xib" class="headerlink" title="Xib"></a>Xib</h4><p>A XIB file is an XML representation of the archived objects. When you build a project, the XIB file is compiled into a NIB file. Developers manipulate XIB files (they’re easier to work with), and applications use NIB files (they’re smaller and easier to parse). When you build an application, the compiled NIB file is copied into the application’s bundle. An iOS application is really <strong>a directory containing the executable and any resources the executable uses</strong>. We refer to this directory as the <strong>bundle</strong>. When your application reads in the NIB file, the objects in the archive are brought to life. A complex application can have many NIB files that are read in as they are needed.</p><h4 id="Deploy-an-app"><a href="#Deploy-an-app" class="headerlink" title="Deploy an app"></a>Deploy an app</h4><p>To install an application on your development device, you need a developer certificate from Apple. Developer certificates are issued to registered iOS Developers who have paid the developer fee. <strong>This certificate grants you the ability to sign your code</strong>, which allows it to run on a device. Without a valid certificate, devices will not run your application.</p><h4 id="Developer-Certificate"><a href="#Developer-Certificate" class="headerlink" title="Developer Certificate"></a>Developer Certificate</h4><p>This certificate file is added to your Mac’s keychain using Keychain Access. It is used to digitally sign your code.</p><h4 id="App-ID"><a href="#App-ID" class="headerlink" title="App ID"></a>App ID</h4><p>The application identifier is <strong>a string that uniquely identifies your application on the App Store</strong>. Application identifiers typically look like this: com.bignerdranch.AwesomeApp, where the name of the application follows the name of your company. The App ID in your provisioning profile must match the bundle identifier of your application. A development profile, like you just created, will have a wildcard character (*) for its App ID<br>and therefore will match any bundle identifier.</p><h4 id="Device-ID-UDID"><a href="#Device-ID-UDID" class="headerlink" title="Device ID (UDID)"></a>Device ID (UDID)</h4><p>This identifier is unique for each iOS device.</p><h4 id="Provisioning-Profile"><a href="#Provisioning-Profile" class="headerlink" title="Provisioning Profile"></a>Provisioning Profile</h4><p>This is a file that lives on your development device and on your computer. <strong>It references a Developer Certificate, a single App ID, and a list of the device IDs for the devices that the application can be installed on</strong>. When an application is deployed to a device, Xcode uses a provisioning profile on your computer to access the appropriate certificate. This certificate is used to sign the application binary. Then, the development device’s UDID is matched to one of the UDIDs contained within the provisioning profile, and the App ID is matched to the bundle identifier. The signed binary is then sent to your development device where it is confirmed by the same provisioning profile on the device and finally launched.</p><h2 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h2><h4 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h4><p>In a language like C, we have functions, and when we call a function, code is executed. If we try and call a function that doesn’t exist, the compiler says, “I can’t do that, Joe,” and the code will fail to compile. This is known as a <strong>compile-time error</strong>. Objective-C, being a dynamically typed language, isn’t able to figure out at compile time whether an object will respond to a message. (An object only responds to a message if its class implements the associated method.) The compiler will warn you if it thinks you are sending a message to an object that won’t respond, but the code will still compile. If, for some reason (and there are many), you end up sending a message to an object that doesn’t respond, your application will throw an exception, also known as a <strong>run-time error</strong>.</p><h2 id="Chapter-3"><a href="#Chapter-3" class="headerlink" title="Chapter 3"></a>Chapter 3</h2><h4 id="Autorelease-pool-draining"><a href="#Autorelease-pool-draining" class="headerlink" title="Autorelease pool draining"></a>Autorelease pool draining</h4><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1ewgybvtcynj21as0qigrf.jpg"></p><h2 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h2><h4 id="Projects-targets-and-frameworks"><a href="#Projects-targets-and-frameworks" class="headerlink" title="Projects, targets, and frameworks"></a>Projects, targets, and frameworks</h4><p>A project is <strong>a file that contains a list of references to other files (source code, resources, frameworks, and libraries) as well as a number of settings that lay out the rules for items within the project</strong>. Projects end in .xcodeproj, as in Whereami.xcodeproj. A project always has at least one target. </p><p>A target <strong>uses the files in the project to build a particular product</strong>. When you build and run, you build and run the target, not the project.</p><p>The product the target builds is typically <strong>an application, although it can be a compiled library or a unit test bundle</strong>. When you create a new project and choose a template, Xcode automatically creates a target for you.</p><p>A framework is <strong>a collection of related classes</strong> that you can add to a target. Cocoa Touch is a collection of frameworks. One of the benefits of Cocoa Touch being organized into frameworks is that you only have to add the frameworks that a target needs.</p><h4 id="Delegation"><a href="#Delegation" class="headerlink" title="Delegation"></a>Delegation</h4><p>Delegation is <strong>an object-oriented approach to callbacks</strong>. A callback is a function that is supplied in advance of an event and is called every time the event occurs. Some objects need to make a callback for more than one event. In a target-action pair, you have a target object that you send an action message to when an event occurs. The target must implement the action message, and, for each event, a new target-action pair must be created. With delegation, on the other hand, you set the delegate once and can then send it messages for different events. The delegate will implement the method for each event it wants to hear about.</p><h4 id="Build-Phases"><a href="#Build-Phases" class="headerlink" title="Build Phases"></a>Build Phases</h4><p>Building an application in Xcode takes several steps. We call these steps build phases.</p><ul><li><strong>Compile Sources</strong> This build phase contains the source code files that are compiled when this target is built. By default, any time you add a source code file to a project, it is added to this build phase.</li><li><strong>Link Binary With Libraries</strong> After your source code has been compiled, it is linked with the frameworks (libraries). This allows your code to use classes from these frameworks.</li><li><strong>Copy Bundle Resources</strong> After your code is compiled and linked, an executable is created and placed inside an application bundle, which is really just a folder. Then, the files listed in the Copy Bundle Resources phase are added to the bundle alongside the executable. These resources are the data files that your application uses at runtime, like MainWindow.xib and any images or sounds that are part of the application. By default, when you add a file to a project that is not source code, it is added to this build phase.</li></ul><h4 id="Preprocessing"><a href="#Preprocessing" class="headerlink" title="Preprocessing"></a>Preprocessing</h4><p>The goal of the preprocessing phase is to create an intermediate file for each implementation file (.m). The intermediate file is still Objective-C code like the implementation file, but the intermediate file can get very large. To create an intermediate file, the preprocessor resolves all the preprocessor directives in the implementation file. Preprocessor directives are statements prefixed with the pound symbol (#), like #import. The resolution of a #import statement replaces the import statement with the contents of the imported file.</p><p><img src="http://ww3.sinaimg.cn/mw690/9460be12gw1ewgycom7qtj21aq144auq.jpg"></p><h4 id="Compiling"><a href="#Compiling" class="headerlink" title="Compiling"></a>Compiling</h4><p>Once the preprocessor has finished, the generated intermediate files are compiled. Compiling an intermediate file takes the Objective-C code and turns it into machine code. This machine code is stored in an object file, one for each intermediate file. The compiling phase – the transition to machine code – is where we see most of our errors as programmers. When the compiler doesn’t understand our code, it generates an error. We call errors generated during this phase compile-time errors or syntax errors. Compile-time errors are typically misplaced semicolons, unbalanced brackets ([]) or braces ({}), spelling or capitalization errors.</p><h4 id="Linking"><a href="#Linking" class="headerlink" title="Linking"></a>Linking</h4><p>An object file contains the machine code for the methods implemented in the implementation file. However, within an implementation file, you use code from other implementation files. Instead of copying the code for this method into the object file, the compiler leaves a link to the other object file.</p><p>A framework is a collection of classes, and a class is defined by two files: a header file and an implementation file. A framework, however, has pre-compiled its implementation files and shoved the resulting object files into one or more library files. That’s why in Objective-C you can’t see the implementation files in a framework – they are already machine code.</p><p>If a link cannot be resolved (because the object file that contains the code cannot be found or because the object file doesn’t contain the referenced code), you get a linker error. Linker errors are more difficult for new developers to understand because they use unfamiliar terms and because there isn’t one line of code that generated the error.</p><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1ewh10qiz5wj21c20r0dub.jpg"></p><h2 id="Chapter-6"><a href="#Chapter-6" class="headerlink" title="Chapter 6"></a>Chapter 6</h2><h4 id="The-drawRect-method"><a href="#The-drawRect-method" class="headerlink" title="The drawRect: method"></a>The drawRect: method</h4><p>Each time an instance of UIView needs to be drawn (or redrawn), <strong>the system prepares a graphics context specifically for that view</strong>. Then the context is activated, and the message drawRect: is sent to the instance of UIView that is being drawn. The graphics context’s type is CGContextRef (Core Graphics Context Reference), and <strong>it is responsible for aggregating drawing commands and producing an image as a result</strong>. This image is the appearance of the view instance. A graphics context also stores its drawing state, which includes things like the current drawing color, coordinate system, and the current line width. Sometimes when drawing a view, you will use Objective-C to make calls defined in the UIKit framework that implicitly use the active graphics context. Other times, you will get hold of the graphics context explicitly and draw using the C functions of the Core Graphics framework. </p><h4 id="class"><a href="#class" class="headerlink" title="@class"></a>@class</h4><p>Notice the @class directive after the import statement. This is a forward declaration for the class. When you forward declare a class, you aren’t going as far as importing the header file; you are just informing the Header File of the class so the compiler can validate it. Forward declaring a class <strong>saves time when compiling – especially with large projects</strong>.</p><h4 id="Redrawing-Views"><a href="#Redrawing-Views" class="headerlink" title="Redrawing Views"></a>Redrawing Views</h4><p>When a UIView instance is sent the message setNeedsDisplay, that view is marked for re-display. View subclasses send themselves setNeedsDisplay when their drawable content changes. When a view has marked itself for re-display, it is not immediately redrawn; instead, <strong>it is added to a list of views that need updating</strong>. Your application is a giant infinite loop called the run loop. The run loop’s job is to check for input (a touch, Core Location updates, data coming in through a network interface, etc.) and then find the appropriate handlers for that event (like an action or delegate method for an object). Those handler methods call other methods, which call more methods, and so on. <strong>Views are not redrawn until after the methods have completed and control returns to the run loop</strong>.</p><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ewgydfbkgpj21h00rgall.jpg"></p><p>When control returns to the run loop, it says, “Well, a bunch of code was just executed. I’m going to check if any views need to be redrawn.” Then the run loop prepares the necessary drawing contexts and sends the message drawRect: to all of the views that have been sent setNeedsDisplay in this iteration of the loop. <strong>After a view has redrawn itself, its subviews are automatically asked to redraw themselves as well</strong>.</p><h2 id="Chapter-7"><a href="#Chapter-7" class="headerlink" title="Chapter 7"></a>Chapter 7</h2><h4 id="File’s-Owner"><a href="#File’s-Owner" class="headerlink" title="File’s Owner"></a>File’s Owner</h4><p>We need some way to connect objects loaded from the XIB file to objects that exist in memory before the XIB file is loaded. This way, the already existing CurrentTimeViewController could set its view instance variable to point at the view loaded from this XIB file. This is where the File’s Owner comes in. The File’s Owner is <strong>a placeholder object</strong>. When a XIB file is loaded, placeholder objects are not instantiated. You can think of a placeholder object as <strong>a hole in which existing objects can be placed</strong> so that connections can be made between them and the objects in the XIB file.</p><p><img src="http://ww1.sinaimg.cn/mw690/9460be12gw1ewgydpsmvfj216u0xon3b.jpg"></p><p>When your application first launches, an instance of UIApplication is created and it loads MainWindow.xib. The UIApplication is the File’s Owner. The File’s Owner of this file has a outlet connection for its delegate that has been connected to HypnoTimeAppDelegate. Therefore, after the XIB file loads, the delegate of the UIApplication is set to point at the HypnoTimeAppDelegate object – the reason why HypnoTimeAppDelegate gets sent the message application:didFinishLaunchingWithOptions:.</p><h4 id="The-View-Controller-Lifecycle-and-Low-Memory-Warnings"><a href="#The-View-Controller-Lifecycle-and-Low-Memory-Warnings" class="headerlink" title="The View Controller Lifecycle and Low-Memory Warnings"></a>The View Controller Lifecycle and Low-Memory Warnings</h4><p>A view controller, like any other object, is created through alloc and init. It does not, however, create its view at that time. Instead, <strong>it waits until the view is really needed before it calls loadView</strong>. When the system is running low on RAM, it issues a low-memory warning to the running application. The application responds by freeing up any resources that it doesn’t need at the moment and can easily recreate. View controllers, during a low-memory warning, are sent the message didReceiveMemoryWarning. The default implementation of this method will check to see if the view is currently on screen; if it is not, it is released. (If the view is on screen, nothing happens.)</p><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1ewgye7rnedj20zs10cgw5.jpg"></p><p><strong>A rule</strong>: Never access a view controller’s view in that view controller’s initialization method. If you have extra work you want to perform on the view, do so in viewDidLoad. This message is sent to a view controller each time it loads its view.</p><h2 id="Chapter-8"><a href="#Chapter-8" class="headerlink" title="Chapter 8"></a>Chapter 8</h2><h4 id="FirstResponder"><a href="#FirstResponder" class="headerlink" title="FirstResponder"></a>FirstResponder</h4><p>The window’s firstResponder is <strong>the object that gets sent all of the motion events</strong>. Motion events have nothing to do with the UIAccelerometer delegate. The system determines there is a shake by querying the accelerometer hardware and then sends the appropriate messages to the firstResponder.</p><h4 id="Retina-Display"><a href="#Retina-Display" class="headerlink" title="Retina Display"></a>Retina Display</h4><p>For vector graphics, like HypnosisView’s drawRect: method and drawn text, you don’t need to do anything; the same code will render as crisply as the device allows. However, if you draw using <strong>Core Graphics functions, these graphics will appear differently on different devices</strong>. In Core Graphics, also called Quartz, we describe lines, curves, text, etc. in terms of points. On a non-Retina display, a point is 1x1 pixel. On a Retina display, a point is 2x2 pixels.</p><p><img src="http://ww1.sinaimg.cn/mw690/9460be12gw1ewgyeeiejhj217s0hwaec.jpg"></p><p>Given these differences, bitmap images (like JPEG or PNG files) will be unattractive if the image isn’t tailored to the device’s screen type. Say your application includes a small image of 25x25 pixels. If this image is displayed on a Retina display, then the image must be stretched to cover an area of 50x50 pixels. At this point, the system does a type of averaging called anti-aliasing to keep the image from looking jagged. The result is an image that isn’t jagged – but it is fuzzy.</p><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ewgyeutxd3j219o0l810f.jpg"></p><p>You could use a larger file instead, but the averaging would then cause problems in the other direction when the image is shrunk for a non-Retina display. The only solution is to bundle two image files with your application: <strong>one at a pixel resolution equal to the number of points on the screen for non-Retina displays and one twice that size in pixels for Retina displays</strong>.</p><p>Fortunately, you do not have to write any extra code to handle which image gets loaded on which device. All you have to do is suffix the higher-resolution image with @2x. Then, when you use UIImage’s imageNamed: method to load the image, this method looks in the bundle and gets the file that is appropriate for the particular device.</p><h2 id="Chapter-9"><a href="#Chapter-9" class="headerlink" title="Chapter 9"></a>Chapter 9</h2><h4 id="NSNotificationCenter"><a href="#NSNotificationCenter" class="headerlink" title="NSNotificationCenter"></a>NSNotificationCenter</h4><p>The notification center does <strong>not retain observers</strong>. If an object registers with the notification center, that object must unregister before it is deallocated. If it doesn’t, the next time a notification it registered for is posted, the center will try to send the object a message. Since that object has been deallocated, your application will crash.</p><h4 id="Autosizing"><a href="#Autosizing" class="headerlink" title="Autosizing"></a>Autosizing</h4><p>You can click this control in six different places: on the four sides outside the inner box and along the vertical and horizontal axes inside the inner box. We call the outside four struts, and the inside two springs. Clicking on one of these areas toggles an autoresizing mask option. A solid red line means the option is on, and a dim red dotted line means the option is off.</p><p><strong>A spring</strong> that is turned on tells the view to <strong>change size when its superview changes size</strong>. For example, if you turn on the horizontal spring, the view will change its width at the same rate its superview changes its width.</p><p><strong>A strut</strong> tells the view to <strong>keep the margin between the view and its superview constant</strong>. For example, if you turn on the left strut, the view will maintain the distance from the left side of its superview when the superview changes its width.</p><p><img src="http://ww3.sinaimg.cn/mw690/9460be12gw1ewh10zfrvnj21160o045d.jpg"></p><h2 id="Chapter-10"><a href="#Chapter-10" class="headerlink" title="Chapter 10"></a>Chapter 10</h2><h4 id="UITableViewCells"><a href="#UITableViewCells" class="headerlink" title="UITableViewCells"></a>UITableViewCells</h4><p><strong>Table views can be broken up into sections, and each section has its own set of rows</strong>. A UITableViewCell is a subclass of UIView, and each row in a UITableView is a UITableViewCell. A table in iOS can only have one column, so a row only has one cell. The UITableViewCells are subviews of the UITableView.</p><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ewgyfcq1ukj21ac09k77d.jpg">. `</p><p>A cell itself has one subview – its contentView. The contentView is the superview for the content of the cell. </p><p><img src="http://ww1.sinaimg.cn/mw690/9460be12gw1ewh116tjwtj218c0rqjx0.jpg"></p><p>It also can draw an accessory indicator. The accessory indicator shows an action-oriented icon, such as a checkmark, a disclosure icon, or a fancy blue dot with a chevron inside. These icons are accessed through pre-defined constants for the appearance of the accessory indicator. </p><p><img src="http://ww1.sinaimg.cn/mw690/9460be12gw1ewgyfytt8oj21ai0l2dnh.jpg"></p><h4 id="Reusing-UITableViewCells"><a href="#Reusing-UITableViewCells" class="headerlink" title="Reusing UITableViewCells"></a>Reusing UITableViewCells</h4><p>iOS devices have a limited amount of memory. If we were displaying a list with thousands of entries in a UITableView, we would have thousands of instances of UITableViewCell. To preserve the lives of iOS devices everywhere, you can reuse table view cells. When the user scrolls the table, some cells move offscreen. <strong>Offscreen cells are put into a pool of cells available for reuse</strong>. Then, instead of creating a brand new cell for every request, the data source first checks the pool. If there is an unused cell, the data source configures it with new data and returns it to the table view.</p><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ewh11hoy2zj21b20t2gt7.jpg"></p><p>There is one problem: sometimes a UITableView has different types of cells. Occasionally, you have to subclass UITableViewCell to create a special look or behavior. However, different subclasses floating around the pool of reusable cells create the possibility of getting back a cell of the wrong type. You must be sure of the type of the cell returned to you so that you can be sure of what properties and methods it has.</p><h2 id="Chapter-11"><a href="#Chapter-11" class="headerlink" title="Chapter 11"></a>Chapter 11</h2><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ewgyh5uveuj21am0q2tgt.jpg"></p><h4 id="Editing-Mode"><a href="#Editing-Mode" class="headerlink" title="Editing Mode"></a>Editing Mode</h4><p>UITableView has an editing property, and when this property is set to YES, the UITableView enters editing mode. Once the table view is in editing mode, the rows of the table can be manipulated by the user. The user can change the order of the rows, add rows, or remove rows. Editing mode does not allow the user to edit the content of a row.</p><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1ewgyhnhdnpj21920wk490.jpg"></p><h4 id="NSBundle"><a href="#NSBundle" class="headerlink" title="NSBundle"></a>NSBundle</h4><p>To load a XIB file manually, you use NSBundle. <strong>This class is the interface between an application and the application bundle it lives in. When you want to access a file in the application bundle, you ask NSBundle for it</strong>. An instance of NSBundle is created when your application launches, and you can get a pointer to this instance by sending the message mainBundle to NSBundle.</p><p>XIB files are typically used to create the window and application delegate (MainWindow.xib) and to create the view for a view controller (for example, CurrentTimeViewController.xib). The code to load these XIB files is already written in the implementations of UIApplication and UIViewController. </p><p>However, as you can see, a XIB file can be used any time you wish to archive view objects, and any object can load a XIB file.</p><pre><code>- (UIView *)headerView&#123;       // If we haven&#39;t loaded the headerView yet...       if (!headerView) &#123;           // Load HeaderView.xib           [[NSBundle mainBundle] loadNibNamed:@&quot;HeaderView&quot; owner:self options:nil];       &#125;       return headerView;&#125;</code></pre><h4 id="Adding-Rows-amp-amp-Deleting-Rows-amp-amp-Moving-Rows"><a href="#Adding-Rows-amp-amp-Deleting-Rows-amp-amp-Moving-Rows" class="headerlink" title="Adding Rows &amp;&amp; Deleting Rows &amp;&amp; Moving Rows"></a>Adding Rows &amp;&amp; Deleting Rows &amp;&amp; Moving Rows</h4><p>Implement the corresponding DataSource Methods</p><h2 id="Chapter-12"><a href="#Chapter-12" class="headerlink" title="Chapter 12"></a>Chapter 12</h2><h4 id="UINavigationController"><a href="#UINavigationController" class="headerlink" title="UINavigationController"></a>UINavigationController</h4><p>When your application presents multiple screens of information, UINavigationController maintains a stack of those screens. <strong>The stack is an NSArray of view controllers, and each screen is the view of a UIViewController. When a UIViewController is on top of the stack, its view is visible</strong>. </p><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ewgyi3bxnoj21by0q8dpo.jpg"></p><p>When writing iOS applications, it is important to treat each UIViewController as its own little world. </p><p><img src="http://ww3.sinaimg.cn/mw690/9460be12gw1ewgyio1khcj21ca14wtkk.jpg"></p><h4 id="UINavigationBar"><a href="#UINavigationBar" class="headerlink" title="UINavigationBar"></a>UINavigationBar</h4><p>Every UIViewController has a navigationItem property of type UINavigationItem. However, unlike UINavigationBar, UINavigationItem is not a subclass of UIView, so it cannot appear on the screen. Instead, the navigation item supplies the navigation bar with the content it needs to draw. When a UIViewController comes to the top of a UINavigationController’s stack, the UINavigationBar uses the UIViewController’s navigationItem to configure itself.</p><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ewgyivfkt5j217g0g8wix.jpg"></p><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ewgyj492i4j219q0gsgrc.jpg"></p><p><img src="http://ww3.sinaimg.cn/mw690/9460be12gw1ewgyjltkklj21cy0kigu5.jpg"></p><h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h4><p><strong>The SEL data type is a pointer to a selector. A selector is a unique ID for a method</strong>. Wrapping a method name in the @selector() directive returns the SEL that points at that method. Remember that a selector is the entire method name including any colons. </p><p>Notice that @selector() <strong>doesn’t care about the return type, argument types, or names of arguments</strong> – only the selector itself. Also, know that @selector() <strong>doesn’t check to see if the method actually exists</strong>. If you give a SEL to a button, that button will send the corresponding message regardless of whether the method is implemented by the target.</p><h4 id="Pushing-view-controllers"><a href="#Pushing-view-controllers" class="headerlink" title="Pushing view controllers"></a>Pushing view controllers</h4><p>When using a UINavigationController, you cannot simply store all of the possible view controllers in its stack. The viewControllers array of a navigation controller is <strong>dynamic</strong> – you start with a root view controller and add view controllers depending on user input.</p><p>Any view controller in a navigation controller’s stack can get a pointer to the navigation controller by sending itself the message <strong>navigationController</strong>. </p><p>Having a view controller push the next view controller is a common pattern. In any application with a UINavigationController, the navigation controller has one root view controller. The root view controller typically creates the next view controller, and the next view controller creates the one after that, and so on. </p><h2 id="Chapter-13"><a href="#Chapter-13" class="headerlink" title="Chapter 13"></a>Chapter 13</h2><p>A UIToolbar works a lot like a UINavigationBar in that you can add UIBarButtonItems to it. However, where a navigation bar has two bar button items, a toolbar has an array of items. You can place as many UIBarButtonItems in a toolbar as can fit on the screen.</p><p><img src="http://ww2.sinaimg.cn/mw690/9460be12gw1ewgyk5j5luj21ew14cgw0.jpg"></p><p>When a view controller is modal, it takes over the entire screen until it has finished its work. To present a view modally, presentModalViewController:animated: is sent to the UIViewController whose view is on the screen. The view controller to be presented is passed to it, and its view slides up from the bottom of the screen.</p><p>A view controller should re-populate its view’s subviews with data whenever it is sent the message viewWillAppear:, eliminating the possibility that a low-memory warning could wipe out its content.</p><h2 id="Chapter-14"><a href="#Chapter-14" class="headerlink" title="Chapter 14"></a>Chapter 14</h2><p>Show a view controller’s view: </p><ul><li>Set it as the root view controller of the window</li><li>Push it onto a UINavigationController’s stack</li><li>Add it to a UITabBarController</li><li>Present it modally</li></ul><p>Every view controller has a property named <strong>modalViewController</strong>. If a view controller presents another view controller modally, then this property holds a pointer to that view controller. Every modally-presented view controller has a pointer named <strong>parentViewController</strong> that it sets to the view controller.</p><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1ewgykcc1iqj212y0getbu.jpg"></p><h2 id="Chapter-15"><a href="#Chapter-15" class="headerlink" title="Chapter 15"></a>Chapter 15</h2><h4 id="Saving-Loading-and-Multitasking"><a href="#Saving-Loading-and-Multitasking" class="headerlink" title="Saving, Loading, and Multitasking"></a>Saving, Loading, and Multitasking</h4><p>Every iOS application has its own application sandbox. An application sandbox is <strong>a directory on the filesystem that is barricaded from the rest of the filesystem</strong>. Your application must stay in its sandbox, and no other application can access your sandbox.</p><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1ewgykp63z7j215k0igtfl.jpg"></p><h4 id="application-bundle"><a href="#application-bundle" class="headerlink" title="application bundle"></a>application bundle</h4><p>This directory contains all the <strong>resources and the executable</strong>. It is read-only.</p><h4 id="Library-Preferences"><a href="#Library-Preferences" class="headerlink" title="Library/Preferences/"></a>Library/Preferences/</h4><p>This directory is where any preferences are stored and where the Settings application looks for <strong>application preferences</strong>. Library/Preferences is handled automatically by the class NSUserDefaults (which you will learn about in Chapter 19) and is backed up when the device is synchronized with iTunes.</p><h4 id="tmp"><a href="#tmp" class="headerlink" title="tmp/"></a>tmp/</h4><p>This directory is <strong>where you write data that you will use temporarily during an application’s runtime</strong>. You should remove files from this directory when done with them, and the operating system may purge them while your application is not running. It does not get backed up when the device is synchronized with iTunes. To get the path to the tmp directory in the application sandbox, you can use the convenience function <strong>NSTemporaryDirectory</strong>.</p><h4 id="Documents"><a href="#Documents" class="headerlink" title="Documents/"></a>Documents/</h4><p>This directory is <strong>where you write data that the application generates during runtime and that you want to persist between runs of the application</strong>. It is backed up when the device is synchronized with iTunes. If something goes wrong with the device, files in this directory can be restored from iTunes. For example, in a game application, the saved game files would be stored here.</p><h4 id="Library-Caches"><a href="#Library-Caches" class="headerlink" title="Library/Caches/"></a>Library/Caches/</h4><p>This directory is where you write data that the application generates during runtime and that you want to persist between runs of the application. However, unlike the Documents directory, <strong>it does not get backed up when the device is synchronized with iTunes</strong>. A major reason for not backing up cached data is that the data can be very large and extend the time it takes to synchronize your device. Data stored somewhere else – like a web server – can be placed in this directory. If the user needs to restore the device, this data can be downloaded from the web server again.</p><h4 id="Archiving"><a href="#Archiving" class="headerlink" title="Archiving"></a>Archiving</h4><p>There are many ways to write data to the filesystem on iOS, and one of the most important is called archiving. <strong>Archiving is the process of taking one or more objects from memory and writing them to the filesystem. Unarchiving reads these objects back from the filesystem into memory</strong>.</p><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1ewgyl4gq9hj21cy0qawos.jpg"></p><p>Archiving works by creating an instance of NSCoder, which is essentially just a container for data, and placing objects and their data inside it. Once the NSCoder has all of the data you have instructed it to collect, it will be written to a specific file in the filesystem.</p><p><img src="http://ww3.sinaimg.cn/mw690/9460be12gw1ewgylc534dj217m0jmgpz.jpg"></p><p>Not all objects can be archived – only those whose class conforms to the NSCoding protocol. The NSCoding protocol has two methods, and both are required: encodeWithCoder: (for archiving) and initWithCoder: (for unarchiving).</p><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1ewgylrbeapj21gc0m8k00.jpg"></p><p>Like NSString, the classes NSDictionary and NSArray have writeToFile: and initWithContentsOfFile: methods. In order to write objects of these types to the filesystem in this fashion, they must contain <strong>only property list serializable objects</strong>. The only objects that are property list serializable are <strong>NSString</strong>, <strong>NSNumber</strong>, <strong>NSDate</strong>, <strong>NSData</strong>, <strong>NSArray</strong>, and <strong>NSDictionary</strong>. When an NSArray or NSDictionary is written to the filesystem with these methods, an XML property list is created.</p><h4 id="Application-States-Transitions-and-Multitasking"><a href="#Application-States-Transitions-and-Multitasking" class="headerlink" title="Application States, Transitions, and Multitasking"></a>Application States, Transitions, and Multitasking</h4><p>An application in the suspended state cannot execute code, and any resources it doesn’t need while suspended are released. A suspended application is essentially freeze-dried and can be quickly thawed when the user relaunches it. The resources that are released are ones that can be reloaded, like cached images, system-managed caches, and other graphics data.</p><p><img src="http://ww3.sinaimg.cn/mw690/9460be12gw1ewgymcadzxj21e210egxs.jpg"></p><h4 id="The-Application-Bundle"><a href="#The-Application-Bundle" class="headerlink" title="The Application Bundle"></a>The Application Bundle</h4><p>When you build an iOS application project in Xcode, you create an application bundle. The application bundle contains the <strong>application executable and any resources</strong> you have bundled with your application. Resources are things like XIB files, images, audio files – any files that will be used at runtime. When you add a resource file to a project, Xcode is smart enough to realize that it should be bundled with your application and categorizes it accordingly.</p><p>Also, files within the application bundle are <strong>read-only</strong>. You <strong>cannot</strong> <strong>modify</strong> them nor can you <strong>dynamically</strong> <strong>add</strong> files to the application bundle at runtime. Files in the application bundle are typically things like button images, interface sound effects, or the initial state of a database you ship with your application. You will use this method in later chapters to load these types of resources at runtime.</p><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1ewgymvhfpuj21cc0n0k2f.jpg"></p><h2 id="Chapter-16"><a href="#Chapter-16" class="headerlink" title="Chapter 16"></a>Chapter 16</h2><h4 id="Subclassing-UITableViewCell"><a href="#Subclassing-UITableViewCell" class="headerlink" title="Subclassing UITableViewCell"></a>Subclassing UITableViewCell</h4><p>You subclass UITableViewCell by changing the view objects in a cell’s contentView. Adding subviews to the contentView instead of directly to the UITableViewCell subclass is important because the cell will resize the contentView at certain times. For example, when a table view enters editing mode, the contentView redraws itself to make room for the editing controls.</p><p><img src="http://ww1.sinaimg.cn/mw690/9460be12gw1ewgyncuc8bj21cs0pcajj.jpg"></p><p>If you were to add subviews directly to the UITableViewCell, these editing controls would obscure the subviews. The cell doesn’t know to adjust its size when entering edit mode, but the contentView does.</p><h4 id="Laying-out-subviews"><a href="#Laying-out-subviews" class="headerlink" title="Laying out subviews"></a>Laying out subviews</h4><p>When a table view’s data source is asked for a cell, it creates a cell, configures its content, and returns it to the table view. The table view then adds the cell as a subview of itself and positions and sizes the cell. Therefore, when you first create a cell, it doesn’t know its size quite yet. For this reason, you do not set the frames of a cell’s content view at initialization time. Instead, you wait until the cell knows how big it is.</p><p>First, you always invoke the superclass’ implementation of <strong>layoutSubviews</strong>. Invoking this method allows the UITableViewCell to layout its subview, the contentView. Then, you get the bounds of the contentView to find out how much area you have to work with when sizing and positioning all of the subviews. (If you don’t invoke the superclass’ implementation of layoutSubviews, the bounds of the contentView may not be correct.) Finally, you set the frame of each subview relative to the contentView’s bounds.</p><h2 id="Chapter-18"><a href="#Chapter-18" class="headerlink" title="Chapter 18"></a>Chapter 18</h2><p>Internationalization is making sure your native cultural information is <strong>not hard-coded</strong> into your application. (By cultural information, we mean language, currency, date formats, number formats, and more.) Localization, on the other hand, is providing the appropriate data in your application <strong>based on the user’s Language and Region Format settings</strong>. NSLocale knows how different regions display symbols, dates, and decimals and whether they use the metric system.</p><h4 id="Localizing-Resources"><a href="#Localizing-Resources" class="headerlink" title="Localizing Resources"></a>Localizing Resources</h4><p>Localization is the process by which application-specific substitutions given a region or a language setting are created. This usually means one of two things:</p><ul><li>Generating multiple copies of resources like images, sounds, and interfaces for different regions and languages</li><li>Creating and accessing “strings tables” to translate text into different languages</li></ul><p><strong>ibtool</strong></p><h4 id="NSLocalizedString-and-Strings-Tables"><a href="#NSLocalizedString-and-Strings-Tables" class="headerlink" title="NSLocalizedString and Strings Tables"></a>NSLocalizedString and Strings Tables</h4><p>A strings table is a file containing a list of key-value pairs for all of the strings your application uses and their associated translations. </p><p><strong>NSLocalizedString()</strong>.</p><h4 id="NSBundle’s-Role-in-Internationalization"><a href="#NSBundle’s-Role-in-Internationalization" class="headerlink" title="NSBundle’s Role in Internationalization"></a>NSBundle’s Role in Internationalization</h4><p>The real work of adding a localization is done for you by the class NSBundle. For example, when a UIViewController is initialized, it is given two arguments: the name of a XIB file and an NSBundle object. The bundle argument is typically nil, which is interpreted as the application’s main bundle. (The main bundle is another name for the application bundle – all of the resources and the executable for the application. When an application is built, all of the lproj directories are copied into this bundle.)</p><p>When the view controller loads its view, it asks the bundle for the XIB file. The bundle, being very smart, <strong>checks the current language settings of the device and looks in the appropriate lproj directory</strong>. The path for the XIB file in the lproj directory is returned to the view controller and loaded.</p><p>NSBundle knows how to search through localization directories for every type of resource using the instance method pathForResource:ofType:. When you want a path to a resource bundled with your application, you send this message to the main bundle. Here’s an example using the resource file myImage.png:</p><pre><code>NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;myImage&quot; ofType:@&quot;png&quot;];</code></pre><p>The bundle first checks to see if there is a myImage.png file in the top level of the application bundle. If so, it returns the full path to that file. <strong>If not, the bundle gets the device’s language settings and looks in the appropriate lproj directory to construct the path</strong>. If no file is found, it returns nil.</p><p>This is why you must delete and clean an application when you localize a file. The previous un-localized file will still be in the root level of the application bundle because Xcode will not delete a file from the bundle when you re-install. Even though there are lproj folders in the application bundle, the bundle finds the top-level file first and returns its path.</p><h2 id="Chapter-19"><a href="#Chapter-19" class="headerlink" title="Chapter 19"></a>Chapter 19</h2><h4 id="NSUserDefaults"><a href="#NSUserDefaults" class="headerlink" title="NSUserDefaults"></a>NSUserDefaults</h4><p>These temporary defaults are placed in the <strong>registration domain</strong> of NSUserDefaults. Any preferences set by the user are stored in a different domain, the <strong>application domain</strong>.<br>By default, the application domain is empty: there are no keys and no values. The first time a user changes a setting, a value is added to the application domain for the specified key. When you ask the NSUserDefaults for the value of a preference, <strong>it first looks in the application domain</strong>. If there is a value for that key, then the user has set a preference, and the NSUserDefaults returns that value. If not, the NSUserDefaults looks in the registration domain and finds the temporary default.</p><p><strong>The application domain is always saved to disk; that’s why it remembers user preferences on the next launch. The registration domain is not, and its values must be set every time the application launches</strong>. To set the values of the registration domain, you create an NSDictionary with a key-value pair for each preference you plan on using in your application. Then, you send the dictionary as an argument to the message registerDefaults: of NSUserDefaults.</p><p>Typically, you send the <strong>registerDefaults:</strong> message before any object is able to access the instance of NSUserDefaults. This means before the instance of the application delegate is created. What comes before the creation of the WhereamiAppDelegate? The creation of the WhereamiAppDelegate class. Like any object, a class also must be initialized before it can receive messages. So, after a class is created but before it receives its first message, it is sent the message initialize.</p><pre><code>+ (void)initialize&#123;    NSDictionary *defaults = [NSDictionary                            dictionaryWithObject:[NSNumber numberWithInt:1]                                          forKey:WhereamiMapTypePrefKey];    [[NSUserDefaults standardUserDefaults] registerDefaults:defaults];&#125;</code></pre><h2 id="Chapter-21"><a href="#Chapter-21" class="headerlink" title="Chapter 21"></a>Chapter 21</h2><h4 id="The-Static-Analyzer"><a href="#The-Static-Analyzer" class="headerlink" title="The Static Analyzer"></a>The Static Analyzer</h4><p>When the static analyzer checks the code, it examines each function and method individually by <strong>iterating over every possible code path</strong>. A method can have a number of control statements (if, for, switch, etc.). The conditions of these statements will dictate which code is actually executed. A code path is one of the possible paths the code will take given these control statements.</p><h4 id="Xcode-Schemes"><a href="#Xcode-Schemes" class="headerlink" title="Xcode Schemes"></a>Xcode Schemes</h4><p><strong>A workspace is a collection of projects, and a project is a collection targets and files. A target has a number of build settings and phases that reference files from its project. When built, a target creates a product, which is usually an application. A scheme contains one or more targets and specifies what to do with the product or products</strong>.</p><p><img src="http://ww3.sinaimg.cn/mw690/9460be12gw1ewh14b3y30j21ae1dgttj.jpg"></p><p>When you create a new project, a scheme with the same name as the project is created for you. </p><h4 id="Creating-a-new-scheme"><a href="#Creating-a-new-scheme" class="headerlink" title="Creating a new scheme"></a>Creating a new scheme</h4><p>As projects become larger and more complicated, they require more specific testing and debugging. This can result in more time fiddling with the options for scheme actions. <strong>To avoid constant fiddling, we typically create new schemes for common situations</strong>. For example, if we have an application that consumes a lot of memory, we might want to routinely run the Allocations instrument on it. Instead of having Instruments ask which instrument to use when we profile the application, we can set up a new scheme that always runs Allocations.</p><h4 id="Build-Settings"><a href="#Build-Settings" class="headerlink" title="Build Settings"></a>Build Settings</h4><p>Every target includes build settings that describe how it should be built. Every project also has build settings that serve as defaults for all the targets within the project.</p><p>The far right column shows the iOS Default settings; these serve as the <strong>project’s defaults</strong>, which it can override. The next column to the left shows the <strong>project’s settings</strong>, and the one after that shows the currently selected <strong>target’s settings</strong>. The Resolved column shows which setting will actually be used; <strong>it is always be equal to the left-most specified value</strong>.</p><p><img src="http://ww1.sinaimg.cn/mw690/9460be12gw1ewgyo5m80pj21hy09yn39.jpg"></p><p>Each target and project has multiple build configurations. <strong>A build configuration is a set of build settings</strong>. When you create a project, there are two build configurations: <strong>debug</strong> and <strong>release</strong>. The build settings for the debug configuration make it easier to debug your application, while the <strong>release settings turn on optimizations to speed up execution</strong>.</p><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1ewlfp4kcjmj21g80hkn5f.jpg"></p><p>When performing a scheme action, the scheme will use one of these configurations when building its targets. You can specify the build configuration that the scheme uses in the scheme editor in the option for Build Configuration in the Info pane.</p><p><img src="http://ww1.sinaimg.cn/mw690/9460be12gw1ewlfn87ka7j21dk0nq457.jpg"></p><h2 id="Chapter-22"><a href="#Chapter-22" class="headerlink" title="Chapter 22"></a>Chapter 22</h2><p>At its core, an instance of CALayer is <strong>a buffer containing a bitmap</strong>. When you draw a layer (or a stack of layers), the rendering is <strong>hardware-accelerated</strong>. This makes drawing a layer to the screen incredibly fast. A CAAnimation object <strong>causes a change over time</strong>.</p><h4 id="Layers-and-views"><a href="#Layers-and-views" class="headerlink" title="Layers and views"></a>Layers and views</h4><p>A view doesn’t know how to draw to the screen; it only knows how to draw to an instance of CALayer. When you instantiate a view, it creates a layer, and when the view draws, it is drawing on its layer. We call layers created by views <strong>implicit layers</strong>. Because every view has a layer, there is a matching layer hierarchy that mimics the view hierarchy. After the views draw on their layers, the layers are <strong>composited</strong> to the screen.</p><p><img src="http://ww1.sinaimg.cn/mw690/9460be12gw1ewgyonjc2jj219q0qe7bn.jpg"></p><p>UIView is a subclass of UIResponder. A view is really an abstraction of a visible object that can be interacted with on the screen, wrapped into a tidy class. A layer, on the other hand, is all about the drawing.</p><h4 id="Creating-a-CALayer"><a href="#Creating-a-CALayer" class="headerlink" title="Creating a CALayer"></a>Creating a CALayer</h4><p>Not all layers are implicit layers. You can create a layer by sending alloc to the class CALayer. Layers created this way are called <strong>explicit layers</strong>.</p><h4 id="Layer-Content"><a href="#Layer-Content" class="headerlink" title="Layer Content"></a>Layer Content</h4><p>A layer is simply a bitmap, and its contents can be set programmatically or with an image. To set the contents programmatically, you either <strong>subclass</strong> CALayer or <strong>assign a delegate</strong> to an instance of CALayer. The delegate then implements drawing routines.</p><p>Because layers exist in a hierarchy, they can have sublayers, and each layer has a pointer back to its parent layer called <strong>superlayer</strong>. When a layer is composited to the screen, it is copied to the screen, and then each sublayer is composited atop it. Therefore, a layer always draws on top of its superlayer.</p><p>When the Z-axis is discussed, some developers imagine that perspective is applied, and they expect a layer to appear larger as its zPosition increases. However, Core Animation layers are presented orthographically; they do not appear as different sizes based on their zPositions.</p><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1ewgyotd61yj21dy0omjvl.jpg"></p><h4 id="Implicitly-Animatable-Properties"><a href="#Implicitly-Animatable-Properties" class="headerlink" title="Implicitly Animatable Properties"></a>Implicitly Animatable Properties</h4><p>Several of the properties of CALayer are <strong>implicitly animatable</strong>. This means that changes to these properties are automatically animated when their setters are called.</p><p>To disable an implicit animation, you can use an animation transaction. <strong>Animation transactions allow you to batch animations and set their parameters</strong>, like the duration and animation curve. To begin a transaction, you send the message begin to the class CATransaction. To end a transaction, you send commit to CATransaction. Within the begin and commit block, you can set properties of a layer and also set values for the transaction as a whole.</p><pre><code>[CATransaction begin];[CATransaction setDisableActions:YES];[CATransaction commit];</code></pre><h4 id="Programmatically-Generating-Content"><a href="#Programmatically-Generating-Content" class="headerlink" title="Programmatically Generating Content"></a>Programmatically Generating Content</h4><ul><li>Subclass - drawInContext:</li><li>Delegate - drawLayer:inContext:</li></ul><p>For both subclassing and delegation, you must send an <strong>explicit setNeedsDisplay</strong> to the layer in order for these methods to be invoked. Otherwise, the layer thinks it doesn’t have any content and won’t draw.</p><h4 id="Layers-Bitmaps-and-Contexts"><a href="#Layers-Bitmaps-and-Contexts" class="headerlink" title="Layers, Bitmaps, and Contexts"></a>Layers, Bitmaps, and Contexts</h4><p>A layer is simply a bitmap – <strong>a chunk of memory that holds the red, green, blue, and alpha values of each pixel</strong>. When you send the message setNeedsDisplay to a UIView instance, that method is forwarded to the view’s layer. After the run loop is done processing an event, every layer marked for re-display prepares a CGContextRef. Drawing routines called on this context generate pixels that end up in the layer’s bitmap.</p><p>How do drawing routines get called on the layer’s context? After a layer prepares its context, it sends the message <strong>drawLayer:inContext:</strong> to its delegate. The delegate of an implicit layer is its view, so in the implementation for drawLayer:inContext:, the view sends drawRect: to itself.</p><p>A layer creates the same kind of context when it needs to redraw its contents.</p><h2 id="Chapter-23"><a href="#Chapter-23" class="headerlink" title="Chapter 23"></a>Chapter 23</h2><p>An animation object drives change over time. An animation object is an instruction set (“Move from point A to point B over 2 seconds”) that can be added to a CALayer instance.</p><h4 id="Animation-Objects"><a href="#Animation-Objects" class="headerlink" title="Animation Objects"></a>Animation Objects</h4><p><img src="http://ww4.sinaimg.cn/mw690/9460be12gw1ewgypa0hd7j21bc0oqqbn.jpg"></p><p><strong>CAPropertyAnimation</strong> is a subclass of CAAnimation that extends the ability of its superclass by adding the ability to change the properties of a layer. Each property animation has a key path of type NSString. This string is the name of an <strong>animatable property</strong> of a CALayer. Many of CALayer’s properties are animatable. CAPropertyAnimation is an abstract superclass. To create an animation object that modifies a property of a layer, you use one of the two concrete subclasses of CAPropertyAnimation: CABasicAnimation and CAKeyframeAnimation.</p><p><strong>CABasicAnimation</strong> has two properties: <strong>fromValue</strong> and <strong>toValue</strong>, and it inherits CAAnimation’s duration property. When a basic animation is added to a layer, the property to be animated is set to the value in fromValue. Over the time specified by duration, the value of the property is interpolated linearly from fromValue to toValue.</p><p>The difference between CABasicAnimation and <strong>CAKeyframeAnimation</strong> is that a basic animation only interpolates two values while a keyframe animation can interpolate as many values as you give it. These values are put into an NSArray in the order in which they are to occur. This array is then set as the values property of a CAKeyframeAnimation instance. Each value in the values property is called a <strong>keyframe</strong>. Keyframes are the values that the animation will interpolate; the animation will take the property it is animating through each of these keyframes over its duration. A basic animation is really a keyframe animation that is limited to two keyframes. (In addition to allowing more than two keyframes, CAKeyframeAnimation adds the ability to change the timing of each of the keyframes)</p><p>A <strong>CAAnimationGroup</strong> instance holds an array of animation objects. When an animation group is added to a layer, the animations run <strong>concurrently</strong>.</p><p><strong>CATransition</strong> animates layers as they are transitioning on and off the screen. On Mac OS X, CATransition is made very powerful by Core Image Filters. In iOS, it can only do a couple of simple transitions like fading and sliding. (CATransition is used by UINavigationController when pushing a view controller’s view onto the screen.) CATransaction <strong>turn off implicit animations</strong> for any layer modifications occurring within the transaction.</p><h4 id="The-Presentation-Layer-and-the-Model-Layer"><a href="#The-Presentation-Layer-and-the-Model-Layer" class="headerlink" title="The Presentation Layer and the Model Layer"></a>The Presentation Layer and the Model Layer</h4><p>CALayer as having two parts: <strong>the content</strong> that gets composited onto the screen, and <strong>a set of parameters</strong> that describe how it should be composited: opacity, transform, position, etc. When a layer is being animated, it actually has two copies of these parameters: the <strong>model version</strong> and the <strong>presentation version</strong>. The presentation parameters are the ones that are being smoothly changed by the animation object. The model parameters are the persistent ones – the ones that will be used once the animation is over. So, when a layer is being animated, its content is composited to the screen using the presentation parameters. When it is animation-less, the model parameters are used.</p><h2 id="Chapter-24"><a href="#Chapter-24" class="headerlink" title="Chapter 24"></a>Chapter 24</h2><p>A block is <strong>a set of instructions</strong> that can be passed around as a variable and called like a function. Blocks provide conveniences for a programmer and performance boosts for applications. If you are familiar with other high-level languages, you may know blocks as <strong>closures or anonymous functions</strong>. Block <strong>captures variables</strong> which separates it from function pointers. You can define the block’s code at the same point where the block is registered as a callback. This keeps your code nice and clean.</p><p>Categories have another use: <strong>pseudo-private methods</strong>.</p><h4 id="Pros-and-Cons-of-Callback-Options"><a href="#Pros-and-Cons-of-Callback-Options" class="headerlink" title="Pros and Cons of Callback Options"></a>Pros and Cons of Callback Options</h4><p>Callbacks have two major components: <strong>the process of registering it and the code for the callback</strong>.</p><p><img src="http://ww1.sinaimg.cn/mw690/9460be12gw1ewgypole3qj21bw0ri45v.jpg"></p><p>You use <strong>target-action</strong> when you have a close relationship between the two objects (like a view controller and one of its views) and when there may be many instances of object that call back.</p><p><strong>Delegation</strong> is used when an object receives many events and it wants the same object to handle each of those events.</p><p><strong>Notifications</strong> are used when you want multiple objects to invoke their callback for the same event and/ or when two objects are not related.</p><p><strong>Blocks</strong> are the outliers when it comes to callbacks because they are not an object-oriented approach. Blocks are useful when the callback is going to happen only once or when the callback is just a quick and simple task (like updating a progress bar). One of the reasons blocks are better suited for this one-shot behavior is because they will retain any objects they reference.</p><p>An approach to callbacks we have not discussed is <strong>subclassing</strong>.</p><h2 id="Chapter-25"><a href="#Chapter-25" class="headerlink" title="Chapter 25"></a>Chapter 25</h2><p>An <strong>NSURL</strong> instance contains the location of a web application in URL format.</p><p>An <strong>NSURLRequest</strong> instance holds all the data necessary to communicate with a web server.</p><p>An <strong>NSURLConnection</strong> instance is responsible for actually making the connection to a web server, sending the information in its NSURLRequest, and gathering the response from the server.</p>]]></content>
    
    
    
    <tags>
      
      <tag>Tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
